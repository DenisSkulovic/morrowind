// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.12.4
// source: dialogue.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { ContextDTO } from "./entities";

export const protobufPackage = "dialogue";

/**
 * ============================================================================
 * Initialize Dialogue
 * ============================================================================
 */
export interface InitializeDialogueRequest {
  initiatingParticipantId: string;
  playerCharacterId: string;
  /** e.g. OPENAI_V1 */
  aiProvider: string;
  dialogueParticipants: CharacterProfilesDTO | undefined;
  worldContext: WorldContextDTO | undefined;
  dialogueHistory: DialogueHistoryDTO | undefined;
  knowledgeBase:
    | KnowledgeBaseDTO
    | undefined;
  /** User, World, Campaign */
  context: ContextDTO | undefined;
}

export interface InitializeDialogueResponse {
  dialogueId: string;
}

/**
 * ============================================================================
 * Character Profile
 * ============================================================================
 */
export interface CharacterProfileDTO {
  id: string;
  name: string;
  race: string;
  class: string;
  traits: string;
  enneagram: string;
  mood: string;
  needs: string;
  goals: CharacterGoalsDTO | undefined;
  skills: { [key: string]: number };
  stats: { [key: string]: string };
  inventory: CharacterInventoryDTO | undefined;
  knowledge: CharacterKnowledgeDTO | undefined;
  dialogueAttitude: string;
}

export interface CharacterProfileDTO_SkillsEntry {
  key: string;
  value: number;
}

export interface CharacterProfileDTO_StatsEntry {
  key: string;
  value: string;
}

export interface CharacterGoalsDTO {
  satisfied: string[];
  unsatisfied: string[];
}

export interface CharacterInventoryDTO {
  equipped: string[];
  stored: string[];
}

export interface CharacterKnowledgeDTO {
  locations: string[];
  factions: string[];
  familiarCharacters: string[];
}

export interface CharacterProfilesDTO {
  arr: CharacterProfileDTO[];
}

/**
 * ============================================================================
 * World Context
 * ============================================================================
 */
export interface WorldContextDTO {
  location: LocationContextDTO | undefined;
  time: TimeContextDTO | undefined;
  weather: WeatherContextDTO | undefined;
  scene: SceneContextDTO | undefined;
  clazz: string;
}

export interface LocationContextDTO {
  id: string;
  name: string;
  description: string;
  biome: string;
  clazz: string;
}

export interface TimeContextDTO {
  timeOfDay: string;
  day: number;
  month: string;
  year: number;
  season: string;
  clazz: string;
}

export interface WeatherContextDTO {
  weather: string;
  temperature: string;
  wind: string;
  precipitation: string;
  visibility: string;
  clazz: string;
}

export interface SceneContextDTO {
  north: DirectionSceneEntryDTO | undefined;
  northEast: DirectionSceneEntryDTO | undefined;
  east: DirectionSceneEntryDTO | undefined;
  southEast: DirectionSceneEntryDTO | undefined;
  south: DirectionSceneEntryDTO | undefined;
  clazz: string;
}

export interface DirectionSceneEntryDTO {
  near: SceneEntryDTO | undefined;
  mid: SceneEntryDTO | undefined;
  far: SceneEntryDTO | undefined;
  clazz: string;
}

export interface SceneEntryDTO {
  biome: string;
  NPCs: SceneNPCsDTO | undefined;
  items: SceneItemsDTO | undefined;
  clazz: string;
}

export interface SceneNPCDTO {
  id: string;
  activity: string;
  clazz: string;
}

export interface SceneNPCsDTO {
  arr: SceneNPCDTO[];
}

export interface SceneItemDTO {
  id: string;
  clazz: string;
}

export interface SceneItemsDTO {
  arr: SceneItemDTO[];
}

/**
 * ============================================================================
 * Dialogue History
 * ============================================================================
 */
export interface DialogueHistoryDTO {
  topicsNewestToOldest: DialogueHistoryTopicsDTO | undefined;
  clazz: string;
}

export interface DialogueHistoryTopicDTO {
  topicName: string;
  stepsNewestToOldest: DialogueStepsDTO | undefined;
  clazz: string;
}

export interface DialogueHistoryTopicsDTO {
  arr: DialogueHistoryTopicDTO[];
}

export interface DialogueStepDTO {
  playerStep: PlayerCharacterStepDTO | undefined;
  aiStep: AiCharacterStepDTO | undefined;
  narration: string;
  outcome: StepOutcomeDTO | undefined;
  clazz: string;
}

export interface DialogueStepsDTO {
  arr: DialogueStepDTO[];
}

export interface DiceRollResultDTO {
  roll: number;
  outcome: string;
  scaleType: string;
  usedScaleConfig: string;
  clazz: string;
}

export interface PlayerCharacterStepDTO {
  characterId: string;
  selectedDialogueOption: string;
  diceRollResult: DiceRollResultDTO | undefined;
  clazz: string;
}

export interface AiCharacterStepDTO {
  characterId: string;
  selectedDialogueOption: string;
  diceRollResult: DiceRollResultDTO | undefined;
  clazz: string;
}

export interface StepOutcomeDTO {
  characterChanges: { [key: string]: CharacterChangesDTO };
  newTopicName: string;
  stepOutcome: string;
  clazz: string;
}

export interface StepOutcomeDTO_CharacterChangesEntry {
  key: string;
  value: CharacterChangesDTO | undefined;
}

export interface CharacterChangeDTO {
  markUnfulfilledGoalsAsFulfilled: string[];
  addUnfulfilledGoals: string[];
  removeUnfulfilledGoals: string[];
  changeDialogueAttitudeTo: string;
  addOrRemoveOrModifyItemInInventory: InventoryChangesDTO | undefined;
}

export interface CharacterChangesDTO {
  arr: CharacterChangeDTO[];
}

export interface InventoryChangeDTO {
  itemId: string;
  quantityDeltaChange: number;
}

export interface InventoryChangesDTO {
  arr: InventoryChangeDTO[];
}

/**
 * ===============================
 * KnowledgeBase
 * ===============================
 */
export interface KnowledgeBaseDTO {
  characters: CharacterKnowledgeBaseDTO[];
  factions: FactionKnowledgeBaseDTO[];
  locations: LocationKnowledgeBaseDTO[];
  items: ItemKnowledgeBaseDTO[];
  clazz: string;
}

export interface CharacterKnowledgeBaseDTO {
  id: string;
  name: string;
  description: string;
  locationId: string;
  factionId: string;
  clazz: string;
}

export interface FactionKnowledgeBaseDTO {
  id: string;
  name: string;
  description: string;
  clazz: string;
}

export interface LocationKnowledgeBaseDTO {
  id: string;
  name: string;
  description: string;
  parentLocationChain: string;
  clazz: string;
}

export interface ItemKnowledgeBaseDTO {
  id: string;
  name: string;
  description: string;
  clazz: string;
}

/**
 * ============================================================================
 * Generate Response Options
 * ============================================================================
 */
export interface GeneratePlayerDialogueOptionsRequest {
  dialogueId: string;
  directionsQuantity: number;
  variations: number;
  /** e.g. D20_V1 */
  scaleType: string;
}

export interface GeneratePlayerDialogueOptionsResponse {
  dialogueOptions: DialogueOptionDTO[];
}

/**
 * ===============================
 * DialogueOptionDTO
 * ===============================
 */
export interface DialogueOptionDTO {
  /** Pre-generated response text */
  explanation: string;
  /** Goal this response aims to achieve */
  dialogueDirection: string;
  /** Strategy this response employs */
  riskImpact: string;
  clazz: string;
}

/**
 * ============================================================================
 * Interrupt Dialogue
 * ============================================================================
 */
export interface InterruptDialogueRequest {
  requestId: string;
  /** e.g. OPENAI_V1 */
  aiProvider: string;
}

export interface InterruptDialogueResponse {
  requestId: string;
}

/** ============================================================================ */
export interface FinalizeDialogueRequest {
  /** Dialogue session ID */
  dialogueId: string;
  /** User, World, Campaign */
  context: ContextDTO | undefined;
}

export interface FinalizeDialogueResponse {
  /** Dialogue session ID */
  dialogueId: string;
  /** Summary of the dialogue */
  summary: string;
  dialogueParticipants: CharacterProfileDTO[];
  worldContext: WorldContextDTO | undefined;
  dialogueHistory: DialogueHistoryDTO | undefined;
}

function createBaseInitializeDialogueRequest(): InitializeDialogueRequest {
  return {
    initiatingParticipantId: "",
    playerCharacterId: "",
    aiProvider: "",
    dialogueParticipants: undefined,
    worldContext: undefined,
    dialogueHistory: undefined,
    knowledgeBase: undefined,
    context: undefined,
  };
}

export const InitializeDialogueRequest: MessageFns<InitializeDialogueRequest> = {
  encode(message: InitializeDialogueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initiatingParticipantId !== "") {
      writer.uint32(10).string(message.initiatingParticipantId);
    }
    if (message.playerCharacterId !== "") {
      writer.uint32(18).string(message.playerCharacterId);
    }
    if (message.aiProvider !== "") {
      writer.uint32(26).string(message.aiProvider);
    }
    if (message.dialogueParticipants !== undefined) {
      CharacterProfilesDTO.encode(message.dialogueParticipants, writer.uint32(34).fork()).join();
    }
    if (message.worldContext !== undefined) {
      WorldContextDTO.encode(message.worldContext, writer.uint32(42).fork()).join();
    }
    if (message.dialogueHistory !== undefined) {
      DialogueHistoryDTO.encode(message.dialogueHistory, writer.uint32(50).fork()).join();
    }
    if (message.knowledgeBase !== undefined) {
      KnowledgeBaseDTO.encode(message.knowledgeBase, writer.uint32(58).fork()).join();
    }
    if (message.context !== undefined) {
      ContextDTO.encode(message.context, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitializeDialogueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializeDialogueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.initiatingParticipantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.playerCharacterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aiProvider = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dialogueParticipants = CharacterProfilesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.worldContext = WorldContextDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dialogueHistory = DialogueHistoryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.knowledgeBase = KnowledgeBaseDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.context = ContextDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitializeDialogueRequest {
    return {
      initiatingParticipantId: isSet(object.initiatingParticipantId)
        ? globalThis.String(object.initiatingParticipantId)
        : "",
      playerCharacterId: isSet(object.playerCharacterId) ? globalThis.String(object.playerCharacterId) : "",
      aiProvider: isSet(object.aiProvider) ? globalThis.String(object.aiProvider) : "",
      dialogueParticipants: isSet(object.dialogueParticipants)
        ? CharacterProfilesDTO.fromJSON(object.dialogueParticipants)
        : undefined,
      worldContext: isSet(object.worldContext) ? WorldContextDTO.fromJSON(object.worldContext) : undefined,
      dialogueHistory: isSet(object.dialogueHistory) ? DialogueHistoryDTO.fromJSON(object.dialogueHistory) : undefined,
      knowledgeBase: isSet(object.knowledgeBase) ? KnowledgeBaseDTO.fromJSON(object.knowledgeBase) : undefined,
      context: isSet(object.context) ? ContextDTO.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: InitializeDialogueRequest): unknown {
    const obj: any = {};
    if (message.initiatingParticipantId !== "") {
      obj.initiatingParticipantId = message.initiatingParticipantId;
    }
    if (message.playerCharacterId !== "") {
      obj.playerCharacterId = message.playerCharacterId;
    }
    if (message.aiProvider !== "") {
      obj.aiProvider = message.aiProvider;
    }
    if (message.dialogueParticipants !== undefined) {
      obj.dialogueParticipants = CharacterProfilesDTO.toJSON(message.dialogueParticipants);
    }
    if (message.worldContext !== undefined) {
      obj.worldContext = WorldContextDTO.toJSON(message.worldContext);
    }
    if (message.dialogueHistory !== undefined) {
      obj.dialogueHistory = DialogueHistoryDTO.toJSON(message.dialogueHistory);
    }
    if (message.knowledgeBase !== undefined) {
      obj.knowledgeBase = KnowledgeBaseDTO.toJSON(message.knowledgeBase);
    }
    if (message.context !== undefined) {
      obj.context = ContextDTO.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitializeDialogueRequest>, I>>(base?: I): InitializeDialogueRequest {
    return InitializeDialogueRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitializeDialogueRequest>, I>>(object: I): InitializeDialogueRequest {
    const message = createBaseInitializeDialogueRequest();
    message.initiatingParticipantId = object.initiatingParticipantId ?? "";
    message.playerCharacterId = object.playerCharacterId ?? "";
    message.aiProvider = object.aiProvider ?? "";
    message.dialogueParticipants = (object.dialogueParticipants !== undefined && object.dialogueParticipants !== null)
      ? CharacterProfilesDTO.fromPartial(object.dialogueParticipants)
      : undefined;
    message.worldContext = (object.worldContext !== undefined && object.worldContext !== null)
      ? WorldContextDTO.fromPartial(object.worldContext)
      : undefined;
    message.dialogueHistory = (object.dialogueHistory !== undefined && object.dialogueHistory !== null)
      ? DialogueHistoryDTO.fromPartial(object.dialogueHistory)
      : undefined;
    message.knowledgeBase = (object.knowledgeBase !== undefined && object.knowledgeBase !== null)
      ? KnowledgeBaseDTO.fromPartial(object.knowledgeBase)
      : undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? ContextDTO.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseInitializeDialogueResponse(): InitializeDialogueResponse {
  return { dialogueId: "" };
}

export const InitializeDialogueResponse: MessageFns<InitializeDialogueResponse> = {
  encode(message: InitializeDialogueResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialogueId !== "") {
      writer.uint32(10).string(message.dialogueId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitializeDialogueResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializeDialogueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dialogueId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitializeDialogueResponse {
    return { dialogueId: isSet(object.dialogueId) ? globalThis.String(object.dialogueId) : "" };
  },

  toJSON(message: InitializeDialogueResponse): unknown {
    const obj: any = {};
    if (message.dialogueId !== "") {
      obj.dialogueId = message.dialogueId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitializeDialogueResponse>, I>>(base?: I): InitializeDialogueResponse {
    return InitializeDialogueResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitializeDialogueResponse>, I>>(object: I): InitializeDialogueResponse {
    const message = createBaseInitializeDialogueResponse();
    message.dialogueId = object.dialogueId ?? "";
    return message;
  },
};

function createBaseCharacterProfileDTO(): CharacterProfileDTO {
  return {
    id: "",
    name: "",
    race: "",
    class: "",
    traits: "",
    enneagram: "",
    mood: "",
    needs: "",
    goals: undefined,
    skills: {},
    stats: {},
    inventory: undefined,
    knowledge: undefined,
    dialogueAttitude: "",
  };
}

export const CharacterProfileDTO: MessageFns<CharacterProfileDTO> = {
  encode(message: CharacterProfileDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.race !== "") {
      writer.uint32(26).string(message.race);
    }
    if (message.class !== "") {
      writer.uint32(34).string(message.class);
    }
    if (message.traits !== "") {
      writer.uint32(42).string(message.traits);
    }
    if (message.enneagram !== "") {
      writer.uint32(50).string(message.enneagram);
    }
    if (message.mood !== "") {
      writer.uint32(58).string(message.mood);
    }
    if (message.needs !== "") {
      writer.uint32(66).string(message.needs);
    }
    if (message.goals !== undefined) {
      CharacterGoalsDTO.encode(message.goals, writer.uint32(74).fork()).join();
    }
    Object.entries(message.skills).forEach(([key, value]) => {
      CharacterProfileDTO_SkillsEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    Object.entries(message.stats).forEach(([key, value]) => {
      CharacterProfileDTO_StatsEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.inventory !== undefined) {
      CharacterInventoryDTO.encode(message.inventory, writer.uint32(98).fork()).join();
    }
    if (message.knowledge !== undefined) {
      CharacterKnowledgeDTO.encode(message.knowledge, writer.uint32(106).fork()).join();
    }
    if (message.dialogueAttitude !== "") {
      writer.uint32(114).string(message.dialogueAttitude);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfileDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfileDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.race = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.class = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.traits = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.enneagram = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mood = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.needs = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.goals = CharacterGoalsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = CharacterProfileDTO_SkillsEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.skills[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = CharacterProfileDTO_StatsEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.stats[entry11.key] = entry11.value;
          }
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.inventory = CharacterInventoryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.knowledge = CharacterKnowledgeDTO.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.dialogueAttitude = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfileDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      race: isSet(object.race) ? globalThis.String(object.race) : "",
      class: isSet(object.class) ? globalThis.String(object.class) : "",
      traits: isSet(object.traits) ? globalThis.String(object.traits) : "",
      enneagram: isSet(object.enneagram) ? globalThis.String(object.enneagram) : "",
      mood: isSet(object.mood) ? globalThis.String(object.mood) : "",
      needs: isSet(object.needs) ? globalThis.String(object.needs) : "",
      goals: isSet(object.goals) ? CharacterGoalsDTO.fromJSON(object.goals) : undefined,
      skills: isObject(object.skills)
        ? Object.entries(object.skills).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      stats: isObject(object.stats)
        ? Object.entries(object.stats).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      inventory: isSet(object.inventory) ? CharacterInventoryDTO.fromJSON(object.inventory) : undefined,
      knowledge: isSet(object.knowledge) ? CharacterKnowledgeDTO.fromJSON(object.knowledge) : undefined,
      dialogueAttitude: isSet(object.dialogueAttitude) ? globalThis.String(object.dialogueAttitude) : "",
    };
  },

  toJSON(message: CharacterProfileDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.race !== "") {
      obj.race = message.race;
    }
    if (message.class !== "") {
      obj.class = message.class;
    }
    if (message.traits !== "") {
      obj.traits = message.traits;
    }
    if (message.enneagram !== "") {
      obj.enneagram = message.enneagram;
    }
    if (message.mood !== "") {
      obj.mood = message.mood;
    }
    if (message.needs !== "") {
      obj.needs = message.needs;
    }
    if (message.goals !== undefined) {
      obj.goals = CharacterGoalsDTO.toJSON(message.goals);
    }
    if (message.skills) {
      const entries = Object.entries(message.skills);
      if (entries.length > 0) {
        obj.skills = {};
        entries.forEach(([k, v]) => {
          obj.skills[k] = Math.round(v);
        });
      }
    }
    if (message.stats) {
      const entries = Object.entries(message.stats);
      if (entries.length > 0) {
        obj.stats = {};
        entries.forEach(([k, v]) => {
          obj.stats[k] = v;
        });
      }
    }
    if (message.inventory !== undefined) {
      obj.inventory = CharacterInventoryDTO.toJSON(message.inventory);
    }
    if (message.knowledge !== undefined) {
      obj.knowledge = CharacterKnowledgeDTO.toJSON(message.knowledge);
    }
    if (message.dialogueAttitude !== "") {
      obj.dialogueAttitude = message.dialogueAttitude;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfileDTO>, I>>(base?: I): CharacterProfileDTO {
    return CharacterProfileDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfileDTO>, I>>(object: I): CharacterProfileDTO {
    const message = createBaseCharacterProfileDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.race = object.race ?? "";
    message.class = object.class ?? "";
    message.traits = object.traits ?? "";
    message.enneagram = object.enneagram ?? "";
    message.mood = object.mood ?? "";
    message.needs = object.needs ?? "";
    message.goals = (object.goals !== undefined && object.goals !== null)
      ? CharacterGoalsDTO.fromPartial(object.goals)
      : undefined;
    message.skills = Object.entries(object.skills ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.stats = Object.entries(object.stats ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.inventory = (object.inventory !== undefined && object.inventory !== null)
      ? CharacterInventoryDTO.fromPartial(object.inventory)
      : undefined;
    message.knowledge = (object.knowledge !== undefined && object.knowledge !== null)
      ? CharacterKnowledgeDTO.fromPartial(object.knowledge)
      : undefined;
    message.dialogueAttitude = object.dialogueAttitude ?? "";
    return message;
  },
};

function createBaseCharacterProfileDTO_SkillsEntry(): CharacterProfileDTO_SkillsEntry {
  return { key: "", value: 0 };
}

export const CharacterProfileDTO_SkillsEntry: MessageFns<CharacterProfileDTO_SkillsEntry> = {
  encode(message: CharacterProfileDTO_SkillsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfileDTO_SkillsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfileDTO_SkillsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfileDTO_SkillsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CharacterProfileDTO_SkillsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfileDTO_SkillsEntry>, I>>(base?: I): CharacterProfileDTO_SkillsEntry {
    return CharacterProfileDTO_SkillsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfileDTO_SkillsEntry>, I>>(
    object: I,
  ): CharacterProfileDTO_SkillsEntry {
    const message = createBaseCharacterProfileDTO_SkillsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCharacterProfileDTO_StatsEntry(): CharacterProfileDTO_StatsEntry {
  return { key: "", value: "" };
}

export const CharacterProfileDTO_StatsEntry: MessageFns<CharacterProfileDTO_StatsEntry> = {
  encode(message: CharacterProfileDTO_StatsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfileDTO_StatsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfileDTO_StatsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfileDTO_StatsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CharacterProfileDTO_StatsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfileDTO_StatsEntry>, I>>(base?: I): CharacterProfileDTO_StatsEntry {
    return CharacterProfileDTO_StatsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfileDTO_StatsEntry>, I>>(
    object: I,
  ): CharacterProfileDTO_StatsEntry {
    const message = createBaseCharacterProfileDTO_StatsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCharacterGoalsDTO(): CharacterGoalsDTO {
  return { satisfied: [], unsatisfied: [] };
}

export const CharacterGoalsDTO: MessageFns<CharacterGoalsDTO> = {
  encode(message: CharacterGoalsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.satisfied) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.unsatisfied) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGoalsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGoalsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.satisfied.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.unsatisfied.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGoalsDTO {
    return {
      satisfied: globalThis.Array.isArray(object?.satisfied)
        ? object.satisfied.map((e: any) => globalThis.String(e))
        : [],
      unsatisfied: globalThis.Array.isArray(object?.unsatisfied)
        ? object.unsatisfied.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CharacterGoalsDTO): unknown {
    const obj: any = {};
    if (message.satisfied?.length) {
      obj.satisfied = message.satisfied;
    }
    if (message.unsatisfied?.length) {
      obj.unsatisfied = message.unsatisfied;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGoalsDTO>, I>>(base?: I): CharacterGoalsDTO {
    return CharacterGoalsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGoalsDTO>, I>>(object: I): CharacterGoalsDTO {
    const message = createBaseCharacterGoalsDTO();
    message.satisfied = object.satisfied?.map((e) => e) || [];
    message.unsatisfied = object.unsatisfied?.map((e) => e) || [];
    return message;
  },
};

function createBaseCharacterInventoryDTO(): CharacterInventoryDTO {
  return { equipped: [], stored: [] };
}

export const CharacterInventoryDTO: MessageFns<CharacterInventoryDTO> = {
  encode(message: CharacterInventoryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.equipped) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.stored) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterInventoryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterInventoryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.equipped.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stored.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterInventoryDTO {
    return {
      equipped: globalThis.Array.isArray(object?.equipped) ? object.equipped.map((e: any) => globalThis.String(e)) : [],
      stored: globalThis.Array.isArray(object?.stored) ? object.stored.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CharacterInventoryDTO): unknown {
    const obj: any = {};
    if (message.equipped?.length) {
      obj.equipped = message.equipped;
    }
    if (message.stored?.length) {
      obj.stored = message.stored;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterInventoryDTO>, I>>(base?: I): CharacterInventoryDTO {
    return CharacterInventoryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterInventoryDTO>, I>>(object: I): CharacterInventoryDTO {
    const message = createBaseCharacterInventoryDTO();
    message.equipped = object.equipped?.map((e) => e) || [];
    message.stored = object.stored?.map((e) => e) || [];
    return message;
  },
};

function createBaseCharacterKnowledgeDTO(): CharacterKnowledgeDTO {
  return { locations: [], factions: [], familiarCharacters: [] };
}

export const CharacterKnowledgeDTO: MessageFns<CharacterKnowledgeDTO> = {
  encode(message: CharacterKnowledgeDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.locations) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.factions) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.familiarCharacters) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterKnowledgeDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterKnowledgeDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.locations.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.factions.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.familiarCharacters.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterKnowledgeDTO {
    return {
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => globalThis.String(e))
        : [],
      factions: globalThis.Array.isArray(object?.factions) ? object.factions.map((e: any) => globalThis.String(e)) : [],
      familiarCharacters: globalThis.Array.isArray(object?.familiarCharacters)
        ? object.familiarCharacters.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CharacterKnowledgeDTO): unknown {
    const obj: any = {};
    if (message.locations?.length) {
      obj.locations = message.locations;
    }
    if (message.factions?.length) {
      obj.factions = message.factions;
    }
    if (message.familiarCharacters?.length) {
      obj.familiarCharacters = message.familiarCharacters;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterKnowledgeDTO>, I>>(base?: I): CharacterKnowledgeDTO {
    return CharacterKnowledgeDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterKnowledgeDTO>, I>>(object: I): CharacterKnowledgeDTO {
    const message = createBaseCharacterKnowledgeDTO();
    message.locations = object.locations?.map((e) => e) || [];
    message.factions = object.factions?.map((e) => e) || [];
    message.familiarCharacters = object.familiarCharacters?.map((e) => e) || [];
    return message;
  },
};

function createBaseCharacterProfilesDTO(): CharacterProfilesDTO {
  return { arr: [] };
}

export const CharacterProfilesDTO: MessageFns<CharacterProfilesDTO> = {
  encode(message: CharacterProfilesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      CharacterProfileDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfilesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfilesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(CharacterProfileDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfilesDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => CharacterProfileDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: CharacterProfilesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterProfileDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfilesDTO>, I>>(base?: I): CharacterProfilesDTO {
    return CharacterProfilesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfilesDTO>, I>>(object: I): CharacterProfilesDTO {
    const message = createBaseCharacterProfilesDTO();
    message.arr = object.arr?.map((e) => CharacterProfileDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorldContextDTO(): WorldContextDTO {
  return { location: undefined, time: undefined, weather: undefined, scene: undefined, clazz: "" };
}

export const WorldContextDTO: MessageFns<WorldContextDTO> = {
  encode(message: WorldContextDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.location !== undefined) {
      LocationContextDTO.encode(message.location, writer.uint32(10).fork()).join();
    }
    if (message.time !== undefined) {
      TimeContextDTO.encode(message.time, writer.uint32(18).fork()).join();
    }
    if (message.weather !== undefined) {
      WeatherContextDTO.encode(message.weather, writer.uint32(26).fork()).join();
    }
    if (message.scene !== undefined) {
      SceneContextDTO.encode(message.scene, writer.uint32(34).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(42).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldContextDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldContextDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.location = LocationContextDTO.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.time = TimeContextDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.weather = WeatherContextDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scene = SceneContextDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldContextDTO {
    return {
      location: isSet(object.location) ? LocationContextDTO.fromJSON(object.location) : undefined,
      time: isSet(object.time) ? TimeContextDTO.fromJSON(object.time) : undefined,
      weather: isSet(object.weather) ? WeatherContextDTO.fromJSON(object.weather) : undefined,
      scene: isSet(object.scene) ? SceneContextDTO.fromJSON(object.scene) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: WorldContextDTO): unknown {
    const obj: any = {};
    if (message.location !== undefined) {
      obj.location = LocationContextDTO.toJSON(message.location);
    }
    if (message.time !== undefined) {
      obj.time = TimeContextDTO.toJSON(message.time);
    }
    if (message.weather !== undefined) {
      obj.weather = WeatherContextDTO.toJSON(message.weather);
    }
    if (message.scene !== undefined) {
      obj.scene = SceneContextDTO.toJSON(message.scene);
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldContextDTO>, I>>(base?: I): WorldContextDTO {
    return WorldContextDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldContextDTO>, I>>(object: I): WorldContextDTO {
    const message = createBaseWorldContextDTO();
    message.location = (object.location !== undefined && object.location !== null)
      ? LocationContextDTO.fromPartial(object.location)
      : undefined;
    message.time = (object.time !== undefined && object.time !== null)
      ? TimeContextDTO.fromPartial(object.time)
      : undefined;
    message.weather = (object.weather !== undefined && object.weather !== null)
      ? WeatherContextDTO.fromPartial(object.weather)
      : undefined;
    message.scene = (object.scene !== undefined && object.scene !== null)
      ? SceneContextDTO.fromPartial(object.scene)
      : undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseLocationContextDTO(): LocationContextDTO {
  return { id: "", name: "", description: "", biome: "", clazz: "" };
}

export const LocationContextDTO: MessageFns<LocationContextDTO> = {
  encode(message: LocationContextDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.biome !== "") {
      writer.uint32(34).string(message.biome);
    }
    if (message.clazz !== "") {
      writer.uint32(42).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationContextDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationContextDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.biome = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationContextDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      biome: isSet(object.biome) ? globalThis.String(object.biome) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: LocationContextDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.biome !== "") {
      obj.biome = message.biome;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocationContextDTO>, I>>(base?: I): LocationContextDTO {
    return LocationContextDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocationContextDTO>, I>>(object: I): LocationContextDTO {
    const message = createBaseLocationContextDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.biome = object.biome ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseTimeContextDTO(): TimeContextDTO {
  return { timeOfDay: "", day: 0, month: "", year: 0, season: "", clazz: "" };
}

export const TimeContextDTO: MessageFns<TimeContextDTO> = {
  encode(message: TimeContextDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeOfDay !== "") {
      writer.uint32(10).string(message.timeOfDay);
    }
    if (message.day !== 0) {
      writer.uint32(16).int32(message.day);
    }
    if (message.month !== "") {
      writer.uint32(26).string(message.month);
    }
    if (message.year !== 0) {
      writer.uint32(32).int32(message.year);
    }
    if (message.season !== "") {
      writer.uint32(42).string(message.season);
    }
    if (message.clazz !== "") {
      writer.uint32(50).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeContextDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeContextDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeOfDay = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.day = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.month = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.year = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.season = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeContextDTO {
    return {
      timeOfDay: isSet(object.timeOfDay) ? globalThis.String(object.timeOfDay) : "",
      day: isSet(object.day) ? globalThis.Number(object.day) : 0,
      month: isSet(object.month) ? globalThis.String(object.month) : "",
      year: isSet(object.year) ? globalThis.Number(object.year) : 0,
      season: isSet(object.season) ? globalThis.String(object.season) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: TimeContextDTO): unknown {
    const obj: any = {};
    if (message.timeOfDay !== "") {
      obj.timeOfDay = message.timeOfDay;
    }
    if (message.day !== 0) {
      obj.day = Math.round(message.day);
    }
    if (message.month !== "") {
      obj.month = message.month;
    }
    if (message.year !== 0) {
      obj.year = Math.round(message.year);
    }
    if (message.season !== "") {
      obj.season = message.season;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeContextDTO>, I>>(base?: I): TimeContextDTO {
    return TimeContextDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeContextDTO>, I>>(object: I): TimeContextDTO {
    const message = createBaseTimeContextDTO();
    message.timeOfDay = object.timeOfDay ?? "";
    message.day = object.day ?? 0;
    message.month = object.month ?? "";
    message.year = object.year ?? 0;
    message.season = object.season ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseWeatherContextDTO(): WeatherContextDTO {
  return { weather: "", temperature: "", wind: "", precipitation: "", visibility: "", clazz: "" };
}

export const WeatherContextDTO: MessageFns<WeatherContextDTO> = {
  encode(message: WeatherContextDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.weather !== "") {
      writer.uint32(10).string(message.weather);
    }
    if (message.temperature !== "") {
      writer.uint32(18).string(message.temperature);
    }
    if (message.wind !== "") {
      writer.uint32(26).string(message.wind);
    }
    if (message.precipitation !== "") {
      writer.uint32(34).string(message.precipitation);
    }
    if (message.visibility !== "") {
      writer.uint32(42).string(message.visibility);
    }
    if (message.clazz !== "") {
      writer.uint32(50).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WeatherContextDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeatherContextDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.weather = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.temperature = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.wind = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.precipitation = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.visibility = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeatherContextDTO {
    return {
      weather: isSet(object.weather) ? globalThis.String(object.weather) : "",
      temperature: isSet(object.temperature) ? globalThis.String(object.temperature) : "",
      wind: isSet(object.wind) ? globalThis.String(object.wind) : "",
      precipitation: isSet(object.precipitation) ? globalThis.String(object.precipitation) : "",
      visibility: isSet(object.visibility) ? globalThis.String(object.visibility) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: WeatherContextDTO): unknown {
    const obj: any = {};
    if (message.weather !== "") {
      obj.weather = message.weather;
    }
    if (message.temperature !== "") {
      obj.temperature = message.temperature;
    }
    if (message.wind !== "") {
      obj.wind = message.wind;
    }
    if (message.precipitation !== "") {
      obj.precipitation = message.precipitation;
    }
    if (message.visibility !== "") {
      obj.visibility = message.visibility;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WeatherContextDTO>, I>>(base?: I): WeatherContextDTO {
    return WeatherContextDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WeatherContextDTO>, I>>(object: I): WeatherContextDTO {
    const message = createBaseWeatherContextDTO();
    message.weather = object.weather ?? "";
    message.temperature = object.temperature ?? "";
    message.wind = object.wind ?? "";
    message.precipitation = object.precipitation ?? "";
    message.visibility = object.visibility ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseSceneContextDTO(): SceneContextDTO {
  return { north: undefined, northEast: undefined, east: undefined, southEast: undefined, south: undefined, clazz: "" };
}

export const SceneContextDTO: MessageFns<SceneContextDTO> = {
  encode(message: SceneContextDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.north !== undefined) {
      DirectionSceneEntryDTO.encode(message.north, writer.uint32(10).fork()).join();
    }
    if (message.northEast !== undefined) {
      DirectionSceneEntryDTO.encode(message.northEast, writer.uint32(18).fork()).join();
    }
    if (message.east !== undefined) {
      DirectionSceneEntryDTO.encode(message.east, writer.uint32(26).fork()).join();
    }
    if (message.southEast !== undefined) {
      DirectionSceneEntryDTO.encode(message.southEast, writer.uint32(34).fork()).join();
    }
    if (message.south !== undefined) {
      DirectionSceneEntryDTO.encode(message.south, writer.uint32(42).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(50).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SceneContextDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneContextDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.north = DirectionSceneEntryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.northEast = DirectionSceneEntryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.east = DirectionSceneEntryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.southEast = DirectionSceneEntryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.south = DirectionSceneEntryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SceneContextDTO {
    return {
      north: isSet(object.north) ? DirectionSceneEntryDTO.fromJSON(object.north) : undefined,
      northEast: isSet(object.northEast) ? DirectionSceneEntryDTO.fromJSON(object.northEast) : undefined,
      east: isSet(object.east) ? DirectionSceneEntryDTO.fromJSON(object.east) : undefined,
      southEast: isSet(object.southEast) ? DirectionSceneEntryDTO.fromJSON(object.southEast) : undefined,
      south: isSet(object.south) ? DirectionSceneEntryDTO.fromJSON(object.south) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: SceneContextDTO): unknown {
    const obj: any = {};
    if (message.north !== undefined) {
      obj.north = DirectionSceneEntryDTO.toJSON(message.north);
    }
    if (message.northEast !== undefined) {
      obj.northEast = DirectionSceneEntryDTO.toJSON(message.northEast);
    }
    if (message.east !== undefined) {
      obj.east = DirectionSceneEntryDTO.toJSON(message.east);
    }
    if (message.southEast !== undefined) {
      obj.southEast = DirectionSceneEntryDTO.toJSON(message.southEast);
    }
    if (message.south !== undefined) {
      obj.south = DirectionSceneEntryDTO.toJSON(message.south);
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SceneContextDTO>, I>>(base?: I): SceneContextDTO {
    return SceneContextDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SceneContextDTO>, I>>(object: I): SceneContextDTO {
    const message = createBaseSceneContextDTO();
    message.north = (object.north !== undefined && object.north !== null)
      ? DirectionSceneEntryDTO.fromPartial(object.north)
      : undefined;
    message.northEast = (object.northEast !== undefined && object.northEast !== null)
      ? DirectionSceneEntryDTO.fromPartial(object.northEast)
      : undefined;
    message.east = (object.east !== undefined && object.east !== null)
      ? DirectionSceneEntryDTO.fromPartial(object.east)
      : undefined;
    message.southEast = (object.southEast !== undefined && object.southEast !== null)
      ? DirectionSceneEntryDTO.fromPartial(object.southEast)
      : undefined;
    message.south = (object.south !== undefined && object.south !== null)
      ? DirectionSceneEntryDTO.fromPartial(object.south)
      : undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseDirectionSceneEntryDTO(): DirectionSceneEntryDTO {
  return { near: undefined, mid: undefined, far: undefined, clazz: "" };
}

export const DirectionSceneEntryDTO: MessageFns<DirectionSceneEntryDTO> = {
  encode(message: DirectionSceneEntryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.near !== undefined) {
      SceneEntryDTO.encode(message.near, writer.uint32(10).fork()).join();
    }
    if (message.mid !== undefined) {
      SceneEntryDTO.encode(message.mid, writer.uint32(18).fork()).join();
    }
    if (message.far !== undefined) {
      SceneEntryDTO.encode(message.far, writer.uint32(26).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(34).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DirectionSceneEntryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDirectionSceneEntryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.near = SceneEntryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mid = SceneEntryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.far = SceneEntryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DirectionSceneEntryDTO {
    return {
      near: isSet(object.near) ? SceneEntryDTO.fromJSON(object.near) : undefined,
      mid: isSet(object.mid) ? SceneEntryDTO.fromJSON(object.mid) : undefined,
      far: isSet(object.far) ? SceneEntryDTO.fromJSON(object.far) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: DirectionSceneEntryDTO): unknown {
    const obj: any = {};
    if (message.near !== undefined) {
      obj.near = SceneEntryDTO.toJSON(message.near);
    }
    if (message.mid !== undefined) {
      obj.mid = SceneEntryDTO.toJSON(message.mid);
    }
    if (message.far !== undefined) {
      obj.far = SceneEntryDTO.toJSON(message.far);
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DirectionSceneEntryDTO>, I>>(base?: I): DirectionSceneEntryDTO {
    return DirectionSceneEntryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DirectionSceneEntryDTO>, I>>(object: I): DirectionSceneEntryDTO {
    const message = createBaseDirectionSceneEntryDTO();
    message.near = (object.near !== undefined && object.near !== null)
      ? SceneEntryDTO.fromPartial(object.near)
      : undefined;
    message.mid = (object.mid !== undefined && object.mid !== null) ? SceneEntryDTO.fromPartial(object.mid) : undefined;
    message.far = (object.far !== undefined && object.far !== null) ? SceneEntryDTO.fromPartial(object.far) : undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseSceneEntryDTO(): SceneEntryDTO {
  return { biome: "", NPCs: undefined, items: undefined, clazz: "" };
}

export const SceneEntryDTO: MessageFns<SceneEntryDTO> = {
  encode(message: SceneEntryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.biome !== "") {
      writer.uint32(10).string(message.biome);
    }
    if (message.NPCs !== undefined) {
      SceneNPCsDTO.encode(message.NPCs, writer.uint32(18).fork()).join();
    }
    if (message.items !== undefined) {
      SceneItemsDTO.encode(message.items, writer.uint32(26).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(34).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SceneEntryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneEntryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.biome = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.NPCs = SceneNPCsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.items = SceneItemsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SceneEntryDTO {
    return {
      biome: isSet(object.biome) ? globalThis.String(object.biome) : "",
      NPCs: isSet(object.NPCs) ? SceneNPCsDTO.fromJSON(object.NPCs) : undefined,
      items: isSet(object.items) ? SceneItemsDTO.fromJSON(object.items) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: SceneEntryDTO): unknown {
    const obj: any = {};
    if (message.biome !== "") {
      obj.biome = message.biome;
    }
    if (message.NPCs !== undefined) {
      obj.NPCs = SceneNPCsDTO.toJSON(message.NPCs);
    }
    if (message.items !== undefined) {
      obj.items = SceneItemsDTO.toJSON(message.items);
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SceneEntryDTO>, I>>(base?: I): SceneEntryDTO {
    return SceneEntryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SceneEntryDTO>, I>>(object: I): SceneEntryDTO {
    const message = createBaseSceneEntryDTO();
    message.biome = object.biome ?? "";
    message.NPCs = (object.NPCs !== undefined && object.NPCs !== null)
      ? SceneNPCsDTO.fromPartial(object.NPCs)
      : undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? SceneItemsDTO.fromPartial(object.items)
      : undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseSceneNPCDTO(): SceneNPCDTO {
  return { id: "", activity: "", clazz: "" };
}

export const SceneNPCDTO: MessageFns<SceneNPCDTO> = {
  encode(message: SceneNPCDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.activity !== "") {
      writer.uint32(18).string(message.activity);
    }
    if (message.clazz !== "") {
      writer.uint32(26).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SceneNPCDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneNPCDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.activity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SceneNPCDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      activity: isSet(object.activity) ? globalThis.String(object.activity) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: SceneNPCDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.activity !== "") {
      obj.activity = message.activity;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SceneNPCDTO>, I>>(base?: I): SceneNPCDTO {
    return SceneNPCDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SceneNPCDTO>, I>>(object: I): SceneNPCDTO {
    const message = createBaseSceneNPCDTO();
    message.id = object.id ?? "";
    message.activity = object.activity ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseSceneNPCsDTO(): SceneNPCsDTO {
  return { arr: [] };
}

export const SceneNPCsDTO: MessageFns<SceneNPCsDTO> = {
  encode(message: SceneNPCsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      SceneNPCDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SceneNPCsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneNPCsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(SceneNPCDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SceneNPCsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => SceneNPCDTO.fromJSON(e)) : [] };
  },

  toJSON(message: SceneNPCsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => SceneNPCDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SceneNPCsDTO>, I>>(base?: I): SceneNPCsDTO {
    return SceneNPCsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SceneNPCsDTO>, I>>(object: I): SceneNPCsDTO {
    const message = createBaseSceneNPCsDTO();
    message.arr = object.arr?.map((e) => SceneNPCDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSceneItemDTO(): SceneItemDTO {
  return { id: "", clazz: "" };
}

export const SceneItemDTO: MessageFns<SceneItemDTO> = {
  encode(message: SceneItemDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.clazz !== "") {
      writer.uint32(18).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SceneItemDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneItemDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SceneItemDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: SceneItemDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SceneItemDTO>, I>>(base?: I): SceneItemDTO {
    return SceneItemDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SceneItemDTO>, I>>(object: I): SceneItemDTO {
    const message = createBaseSceneItemDTO();
    message.id = object.id ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseSceneItemsDTO(): SceneItemsDTO {
  return { arr: [] };
}

export const SceneItemsDTO: MessageFns<SceneItemsDTO> = {
  encode(message: SceneItemsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      SceneItemDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SceneItemsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneItemsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(SceneItemDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SceneItemsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => SceneItemDTO.fromJSON(e)) : [] };
  },

  toJSON(message: SceneItemsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => SceneItemDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SceneItemsDTO>, I>>(base?: I): SceneItemsDTO {
    return SceneItemsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SceneItemsDTO>, I>>(object: I): SceneItemsDTO {
    const message = createBaseSceneItemsDTO();
    message.arr = object.arr?.map((e) => SceneItemDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDialogueHistoryDTO(): DialogueHistoryDTO {
  return { topicsNewestToOldest: undefined, clazz: "" };
}

export const DialogueHistoryDTO: MessageFns<DialogueHistoryDTO> = {
  encode(message: DialogueHistoryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicsNewestToOldest !== undefined) {
      DialogueHistoryTopicsDTO.encode(message.topicsNewestToOldest, writer.uint32(10).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(18).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogueHistoryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogueHistoryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topicsNewestToOldest = DialogueHistoryTopicsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogueHistoryDTO {
    return {
      topicsNewestToOldest: isSet(object.topicsNewestToOldest)
        ? DialogueHistoryTopicsDTO.fromJSON(object.topicsNewestToOldest)
        : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: DialogueHistoryDTO): unknown {
    const obj: any = {};
    if (message.topicsNewestToOldest !== undefined) {
      obj.topicsNewestToOldest = DialogueHistoryTopicsDTO.toJSON(message.topicsNewestToOldest);
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DialogueHistoryDTO>, I>>(base?: I): DialogueHistoryDTO {
    return DialogueHistoryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DialogueHistoryDTO>, I>>(object: I): DialogueHistoryDTO {
    const message = createBaseDialogueHistoryDTO();
    message.topicsNewestToOldest = (object.topicsNewestToOldest !== undefined && object.topicsNewestToOldest !== null)
      ? DialogueHistoryTopicsDTO.fromPartial(object.topicsNewestToOldest)
      : undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseDialogueHistoryTopicDTO(): DialogueHistoryTopicDTO {
  return { topicName: "", stepsNewestToOldest: undefined, clazz: "" };
}

export const DialogueHistoryTopicDTO: MessageFns<DialogueHistoryTopicDTO> = {
  encode(message: DialogueHistoryTopicDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.topicName !== "") {
      writer.uint32(10).string(message.topicName);
    }
    if (message.stepsNewestToOldest !== undefined) {
      DialogueStepsDTO.encode(message.stepsNewestToOldest, writer.uint32(18).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(26).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogueHistoryTopicDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogueHistoryTopicDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.topicName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stepsNewestToOldest = DialogueStepsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogueHistoryTopicDTO {
    return {
      topicName: isSet(object.topicName) ? globalThis.String(object.topicName) : "",
      stepsNewestToOldest: isSet(object.stepsNewestToOldest)
        ? DialogueStepsDTO.fromJSON(object.stepsNewestToOldest)
        : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: DialogueHistoryTopicDTO): unknown {
    const obj: any = {};
    if (message.topicName !== "") {
      obj.topicName = message.topicName;
    }
    if (message.stepsNewestToOldest !== undefined) {
      obj.stepsNewestToOldest = DialogueStepsDTO.toJSON(message.stepsNewestToOldest);
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DialogueHistoryTopicDTO>, I>>(base?: I): DialogueHistoryTopicDTO {
    return DialogueHistoryTopicDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DialogueHistoryTopicDTO>, I>>(object: I): DialogueHistoryTopicDTO {
    const message = createBaseDialogueHistoryTopicDTO();
    message.topicName = object.topicName ?? "";
    message.stepsNewestToOldest = (object.stepsNewestToOldest !== undefined && object.stepsNewestToOldest !== null)
      ? DialogueStepsDTO.fromPartial(object.stepsNewestToOldest)
      : undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseDialogueHistoryTopicsDTO(): DialogueHistoryTopicsDTO {
  return { arr: [] };
}

export const DialogueHistoryTopicsDTO: MessageFns<DialogueHistoryTopicsDTO> = {
  encode(message: DialogueHistoryTopicsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      DialogueHistoryTopicDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogueHistoryTopicsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogueHistoryTopicsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(DialogueHistoryTopicDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogueHistoryTopicsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => DialogueHistoryTopicDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: DialogueHistoryTopicsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => DialogueHistoryTopicDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DialogueHistoryTopicsDTO>, I>>(base?: I): DialogueHistoryTopicsDTO {
    return DialogueHistoryTopicsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DialogueHistoryTopicsDTO>, I>>(object: I): DialogueHistoryTopicsDTO {
    const message = createBaseDialogueHistoryTopicsDTO();
    message.arr = object.arr?.map((e) => DialogueHistoryTopicDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDialogueStepDTO(): DialogueStepDTO {
  return { playerStep: undefined, aiStep: undefined, narration: "", outcome: undefined, clazz: "" };
}

export const DialogueStepDTO: MessageFns<DialogueStepDTO> = {
  encode(message: DialogueStepDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerStep !== undefined) {
      PlayerCharacterStepDTO.encode(message.playerStep, writer.uint32(10).fork()).join();
    }
    if (message.aiStep !== undefined) {
      AiCharacterStepDTO.encode(message.aiStep, writer.uint32(18).fork()).join();
    }
    if (message.narration !== "") {
      writer.uint32(26).string(message.narration);
    }
    if (message.outcome !== undefined) {
      StepOutcomeDTO.encode(message.outcome, writer.uint32(34).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(42).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogueStepDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogueStepDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerStep = PlayerCharacterStepDTO.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aiStep = AiCharacterStepDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.narration = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outcome = StepOutcomeDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogueStepDTO {
    return {
      playerStep: isSet(object.playerStep) ? PlayerCharacterStepDTO.fromJSON(object.playerStep) : undefined,
      aiStep: isSet(object.aiStep) ? AiCharacterStepDTO.fromJSON(object.aiStep) : undefined,
      narration: isSet(object.narration) ? globalThis.String(object.narration) : "",
      outcome: isSet(object.outcome) ? StepOutcomeDTO.fromJSON(object.outcome) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: DialogueStepDTO): unknown {
    const obj: any = {};
    if (message.playerStep !== undefined) {
      obj.playerStep = PlayerCharacterStepDTO.toJSON(message.playerStep);
    }
    if (message.aiStep !== undefined) {
      obj.aiStep = AiCharacterStepDTO.toJSON(message.aiStep);
    }
    if (message.narration !== "") {
      obj.narration = message.narration;
    }
    if (message.outcome !== undefined) {
      obj.outcome = StepOutcomeDTO.toJSON(message.outcome);
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DialogueStepDTO>, I>>(base?: I): DialogueStepDTO {
    return DialogueStepDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DialogueStepDTO>, I>>(object: I): DialogueStepDTO {
    const message = createBaseDialogueStepDTO();
    message.playerStep = (object.playerStep !== undefined && object.playerStep !== null)
      ? PlayerCharacterStepDTO.fromPartial(object.playerStep)
      : undefined;
    message.aiStep = (object.aiStep !== undefined && object.aiStep !== null)
      ? AiCharacterStepDTO.fromPartial(object.aiStep)
      : undefined;
    message.narration = object.narration ?? "";
    message.outcome = (object.outcome !== undefined && object.outcome !== null)
      ? StepOutcomeDTO.fromPartial(object.outcome)
      : undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseDialogueStepsDTO(): DialogueStepsDTO {
  return { arr: [] };
}

export const DialogueStepsDTO: MessageFns<DialogueStepsDTO> = {
  encode(message: DialogueStepsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      DialogueStepDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogueStepsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogueStepsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(DialogueStepDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogueStepsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => DialogueStepDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: DialogueStepsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => DialogueStepDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DialogueStepsDTO>, I>>(base?: I): DialogueStepsDTO {
    return DialogueStepsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DialogueStepsDTO>, I>>(object: I): DialogueStepsDTO {
    const message = createBaseDialogueStepsDTO();
    message.arr = object.arr?.map((e) => DialogueStepDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDiceRollResultDTO(): DiceRollResultDTO {
  return { roll: 0, outcome: "", scaleType: "", usedScaleConfig: "", clazz: "" };
}

export const DiceRollResultDTO: MessageFns<DiceRollResultDTO> = {
  encode(message: DiceRollResultDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roll !== 0) {
      writer.uint32(8).int32(message.roll);
    }
    if (message.outcome !== "") {
      writer.uint32(18).string(message.outcome);
    }
    if (message.scaleType !== "") {
      writer.uint32(26).string(message.scaleType);
    }
    if (message.usedScaleConfig !== "") {
      writer.uint32(34).string(message.usedScaleConfig);
    }
    if (message.clazz !== "") {
      writer.uint32(42).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiceRollResultDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiceRollResultDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.roll = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outcome = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scaleType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.usedScaleConfig = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiceRollResultDTO {
    return {
      roll: isSet(object.roll) ? globalThis.Number(object.roll) : 0,
      outcome: isSet(object.outcome) ? globalThis.String(object.outcome) : "",
      scaleType: isSet(object.scaleType) ? globalThis.String(object.scaleType) : "",
      usedScaleConfig: isSet(object.usedScaleConfig) ? globalThis.String(object.usedScaleConfig) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: DiceRollResultDTO): unknown {
    const obj: any = {};
    if (message.roll !== 0) {
      obj.roll = Math.round(message.roll);
    }
    if (message.outcome !== "") {
      obj.outcome = message.outcome;
    }
    if (message.scaleType !== "") {
      obj.scaleType = message.scaleType;
    }
    if (message.usedScaleConfig !== "") {
      obj.usedScaleConfig = message.usedScaleConfig;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiceRollResultDTO>, I>>(base?: I): DiceRollResultDTO {
    return DiceRollResultDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiceRollResultDTO>, I>>(object: I): DiceRollResultDTO {
    const message = createBaseDiceRollResultDTO();
    message.roll = object.roll ?? 0;
    message.outcome = object.outcome ?? "";
    message.scaleType = object.scaleType ?? "";
    message.usedScaleConfig = object.usedScaleConfig ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBasePlayerCharacterStepDTO(): PlayerCharacterStepDTO {
  return { characterId: "", selectedDialogueOption: "", diceRollResult: undefined, clazz: "" };
}

export const PlayerCharacterStepDTO: MessageFns<PlayerCharacterStepDTO> = {
  encode(message: PlayerCharacterStepDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    if (message.selectedDialogueOption !== "") {
      writer.uint32(18).string(message.selectedDialogueOption);
    }
    if (message.diceRollResult !== undefined) {
      DiceRollResultDTO.encode(message.diceRollResult, writer.uint32(26).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(34).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerCharacterStepDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerCharacterStepDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selectedDialogueOption = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.diceRollResult = DiceRollResultDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerCharacterStepDTO {
    return {
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      selectedDialogueOption: isSet(object.selectedDialogueOption)
        ? globalThis.String(object.selectedDialogueOption)
        : "",
      diceRollResult: isSet(object.diceRollResult) ? DiceRollResultDTO.fromJSON(object.diceRollResult) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: PlayerCharacterStepDTO): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.selectedDialogueOption !== "") {
      obj.selectedDialogueOption = message.selectedDialogueOption;
    }
    if (message.diceRollResult !== undefined) {
      obj.diceRollResult = DiceRollResultDTO.toJSON(message.diceRollResult);
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerCharacterStepDTO>, I>>(base?: I): PlayerCharacterStepDTO {
    return PlayerCharacterStepDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerCharacterStepDTO>, I>>(object: I): PlayerCharacterStepDTO {
    const message = createBasePlayerCharacterStepDTO();
    message.characterId = object.characterId ?? "";
    message.selectedDialogueOption = object.selectedDialogueOption ?? "";
    message.diceRollResult = (object.diceRollResult !== undefined && object.diceRollResult !== null)
      ? DiceRollResultDTO.fromPartial(object.diceRollResult)
      : undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseAiCharacterStepDTO(): AiCharacterStepDTO {
  return { characterId: "", selectedDialogueOption: "", diceRollResult: undefined, clazz: "" };
}

export const AiCharacterStepDTO: MessageFns<AiCharacterStepDTO> = {
  encode(message: AiCharacterStepDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.characterId !== "") {
      writer.uint32(10).string(message.characterId);
    }
    if (message.selectedDialogueOption !== "") {
      writer.uint32(18).string(message.selectedDialogueOption);
    }
    if (message.diceRollResult !== undefined) {
      DiceRollResultDTO.encode(message.diceRollResult, writer.uint32(26).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(34).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AiCharacterStepDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAiCharacterStepDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.selectedDialogueOption = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.diceRollResult = DiceRollResultDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AiCharacterStepDTO {
    return {
      characterId: isSet(object.characterId) ? globalThis.String(object.characterId) : "",
      selectedDialogueOption: isSet(object.selectedDialogueOption)
        ? globalThis.String(object.selectedDialogueOption)
        : "",
      diceRollResult: isSet(object.diceRollResult) ? DiceRollResultDTO.fromJSON(object.diceRollResult) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: AiCharacterStepDTO): unknown {
    const obj: any = {};
    if (message.characterId !== "") {
      obj.characterId = message.characterId;
    }
    if (message.selectedDialogueOption !== "") {
      obj.selectedDialogueOption = message.selectedDialogueOption;
    }
    if (message.diceRollResult !== undefined) {
      obj.diceRollResult = DiceRollResultDTO.toJSON(message.diceRollResult);
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AiCharacterStepDTO>, I>>(base?: I): AiCharacterStepDTO {
    return AiCharacterStepDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AiCharacterStepDTO>, I>>(object: I): AiCharacterStepDTO {
    const message = createBaseAiCharacterStepDTO();
    message.characterId = object.characterId ?? "";
    message.selectedDialogueOption = object.selectedDialogueOption ?? "";
    message.diceRollResult = (object.diceRollResult !== undefined && object.diceRollResult !== null)
      ? DiceRollResultDTO.fromPartial(object.diceRollResult)
      : undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseStepOutcomeDTO(): StepOutcomeDTO {
  return { characterChanges: {}, newTopicName: "", stepOutcome: "", clazz: "" };
}

export const StepOutcomeDTO: MessageFns<StepOutcomeDTO> = {
  encode(message: StepOutcomeDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.characterChanges).forEach(([key, value]) => {
      StepOutcomeDTO_CharacterChangesEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.newTopicName !== "") {
      writer.uint32(18).string(message.newTopicName);
    }
    if (message.stepOutcome !== "") {
      writer.uint32(26).string(message.stepOutcome);
    }
    if (message.clazz !== "") {
      writer.uint32(34).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepOutcomeDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepOutcomeDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = StepOutcomeDTO_CharacterChangesEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.characterChanges[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newTopicName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.stepOutcome = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepOutcomeDTO {
    return {
      characterChanges: isObject(object.characterChanges)
        ? Object.entries(object.characterChanges).reduce<{ [key: string]: CharacterChangesDTO }>(
          (acc, [key, value]) => {
            acc[key] = CharacterChangesDTO.fromJSON(value);
            return acc;
          },
          {},
        )
        : {},
      newTopicName: isSet(object.newTopicName) ? globalThis.String(object.newTopicName) : "",
      stepOutcome: isSet(object.stepOutcome) ? globalThis.String(object.stepOutcome) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: StepOutcomeDTO): unknown {
    const obj: any = {};
    if (message.characterChanges) {
      const entries = Object.entries(message.characterChanges);
      if (entries.length > 0) {
        obj.characterChanges = {};
        entries.forEach(([k, v]) => {
          obj.characterChanges[k] = CharacterChangesDTO.toJSON(v);
        });
      }
    }
    if (message.newTopicName !== "") {
      obj.newTopicName = message.newTopicName;
    }
    if (message.stepOutcome !== "") {
      obj.stepOutcome = message.stepOutcome;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepOutcomeDTO>, I>>(base?: I): StepOutcomeDTO {
    return StepOutcomeDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepOutcomeDTO>, I>>(object: I): StepOutcomeDTO {
    const message = createBaseStepOutcomeDTO();
    message.characterChanges = Object.entries(object.characterChanges ?? {}).reduce<
      { [key: string]: CharacterChangesDTO }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = CharacterChangesDTO.fromPartial(value);
      }
      return acc;
    }, {});
    message.newTopicName = object.newTopicName ?? "";
    message.stepOutcome = object.stepOutcome ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseStepOutcomeDTO_CharacterChangesEntry(): StepOutcomeDTO_CharacterChangesEntry {
  return { key: "", value: undefined };
}

export const StepOutcomeDTO_CharacterChangesEntry: MessageFns<StepOutcomeDTO_CharacterChangesEntry> = {
  encode(message: StepOutcomeDTO_CharacterChangesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      CharacterChangesDTO.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StepOutcomeDTO_CharacterChangesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStepOutcomeDTO_CharacterChangesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = CharacterChangesDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StepOutcomeDTO_CharacterChangesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? CharacterChangesDTO.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: StepOutcomeDTO_CharacterChangesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = CharacterChangesDTO.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StepOutcomeDTO_CharacterChangesEntry>, I>>(
    base?: I,
  ): StepOutcomeDTO_CharacterChangesEntry {
    return StepOutcomeDTO_CharacterChangesEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StepOutcomeDTO_CharacterChangesEntry>, I>>(
    object: I,
  ): StepOutcomeDTO_CharacterChangesEntry {
    const message = createBaseStepOutcomeDTO_CharacterChangesEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? CharacterChangesDTO.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseCharacterChangeDTO(): CharacterChangeDTO {
  return {
    markUnfulfilledGoalsAsFulfilled: [],
    addUnfulfilledGoals: [],
    removeUnfulfilledGoals: [],
    changeDialogueAttitudeTo: "",
    addOrRemoveOrModifyItemInInventory: undefined,
  };
}

export const CharacterChangeDTO: MessageFns<CharacterChangeDTO> = {
  encode(message: CharacterChangeDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.markUnfulfilledGoalsAsFulfilled) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.addUnfulfilledGoals) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.removeUnfulfilledGoals) {
      writer.uint32(26).string(v!);
    }
    if (message.changeDialogueAttitudeTo !== "") {
      writer.uint32(34).string(message.changeDialogueAttitudeTo);
    }
    if (message.addOrRemoveOrModifyItemInInventory !== undefined) {
      InventoryChangesDTO.encode(message.addOrRemoveOrModifyItemInInventory, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterChangeDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterChangeDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.markUnfulfilledGoalsAsFulfilled.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.addUnfulfilledGoals.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.removeUnfulfilledGoals.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.changeDialogueAttitudeTo = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addOrRemoveOrModifyItemInInventory = InventoryChangesDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterChangeDTO {
    return {
      markUnfulfilledGoalsAsFulfilled: globalThis.Array.isArray(object?.markUnfulfilledGoalsAsFulfilled)
        ? object.markUnfulfilledGoalsAsFulfilled.map((e: any) => globalThis.String(e))
        : [],
      addUnfulfilledGoals: globalThis.Array.isArray(object?.addUnfulfilledGoals)
        ? object.addUnfulfilledGoals.map((e: any) => globalThis.String(e))
        : [],
      removeUnfulfilledGoals: globalThis.Array.isArray(object?.removeUnfulfilledGoals)
        ? object.removeUnfulfilledGoals.map((e: any) => globalThis.String(e))
        : [],
      changeDialogueAttitudeTo: isSet(object.changeDialogueAttitudeTo)
        ? globalThis.String(object.changeDialogueAttitudeTo)
        : "",
      addOrRemoveOrModifyItemInInventory: isSet(object.addOrRemoveOrModifyItemInInventory)
        ? InventoryChangesDTO.fromJSON(object.addOrRemoveOrModifyItemInInventory)
        : undefined,
    };
  },

  toJSON(message: CharacterChangeDTO): unknown {
    const obj: any = {};
    if (message.markUnfulfilledGoalsAsFulfilled?.length) {
      obj.markUnfulfilledGoalsAsFulfilled = message.markUnfulfilledGoalsAsFulfilled;
    }
    if (message.addUnfulfilledGoals?.length) {
      obj.addUnfulfilledGoals = message.addUnfulfilledGoals;
    }
    if (message.removeUnfulfilledGoals?.length) {
      obj.removeUnfulfilledGoals = message.removeUnfulfilledGoals;
    }
    if (message.changeDialogueAttitudeTo !== "") {
      obj.changeDialogueAttitudeTo = message.changeDialogueAttitudeTo;
    }
    if (message.addOrRemoveOrModifyItemInInventory !== undefined) {
      obj.addOrRemoveOrModifyItemInInventory = InventoryChangesDTO.toJSON(message.addOrRemoveOrModifyItemInInventory);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterChangeDTO>, I>>(base?: I): CharacterChangeDTO {
    return CharacterChangeDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterChangeDTO>, I>>(object: I): CharacterChangeDTO {
    const message = createBaseCharacterChangeDTO();
    message.markUnfulfilledGoalsAsFulfilled = object.markUnfulfilledGoalsAsFulfilled?.map((e) => e) || [];
    message.addUnfulfilledGoals = object.addUnfulfilledGoals?.map((e) => e) || [];
    message.removeUnfulfilledGoals = object.removeUnfulfilledGoals?.map((e) => e) || [];
    message.changeDialogueAttitudeTo = object.changeDialogueAttitudeTo ?? "";
    message.addOrRemoveOrModifyItemInInventory =
      (object.addOrRemoveOrModifyItemInInventory !== undefined && object.addOrRemoveOrModifyItemInInventory !== null)
        ? InventoryChangesDTO.fromPartial(object.addOrRemoveOrModifyItemInInventory)
        : undefined;
    return message;
  },
};

function createBaseCharacterChangesDTO(): CharacterChangesDTO {
  return { arr: [] };
}

export const CharacterChangesDTO: MessageFns<CharacterChangesDTO> = {
  encode(message: CharacterChangesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      CharacterChangeDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterChangesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterChangesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(CharacterChangeDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterChangesDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => CharacterChangeDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: CharacterChangesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterChangeDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterChangesDTO>, I>>(base?: I): CharacterChangesDTO {
    return CharacterChangesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterChangesDTO>, I>>(object: I): CharacterChangesDTO {
    const message = createBaseCharacterChangesDTO();
    message.arr = object.arr?.map((e) => CharacterChangeDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInventoryChangeDTO(): InventoryChangeDTO {
  return { itemId: "", quantityDeltaChange: 0 };
}

export const InventoryChangeDTO: MessageFns<InventoryChangeDTO> = {
  encode(message: InventoryChangeDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.itemId !== "") {
      writer.uint32(10).string(message.itemId);
    }
    if (message.quantityDeltaChange !== 0) {
      writer.uint32(16).int32(message.quantityDeltaChange);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InventoryChangeDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInventoryChangeDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantityDeltaChange = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InventoryChangeDTO {
    return {
      itemId: isSet(object.itemId) ? globalThis.String(object.itemId) : "",
      quantityDeltaChange: isSet(object.quantityDeltaChange) ? globalThis.Number(object.quantityDeltaChange) : 0,
    };
  },

  toJSON(message: InventoryChangeDTO): unknown {
    const obj: any = {};
    if (message.itemId !== "") {
      obj.itemId = message.itemId;
    }
    if (message.quantityDeltaChange !== 0) {
      obj.quantityDeltaChange = Math.round(message.quantityDeltaChange);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InventoryChangeDTO>, I>>(base?: I): InventoryChangeDTO {
    return InventoryChangeDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InventoryChangeDTO>, I>>(object: I): InventoryChangeDTO {
    const message = createBaseInventoryChangeDTO();
    message.itemId = object.itemId ?? "";
    message.quantityDeltaChange = object.quantityDeltaChange ?? 0;
    return message;
  },
};

function createBaseInventoryChangesDTO(): InventoryChangesDTO {
  return { arr: [] };
}

export const InventoryChangesDTO: MessageFns<InventoryChangesDTO> = {
  encode(message: InventoryChangesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      InventoryChangeDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InventoryChangesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInventoryChangesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(InventoryChangeDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InventoryChangesDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => InventoryChangeDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: InventoryChangesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => InventoryChangeDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InventoryChangesDTO>, I>>(base?: I): InventoryChangesDTO {
    return InventoryChangesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InventoryChangesDTO>, I>>(object: I): InventoryChangesDTO {
    const message = createBaseInventoryChangesDTO();
    message.arr = object.arr?.map((e) => InventoryChangeDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseKnowledgeBaseDTO(): KnowledgeBaseDTO {
  return { characters: [], factions: [], locations: [], items: [], clazz: "" };
}

export const KnowledgeBaseDTO: MessageFns<KnowledgeBaseDTO> = {
  encode(message: KnowledgeBaseDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.characters) {
      CharacterKnowledgeBaseDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.factions) {
      FactionKnowledgeBaseDTO.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.locations) {
      LocationKnowledgeBaseDTO.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.items) {
      ItemKnowledgeBaseDTO.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(42).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KnowledgeBaseDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKnowledgeBaseDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characters.push(CharacterKnowledgeBaseDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.factions.push(FactionKnowledgeBaseDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.locations.push(LocationKnowledgeBaseDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.items.push(ItemKnowledgeBaseDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KnowledgeBaseDTO {
    return {
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => CharacterKnowledgeBaseDTO.fromJSON(e))
        : [],
      factions: globalThis.Array.isArray(object?.factions)
        ? object.factions.map((e: any) => FactionKnowledgeBaseDTO.fromJSON(e))
        : [],
      locations: globalThis.Array.isArray(object?.locations)
        ? object.locations.map((e: any) => LocationKnowledgeBaseDTO.fromJSON(e))
        : [],
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => ItemKnowledgeBaseDTO.fromJSON(e))
        : [],
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: KnowledgeBaseDTO): unknown {
    const obj: any = {};
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => CharacterKnowledgeBaseDTO.toJSON(e));
    }
    if (message.factions?.length) {
      obj.factions = message.factions.map((e) => FactionKnowledgeBaseDTO.toJSON(e));
    }
    if (message.locations?.length) {
      obj.locations = message.locations.map((e) => LocationKnowledgeBaseDTO.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => ItemKnowledgeBaseDTO.toJSON(e));
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<KnowledgeBaseDTO>, I>>(base?: I): KnowledgeBaseDTO {
    return KnowledgeBaseDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<KnowledgeBaseDTO>, I>>(object: I): KnowledgeBaseDTO {
    const message = createBaseKnowledgeBaseDTO();
    message.characters = object.characters?.map((e) => CharacterKnowledgeBaseDTO.fromPartial(e)) || [];
    message.factions = object.factions?.map((e) => FactionKnowledgeBaseDTO.fromPartial(e)) || [];
    message.locations = object.locations?.map((e) => LocationKnowledgeBaseDTO.fromPartial(e)) || [];
    message.items = object.items?.map((e) => ItemKnowledgeBaseDTO.fromPartial(e)) || [];
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseCharacterKnowledgeBaseDTO(): CharacterKnowledgeBaseDTO {
  return { id: "", name: "", description: "", locationId: "", factionId: "", clazz: "" };
}

export const CharacterKnowledgeBaseDTO: MessageFns<CharacterKnowledgeBaseDTO> = {
  encode(message: CharacterKnowledgeBaseDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.locationId !== "") {
      writer.uint32(34).string(message.locationId);
    }
    if (message.factionId !== "") {
      writer.uint32(42).string(message.factionId);
    }
    if (message.clazz !== "") {
      writer.uint32(50).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterKnowledgeBaseDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterKnowledgeBaseDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.locationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.factionId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterKnowledgeBaseDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      locationId: isSet(object.locationId) ? globalThis.String(object.locationId) : "",
      factionId: isSet(object.factionId) ? globalThis.String(object.factionId) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: CharacterKnowledgeBaseDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.locationId !== "") {
      obj.locationId = message.locationId;
    }
    if (message.factionId !== "") {
      obj.factionId = message.factionId;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterKnowledgeBaseDTO>, I>>(base?: I): CharacterKnowledgeBaseDTO {
    return CharacterKnowledgeBaseDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterKnowledgeBaseDTO>, I>>(object: I): CharacterKnowledgeBaseDTO {
    const message = createBaseCharacterKnowledgeBaseDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.locationId = object.locationId ?? "";
    message.factionId = object.factionId ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseFactionKnowledgeBaseDTO(): FactionKnowledgeBaseDTO {
  return { id: "", name: "", description: "", clazz: "" };
}

export const FactionKnowledgeBaseDTO: MessageFns<FactionKnowledgeBaseDTO> = {
  encode(message: FactionKnowledgeBaseDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.clazz !== "") {
      writer.uint32(34).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactionKnowledgeBaseDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactionKnowledgeBaseDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactionKnowledgeBaseDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: FactionKnowledgeBaseDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactionKnowledgeBaseDTO>, I>>(base?: I): FactionKnowledgeBaseDTO {
    return FactionKnowledgeBaseDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactionKnowledgeBaseDTO>, I>>(object: I): FactionKnowledgeBaseDTO {
    const message = createBaseFactionKnowledgeBaseDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseLocationKnowledgeBaseDTO(): LocationKnowledgeBaseDTO {
  return { id: "", name: "", description: "", parentLocationChain: "", clazz: "" };
}

export const LocationKnowledgeBaseDTO: MessageFns<LocationKnowledgeBaseDTO> = {
  encode(message: LocationKnowledgeBaseDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.parentLocationChain !== "") {
      writer.uint32(34).string(message.parentLocationChain);
    }
    if (message.clazz !== "") {
      writer.uint32(42).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LocationKnowledgeBaseDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLocationKnowledgeBaseDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.parentLocationChain = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LocationKnowledgeBaseDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      parentLocationChain: isSet(object.parentLocationChain) ? globalThis.String(object.parentLocationChain) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: LocationKnowledgeBaseDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.parentLocationChain !== "") {
      obj.parentLocationChain = message.parentLocationChain;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LocationKnowledgeBaseDTO>, I>>(base?: I): LocationKnowledgeBaseDTO {
    return LocationKnowledgeBaseDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LocationKnowledgeBaseDTO>, I>>(object: I): LocationKnowledgeBaseDTO {
    const message = createBaseLocationKnowledgeBaseDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.parentLocationChain = object.parentLocationChain ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseItemKnowledgeBaseDTO(): ItemKnowledgeBaseDTO {
  return { id: "", name: "", description: "", clazz: "" };
}

export const ItemKnowledgeBaseDTO: MessageFns<ItemKnowledgeBaseDTO> = {
  encode(message: ItemKnowledgeBaseDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.clazz !== "") {
      writer.uint32(34).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemKnowledgeBaseDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemKnowledgeBaseDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemKnowledgeBaseDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: ItemKnowledgeBaseDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemKnowledgeBaseDTO>, I>>(base?: I): ItemKnowledgeBaseDTO {
    return ItemKnowledgeBaseDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemKnowledgeBaseDTO>, I>>(object: I): ItemKnowledgeBaseDTO {
    const message = createBaseItemKnowledgeBaseDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseGeneratePlayerDialogueOptionsRequest(): GeneratePlayerDialogueOptionsRequest {
  return { dialogueId: "", directionsQuantity: 0, variations: 0, scaleType: "" };
}

export const GeneratePlayerDialogueOptionsRequest: MessageFns<GeneratePlayerDialogueOptionsRequest> = {
  encode(message: GeneratePlayerDialogueOptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialogueId !== "") {
      writer.uint32(10).string(message.dialogueId);
    }
    if (message.directionsQuantity !== 0) {
      writer.uint32(16).int32(message.directionsQuantity);
    }
    if (message.variations !== 0) {
      writer.uint32(24).int32(message.variations);
    }
    if (message.scaleType !== "") {
      writer.uint32(34).string(message.scaleType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratePlayerDialogueOptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratePlayerDialogueOptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dialogueId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.directionsQuantity = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.variations = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scaleType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneratePlayerDialogueOptionsRequest {
    return {
      dialogueId: isSet(object.dialogueId) ? globalThis.String(object.dialogueId) : "",
      directionsQuantity: isSet(object.directionsQuantity) ? globalThis.Number(object.directionsQuantity) : 0,
      variations: isSet(object.variations) ? globalThis.Number(object.variations) : 0,
      scaleType: isSet(object.scaleType) ? globalThis.String(object.scaleType) : "",
    };
  },

  toJSON(message: GeneratePlayerDialogueOptionsRequest): unknown {
    const obj: any = {};
    if (message.dialogueId !== "") {
      obj.dialogueId = message.dialogueId;
    }
    if (message.directionsQuantity !== 0) {
      obj.directionsQuantity = Math.round(message.directionsQuantity);
    }
    if (message.variations !== 0) {
      obj.variations = Math.round(message.variations);
    }
    if (message.scaleType !== "") {
      obj.scaleType = message.scaleType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeneratePlayerDialogueOptionsRequest>, I>>(
    base?: I,
  ): GeneratePlayerDialogueOptionsRequest {
    return GeneratePlayerDialogueOptionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeneratePlayerDialogueOptionsRequest>, I>>(
    object: I,
  ): GeneratePlayerDialogueOptionsRequest {
    const message = createBaseGeneratePlayerDialogueOptionsRequest();
    message.dialogueId = object.dialogueId ?? "";
    message.directionsQuantity = object.directionsQuantity ?? 0;
    message.variations = object.variations ?? 0;
    message.scaleType = object.scaleType ?? "";
    return message;
  },
};

function createBaseGeneratePlayerDialogueOptionsResponse(): GeneratePlayerDialogueOptionsResponse {
  return { dialogueOptions: [] };
}

export const GeneratePlayerDialogueOptionsResponse: MessageFns<GeneratePlayerDialogueOptionsResponse> = {
  encode(message: GeneratePlayerDialogueOptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dialogueOptions) {
      DialogueOptionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GeneratePlayerDialogueOptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGeneratePlayerDialogueOptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dialogueOptions.push(DialogueOptionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GeneratePlayerDialogueOptionsResponse {
    return {
      dialogueOptions: globalThis.Array.isArray(object?.dialogueOptions)
        ? object.dialogueOptions.map((e: any) => DialogueOptionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GeneratePlayerDialogueOptionsResponse): unknown {
    const obj: any = {};
    if (message.dialogueOptions?.length) {
      obj.dialogueOptions = message.dialogueOptions.map((e) => DialogueOptionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GeneratePlayerDialogueOptionsResponse>, I>>(
    base?: I,
  ): GeneratePlayerDialogueOptionsResponse {
    return GeneratePlayerDialogueOptionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GeneratePlayerDialogueOptionsResponse>, I>>(
    object: I,
  ): GeneratePlayerDialogueOptionsResponse {
    const message = createBaseGeneratePlayerDialogueOptionsResponse();
    message.dialogueOptions = object.dialogueOptions?.map((e) => DialogueOptionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDialogueOptionDTO(): DialogueOptionDTO {
  return { explanation: "", dialogueDirection: "", riskImpact: "", clazz: "" };
}

export const DialogueOptionDTO: MessageFns<DialogueOptionDTO> = {
  encode(message: DialogueOptionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.explanation !== "") {
      writer.uint32(10).string(message.explanation);
    }
    if (message.dialogueDirection !== "") {
      writer.uint32(18).string(message.dialogueDirection);
    }
    if (message.riskImpact !== "") {
      writer.uint32(26).string(message.riskImpact);
    }
    if (message.clazz !== "") {
      writer.uint32(34).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DialogueOptionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDialogueOptionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.explanation = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dialogueDirection = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.riskImpact = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DialogueOptionDTO {
    return {
      explanation: isSet(object.explanation) ? globalThis.String(object.explanation) : "",
      dialogueDirection: isSet(object.dialogueDirection) ? globalThis.String(object.dialogueDirection) : "",
      riskImpact: isSet(object.riskImpact) ? globalThis.String(object.riskImpact) : "",
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: DialogueOptionDTO): unknown {
    const obj: any = {};
    if (message.explanation !== "") {
      obj.explanation = message.explanation;
    }
    if (message.dialogueDirection !== "") {
      obj.dialogueDirection = message.dialogueDirection;
    }
    if (message.riskImpact !== "") {
      obj.riskImpact = message.riskImpact;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DialogueOptionDTO>, I>>(base?: I): DialogueOptionDTO {
    return DialogueOptionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DialogueOptionDTO>, I>>(object: I): DialogueOptionDTO {
    const message = createBaseDialogueOptionDTO();
    message.explanation = object.explanation ?? "";
    message.dialogueDirection = object.dialogueDirection ?? "";
    message.riskImpact = object.riskImpact ?? "";
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseInterruptDialogueRequest(): InterruptDialogueRequest {
  return { requestId: "", aiProvider: "" };
}

export const InterruptDialogueRequest: MessageFns<InterruptDialogueRequest> = {
  encode(message: InterruptDialogueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.aiProvider !== "") {
      writer.uint32(18).string(message.aiProvider);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterruptDialogueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterruptDialogueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aiProvider = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterruptDialogueRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      aiProvider: isSet(object.aiProvider) ? globalThis.String(object.aiProvider) : "",
    };
  },

  toJSON(message: InterruptDialogueRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.aiProvider !== "") {
      obj.aiProvider = message.aiProvider;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InterruptDialogueRequest>, I>>(base?: I): InterruptDialogueRequest {
    return InterruptDialogueRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InterruptDialogueRequest>, I>>(object: I): InterruptDialogueRequest {
    const message = createBaseInterruptDialogueRequest();
    message.requestId = object.requestId ?? "";
    message.aiProvider = object.aiProvider ?? "";
    return message;
  },
};

function createBaseInterruptDialogueResponse(): InterruptDialogueResponse {
  return { requestId: "" };
}

export const InterruptDialogueResponse: MessageFns<InterruptDialogueResponse> = {
  encode(message: InterruptDialogueResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InterruptDialogueResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInterruptDialogueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InterruptDialogueResponse {
    return { requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "" };
  },

  toJSON(message: InterruptDialogueResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InterruptDialogueResponse>, I>>(base?: I): InterruptDialogueResponse {
    return InterruptDialogueResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InterruptDialogueResponse>, I>>(object: I): InterruptDialogueResponse {
    const message = createBaseInterruptDialogueResponse();
    message.requestId = object.requestId ?? "";
    return message;
  },
};

function createBaseFinalizeDialogueRequest(): FinalizeDialogueRequest {
  return { dialogueId: "", context: undefined };
}

export const FinalizeDialogueRequest: MessageFns<FinalizeDialogueRequest> = {
  encode(message: FinalizeDialogueRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialogueId !== "") {
      writer.uint32(10).string(message.dialogueId);
    }
    if (message.context !== undefined) {
      ContextDTO.encode(message.context, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeDialogueRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeDialogueRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dialogueId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.context = ContextDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeDialogueRequest {
    return {
      dialogueId: isSet(object.dialogueId) ? globalThis.String(object.dialogueId) : "",
      context: isSet(object.context) ? ContextDTO.fromJSON(object.context) : undefined,
    };
  },

  toJSON(message: FinalizeDialogueRequest): unknown {
    const obj: any = {};
    if (message.dialogueId !== "") {
      obj.dialogueId = message.dialogueId;
    }
    if (message.context !== undefined) {
      obj.context = ContextDTO.toJSON(message.context);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalizeDialogueRequest>, I>>(base?: I): FinalizeDialogueRequest {
    return FinalizeDialogueRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalizeDialogueRequest>, I>>(object: I): FinalizeDialogueRequest {
    const message = createBaseFinalizeDialogueRequest();
    message.dialogueId = object.dialogueId ?? "";
    message.context = (object.context !== undefined && object.context !== null)
      ? ContextDTO.fromPartial(object.context)
      : undefined;
    return message;
  },
};

function createBaseFinalizeDialogueResponse(): FinalizeDialogueResponse {
  return { dialogueId: "", summary: "", dialogueParticipants: [], worldContext: undefined, dialogueHistory: undefined };
}

export const FinalizeDialogueResponse: MessageFns<FinalizeDialogueResponse> = {
  encode(message: FinalizeDialogueResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dialogueId !== "") {
      writer.uint32(10).string(message.dialogueId);
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    for (const v of message.dialogueParticipants) {
      CharacterProfileDTO.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.worldContext !== undefined) {
      WorldContextDTO.encode(message.worldContext, writer.uint32(34).fork()).join();
    }
    if (message.dialogueHistory !== undefined) {
      DialogueHistoryDTO.encode(message.dialogueHistory, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeDialogueResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeDialogueResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dialogueId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.dialogueParticipants.push(CharacterProfileDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.worldContext = WorldContextDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dialogueHistory = DialogueHistoryDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeDialogueResponse {
    return {
      dialogueId: isSet(object.dialogueId) ? globalThis.String(object.dialogueId) : "",
      summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
      dialogueParticipants: globalThis.Array.isArray(object?.dialogueParticipants)
        ? object.dialogueParticipants.map((e: any) => CharacterProfileDTO.fromJSON(e))
        : [],
      worldContext: isSet(object.worldContext) ? WorldContextDTO.fromJSON(object.worldContext) : undefined,
      dialogueHistory: isSet(object.dialogueHistory) ? DialogueHistoryDTO.fromJSON(object.dialogueHistory) : undefined,
    };
  },

  toJSON(message: FinalizeDialogueResponse): unknown {
    const obj: any = {};
    if (message.dialogueId !== "") {
      obj.dialogueId = message.dialogueId;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.dialogueParticipants?.length) {
      obj.dialogueParticipants = message.dialogueParticipants.map((e) => CharacterProfileDTO.toJSON(e));
    }
    if (message.worldContext !== undefined) {
      obj.worldContext = WorldContextDTO.toJSON(message.worldContext);
    }
    if (message.dialogueHistory !== undefined) {
      obj.dialogueHistory = DialogueHistoryDTO.toJSON(message.dialogueHistory);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalizeDialogueResponse>, I>>(base?: I): FinalizeDialogueResponse {
    return FinalizeDialogueResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalizeDialogueResponse>, I>>(object: I): FinalizeDialogueResponse {
    const message = createBaseFinalizeDialogueResponse();
    message.dialogueId = object.dialogueId ?? "";
    message.summary = object.summary ?? "";
    message.dialogueParticipants = object.dialogueParticipants?.map((e) => CharacterProfileDTO.fromPartial(e)) || [];
    message.worldContext = (object.worldContext !== undefined && object.worldContext !== null)
      ? WorldContextDTO.fromPartial(object.worldContext)
      : undefined;
    message.dialogueHistory = (object.dialogueHistory !== undefined && object.dialogueHistory !== null)
      ? DialogueHistoryDTO.fromPartial(object.dialogueHistory)
      : undefined;
    return message;
  },
};

export interface DialogueService {
  InitializeDialogue(request: InitializeDialogueRequest): Promise<InitializeDialogueResponse>;
  FinalizeDialogue(request: FinalizeDialogueRequest): Promise<FinalizeDialogueResponse>;
  GeneratePlayerDialogueOptions(
    request: GeneratePlayerDialogueOptionsRequest,
  ): Promise<GeneratePlayerDialogueOptionsResponse>;
  InterruptDialogue(request: InterruptDialogueRequest): Promise<InterruptDialogueResponse>;
}

export const DialogueServiceServiceName = "dialogue.DialogueService";
export class DialogueServiceClientImpl implements DialogueService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || DialogueServiceServiceName;
    this.rpc = rpc;
    this.InitializeDialogue = this.InitializeDialogue.bind(this);
    this.FinalizeDialogue = this.FinalizeDialogue.bind(this);
    this.GeneratePlayerDialogueOptions = this.GeneratePlayerDialogueOptions.bind(this);
    this.InterruptDialogue = this.InterruptDialogue.bind(this);
  }
  InitializeDialogue(request: InitializeDialogueRequest): Promise<InitializeDialogueResponse> {
    const data = InitializeDialogueRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InitializeDialogue", data);
    return promise.then((data) => InitializeDialogueResponse.decode(new BinaryReader(data)));
  }

  FinalizeDialogue(request: FinalizeDialogueRequest): Promise<FinalizeDialogueResponse> {
    const data = FinalizeDialogueRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FinalizeDialogue", data);
    return promise.then((data) => FinalizeDialogueResponse.decode(new BinaryReader(data)));
  }

  GeneratePlayerDialogueOptions(
    request: GeneratePlayerDialogueOptionsRequest,
  ): Promise<GeneratePlayerDialogueOptionsResponse> {
    const data = GeneratePlayerDialogueOptionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GeneratePlayerDialogueOptions", data);
    return promise.then((data) => GeneratePlayerDialogueOptionsResponse.decode(new BinaryReader(data)));
  }

  InterruptDialogue(request: InterruptDialogueRequest): Promise<InterruptDialogueResponse> {
    const data = InterruptDialogueRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InterruptDialogue", data);
    return promise.then((data) => InterruptDialogueResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
