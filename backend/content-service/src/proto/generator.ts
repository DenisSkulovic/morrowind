// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.4.2
//   protoc               v3.20.3
// source: generator.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  CharacterDTO,
  CharacterGenInstructionDTO,
  CharacterGroupGenInstructionDTO,
  DataSourceEnumDTO,
  dataSourceEnumDTOFromJSON,
  dataSourceEnumDTOToJSON,
  GenerationInstructionDTO,
  ItemDTO,
} from "./common";

export const protobufPackage = "generator";

export interface GenerateItemsRequest {
  source: DataSourceEnumDTO;
  arr: GenerationInstructionDTO[];
}

export interface GenerateItemsResponse {
  arr: ItemDTO[];
}

export interface GenerateCharactersRequest {
  source: DataSourceEnumDTO;
  arr: CharacterGenInstructionDTO[];
}

export interface GenerateCharactersResponse {
  arr: CharacterDTO[];
}

export interface GenerateCharacterGroupsRequest {
  source: DataSourceEnumDTO;
  arr: CharacterGroupGenInstructionDTO[];
}

export interface GenerateCharacterGroupsResponse {
  arr: GenerateCharactersResponse[];
}

function createBaseGenerateItemsRequest(): GenerateItemsRequest {
  return { source: 0, arr: [] };
}

export const GenerateItemsRequest: MessageFns<GenerateItemsRequest> = {
  encode(message: GenerateItemsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== 0) {
      writer.uint32(8).int32(message.source);
    }
    for (const v of message.arr) {
      GenerationInstructionDTO.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateItemsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateItemsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arr.push(GenerationInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateItemsRequest {
    return {
      source: isSet(object.source) ? dataSourceEnumDTOFromJSON(object.source) : 0,
      arr: globalThis.Array.isArray(object?.arr)
        ? object.arr.map((e: any) => GenerationInstructionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateItemsRequest): unknown {
    const obj: any = {};
    if (message.source !== 0) {
      obj.source = dataSourceEnumDTOToJSON(message.source);
    }
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => GenerationInstructionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateItemsRequest>, I>>(base?: I): GenerateItemsRequest {
    return GenerateItemsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateItemsRequest>, I>>(object: I): GenerateItemsRequest {
    const message = createBaseGenerateItemsRequest();
    message.source = object.source ?? 0;
    message.arr = object.arr?.map((e) => GenerationInstructionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateItemsResponse(): GenerateItemsResponse {
  return { arr: [] };
}

export const GenerateItemsResponse: MessageFns<GenerateItemsResponse> = {
  encode(message: GenerateItemsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      ItemDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateItemsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateItemsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(ItemDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateItemsResponse {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => ItemDTO.fromJSON(e)) : [] };
  },

  toJSON(message: GenerateItemsResponse): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => ItemDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateItemsResponse>, I>>(base?: I): GenerateItemsResponse {
    return GenerateItemsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateItemsResponse>, I>>(object: I): GenerateItemsResponse {
    const message = createBaseGenerateItemsResponse();
    message.arr = object.arr?.map((e) => ItemDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateCharactersRequest(): GenerateCharactersRequest {
  return { source: 0, arr: [] };
}

export const GenerateCharactersRequest: MessageFns<GenerateCharactersRequest> = {
  encode(message: GenerateCharactersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== 0) {
      writer.uint32(8).int32(message.source);
    }
    for (const v of message.arr) {
      CharacterGenInstructionDTO.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCharactersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCharactersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arr.push(CharacterGenInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateCharactersRequest {
    return {
      source: isSet(object.source) ? dataSourceEnumDTOFromJSON(object.source) : 0,
      arr: globalThis.Array.isArray(object?.arr)
        ? object.arr.map((e: any) => CharacterGenInstructionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateCharactersRequest): unknown {
    const obj: any = {};
    if (message.source !== 0) {
      obj.source = dataSourceEnumDTOToJSON(message.source);
    }
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterGenInstructionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCharactersRequest>, I>>(base?: I): GenerateCharactersRequest {
    return GenerateCharactersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCharactersRequest>, I>>(object: I): GenerateCharactersRequest {
    const message = createBaseGenerateCharactersRequest();
    message.source = object.source ?? 0;
    message.arr = object.arr?.map((e) => CharacterGenInstructionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateCharactersResponse(): GenerateCharactersResponse {
  return { arr: [] };
}

export const GenerateCharactersResponse: MessageFns<GenerateCharactersResponse> = {
  encode(message: GenerateCharactersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      CharacterDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCharactersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCharactersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(CharacterDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateCharactersResponse {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => CharacterDTO.fromJSON(e)) : [] };
  },

  toJSON(message: GenerateCharactersResponse): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCharactersResponse>, I>>(base?: I): GenerateCharactersResponse {
    return GenerateCharactersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCharactersResponse>, I>>(object: I): GenerateCharactersResponse {
    const message = createBaseGenerateCharactersResponse();
    message.arr = object.arr?.map((e) => CharacterDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateCharacterGroupsRequest(): GenerateCharacterGroupsRequest {
  return { source: 0, arr: [] };
}

export const GenerateCharacterGroupsRequest: MessageFns<GenerateCharacterGroupsRequest> = {
  encode(message: GenerateCharacterGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== 0) {
      writer.uint32(8).int32(message.source);
    }
    for (const v of message.arr) {
      CharacterGroupGenInstructionDTO.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCharacterGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCharacterGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arr.push(CharacterGroupGenInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateCharacterGroupsRequest {
    return {
      source: isSet(object.source) ? dataSourceEnumDTOFromJSON(object.source) : 0,
      arr: globalThis.Array.isArray(object?.arr)
        ? object.arr.map((e: any) => CharacterGroupGenInstructionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateCharacterGroupsRequest): unknown {
    const obj: any = {};
    if (message.source !== 0) {
      obj.source = dataSourceEnumDTOToJSON(message.source);
    }
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterGroupGenInstructionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCharacterGroupsRequest>, I>>(base?: I): GenerateCharacterGroupsRequest {
    return GenerateCharacterGroupsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCharacterGroupsRequest>, I>>(
    object: I,
  ): GenerateCharacterGroupsRequest {
    const message = createBaseGenerateCharacterGroupsRequest();
    message.source = object.source ?? 0;
    message.arr = object.arr?.map((e) => CharacterGroupGenInstructionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateCharacterGroupsResponse(): GenerateCharacterGroupsResponse {
  return { arr: [] };
}

export const GenerateCharacterGroupsResponse: MessageFns<GenerateCharacterGroupsResponse> = {
  encode(message: GenerateCharacterGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      GenerateCharactersResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCharacterGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCharacterGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(GenerateCharactersResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateCharacterGroupsResponse {
    return {
      arr: globalThis.Array.isArray(object?.arr)
        ? object.arr.map((e: any) => GenerateCharactersResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateCharacterGroupsResponse): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => GenerateCharactersResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCharacterGroupsResponse>, I>>(base?: I): GenerateCharacterGroupsResponse {
    return GenerateCharacterGroupsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCharacterGroupsResponse>, I>>(
    object: I,
  ): GenerateCharacterGroupsResponse {
    const message = createBaseGenerateCharacterGroupsResponse();
    message.arr = object.arr?.map((e) => GenerateCharactersResponse.fromPartial(e)) || [];
    return message;
  },
};

export interface GeneratorController {
  generateItems(request: GenerateItemsRequest): Promise<GenerateItemsResponse>;
  generateCharacters(request: GenerateCharactersRequest): Promise<GenerateCharactersResponse>;
  generateCharacterGroups(request: GenerateCharacterGroupsRequest): Promise<GenerateCharacterGroupsResponse>;
}

export const GeneratorControllerServiceName = "generator.GeneratorController";
export class GeneratorControllerClientImpl implements GeneratorController {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || GeneratorControllerServiceName;
    this.rpc = rpc;
    this.generateItems = this.generateItems.bind(this);
    this.generateCharacters = this.generateCharacters.bind(this);
    this.generateCharacterGroups = this.generateCharacterGroups.bind(this);
  }
  generateItems(request: GenerateItemsRequest): Promise<GenerateItemsResponse> {
    const data = GenerateItemsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "generateItems", data);
    return promise.then((data) => GenerateItemsResponse.decode(new BinaryReader(data)));
  }

  generateCharacters(request: GenerateCharactersRequest): Promise<GenerateCharactersResponse> {
    const data = GenerateCharactersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "generateCharacters", data);
    return promise.then((data) => GenerateCharactersResponse.decode(new BinaryReader(data)));
  }

  generateCharacterGroups(request: GenerateCharacterGroupsRequest): Promise<GenerateCharacterGroupsResponse> {
    const data = GenerateCharacterGroupsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "generateCharacterGroups", data);
    return promise.then((data) => GenerateCharacterGroupsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
