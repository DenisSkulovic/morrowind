// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v3.20.3
// source: src/proto/generator.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  Character,
  CharacterGenInstruction,
  CharacterGroupGenInstruction,
  GenerationInstruction,
  Item,
} from "./common";

export const protobufPackage = "generator";

export interface GenerateItemsRequest {
  instructions: GenerationInstruction[];
}

export interface GenerateItemsResponse {
  items: Item[];
}

export interface GenerateCharactersRequest {
  instructions: CharacterGenInstruction[];
}

export interface GenerateCharactersResponse {
  character: Character[];
}

export interface GenerateCharacterGroupsRequest {
  instructions: CharacterGroupGenInstruction[];
}

export interface GenerateCharacterGroupsResponse {
  characterGroups: GenerateCharactersResponse[];
}

function createBaseGenerateItemsRequest(): GenerateItemsRequest {
  return { instructions: [] };
}

export const GenerateItemsRequest: MessageFns<GenerateItemsRequest> = {
  encode(message: GenerateItemsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instructions) {
      GenerationInstruction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateItemsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateItemsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instructions.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateItemsRequest {
    return {
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateItemsRequest): unknown {
    const obj: any = {};
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => GenerationInstruction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateItemsRequest>, I>>(base?: I): GenerateItemsRequest {
    return GenerateItemsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateItemsRequest>, I>>(object: I): GenerateItemsRequest {
    const message = createBaseGenerateItemsRequest();
    message.instructions = object.instructions?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateItemsResponse(): GenerateItemsResponse {
  return { items: [] };
}

export const GenerateItemsResponse: MessageFns<GenerateItemsResponse> = {
  encode(message: GenerateItemsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      Item.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateItemsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateItemsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Item.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateItemsResponse {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Item.fromJSON(e)) : [] };
  },

  toJSON(message: GenerateItemsResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Item.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateItemsResponse>, I>>(base?: I): GenerateItemsResponse {
    return GenerateItemsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateItemsResponse>, I>>(object: I): GenerateItemsResponse {
    const message = createBaseGenerateItemsResponse();
    message.items = object.items?.map((e) => Item.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateCharactersRequest(): GenerateCharactersRequest {
  return { instructions: [] };
}

export const GenerateCharactersRequest: MessageFns<GenerateCharactersRequest> = {
  encode(message: GenerateCharactersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instructions) {
      CharacterGenInstruction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCharactersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCharactersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instructions.push(CharacterGenInstruction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateCharactersRequest {
    return {
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => CharacterGenInstruction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateCharactersRequest): unknown {
    const obj: any = {};
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => CharacterGenInstruction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCharactersRequest>, I>>(base?: I): GenerateCharactersRequest {
    return GenerateCharactersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCharactersRequest>, I>>(object: I): GenerateCharactersRequest {
    const message = createBaseGenerateCharactersRequest();
    message.instructions = object.instructions?.map((e) => CharacterGenInstruction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateCharactersResponse(): GenerateCharactersResponse {
  return { character: [] };
}

export const GenerateCharactersResponse: MessageFns<GenerateCharactersResponse> = {
  encode(message: GenerateCharactersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.character) {
      Character.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCharactersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCharactersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.character.push(Character.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateCharactersResponse {
    return {
      character: globalThis.Array.isArray(object?.character)
        ? object.character.map((e: any) => Character.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateCharactersResponse): unknown {
    const obj: any = {};
    if (message.character?.length) {
      obj.character = message.character.map((e) => Character.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCharactersResponse>, I>>(base?: I): GenerateCharactersResponse {
    return GenerateCharactersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCharactersResponse>, I>>(object: I): GenerateCharactersResponse {
    const message = createBaseGenerateCharactersResponse();
    message.character = object.character?.map((e) => Character.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateCharacterGroupsRequest(): GenerateCharacterGroupsRequest {
  return { instructions: [] };
}

export const GenerateCharacterGroupsRequest: MessageFns<GenerateCharacterGroupsRequest> = {
  encode(message: GenerateCharacterGroupsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instructions) {
      CharacterGroupGenInstruction.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCharacterGroupsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCharacterGroupsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instructions.push(CharacterGroupGenInstruction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateCharacterGroupsRequest {
    return {
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => CharacterGroupGenInstruction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateCharacterGroupsRequest): unknown {
    const obj: any = {};
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => CharacterGroupGenInstruction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCharacterGroupsRequest>, I>>(base?: I): GenerateCharacterGroupsRequest {
    return GenerateCharacterGroupsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCharacterGroupsRequest>, I>>(
    object: I,
  ): GenerateCharacterGroupsRequest {
    const message = createBaseGenerateCharacterGroupsRequest();
    message.instructions = object.instructions?.map((e) => CharacterGroupGenInstruction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateCharacterGroupsResponse(): GenerateCharacterGroupsResponse {
  return { characterGroups: [] };
}

export const GenerateCharacterGroupsResponse: MessageFns<GenerateCharacterGroupsResponse> = {
  encode(message: GenerateCharacterGroupsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.characterGroups) {
      GenerateCharactersResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateCharacterGroupsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateCharacterGroupsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterGroups.push(GenerateCharactersResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerateCharacterGroupsResponse {
    return {
      characterGroups: globalThis.Array.isArray(object?.characterGroups)
        ? object.characterGroups.map((e: any) => GenerateCharactersResponse.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerateCharacterGroupsResponse): unknown {
    const obj: any = {};
    if (message.characterGroups?.length) {
      obj.characterGroups = message.characterGroups.map((e) => GenerateCharactersResponse.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateCharacterGroupsResponse>, I>>(base?: I): GenerateCharacterGroupsResponse {
    return GenerateCharacterGroupsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateCharacterGroupsResponse>, I>>(
    object: I,
  ): GenerateCharacterGroupsResponse {
    const message = createBaseGenerateCharacterGroupsResponse();
    message.characterGroups = object.characterGroups?.map((e) => GenerateCharactersResponse.fromPartial(e)) || [];
    return message;
  },
};

export interface GeneratorController {
  generatItems(request: GenerateItemsRequest): Promise<GenerateItemsResponse>;
  generateCharacters(request: GenerateCharactersRequest): Promise<GenerateCharactersResponse>;
  generateCharacterGroups(request: GenerateCharacterGroupsRequest): Promise<GenerateCharacterGroupsResponse>;
}

export const GeneratorControllerServiceName = "generator.GeneratorController";
export class GeneratorControllerClientImpl implements GeneratorController {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || GeneratorControllerServiceName;
    this.rpc = rpc;
    this.generatItems = this.generatItems.bind(this);
    this.generateCharacters = this.generateCharacters.bind(this);
    this.generateCharacterGroups = this.generateCharacterGroups.bind(this);
  }
  generatItems(request: GenerateItemsRequest): Promise<GenerateItemsResponse> {
    const data = GenerateItemsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "generatItems", data);
    return promise.then((data) => GenerateItemsResponse.decode(new BinaryReader(data)));
  }

  generateCharacters(request: GenerateCharactersRequest): Promise<GenerateCharactersResponse> {
    const data = GenerateCharactersRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "generateCharacters", data);
    return promise.then((data) => GenerateCharactersResponse.decode(new BinaryReader(data)));
  }

  generateCharacterGroups(request: GenerateCharacterGroupsRequest): Promise<GenerateCharacterGroupsResponse> {
    const data = GenerateCharacterGroupsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "generateCharacterGroups", data);
    return promise.then((data) => GenerateCharacterGroupsResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
