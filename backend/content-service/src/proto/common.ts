// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.4.2
//   protoc               v3.20.3
// source: common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "common";

/** ####################################################################################### */
export enum EffectTypeEnumDTO {
  EFFECT_TYPE_DAMAGE = 0,
  EFFECT_TYPE_HEALING = 1,
  EFFECT_TYPE_BUFF = 2,
  EFFECT_TYPE_DEBUFF = 3,
  EFFECT_TYPE_RESISTANCE = 4,
  EFFECT_TYPE_STEALING = 5,
  EFFECT_TYPE_NEUTRAL = 6,
  UNRECOGNIZED = -1,
}

export function effectTypeEnumDTOFromJSON(object: any): EffectTypeEnumDTO {
  switch (object) {
    case 0:
    case "EFFECT_TYPE_DAMAGE":
      return EffectTypeEnumDTO.EFFECT_TYPE_DAMAGE;
    case 1:
    case "EFFECT_TYPE_HEALING":
      return EffectTypeEnumDTO.EFFECT_TYPE_HEALING;
    case 2:
    case "EFFECT_TYPE_BUFF":
      return EffectTypeEnumDTO.EFFECT_TYPE_BUFF;
    case 3:
    case "EFFECT_TYPE_DEBUFF":
      return EffectTypeEnumDTO.EFFECT_TYPE_DEBUFF;
    case 4:
    case "EFFECT_TYPE_RESISTANCE":
      return EffectTypeEnumDTO.EFFECT_TYPE_RESISTANCE;
    case 5:
    case "EFFECT_TYPE_STEALING":
      return EffectTypeEnumDTO.EFFECT_TYPE_STEALING;
    case 6:
    case "EFFECT_TYPE_NEUTRAL":
      return EffectTypeEnumDTO.EFFECT_TYPE_NEUTRAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectTypeEnumDTO.UNRECOGNIZED;
  }
}

export function effectTypeEnumDTOToJSON(object: EffectTypeEnumDTO): string {
  switch (object) {
    case EffectTypeEnumDTO.EFFECT_TYPE_DAMAGE:
      return "EFFECT_TYPE_DAMAGE";
    case EffectTypeEnumDTO.EFFECT_TYPE_HEALING:
      return "EFFECT_TYPE_HEALING";
    case EffectTypeEnumDTO.EFFECT_TYPE_BUFF:
      return "EFFECT_TYPE_BUFF";
    case EffectTypeEnumDTO.EFFECT_TYPE_DEBUFF:
      return "EFFECT_TYPE_DEBUFF";
    case EffectTypeEnumDTO.EFFECT_TYPE_RESISTANCE:
      return "EFFECT_TYPE_RESISTANCE";
    case EffectTypeEnumDTO.EFFECT_TYPE_STEALING:
      return "EFFECT_TYPE_STEALING";
    case EffectTypeEnumDTO.EFFECT_TYPE_NEUTRAL:
      return "EFFECT_TYPE_NEUTRAL";
    case EffectTypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EffectTargetEnumDTO {
  EFFECT_TARGET_HEALTH = 0,
  EFFECT_TARGET_STAMINA = 1,
  EFFECT_TARGET_MANA = 2,
  UNRECOGNIZED = -1,
}

export function effectTargetEnumDTOFromJSON(object: any): EffectTargetEnumDTO {
  switch (object) {
    case 0:
    case "EFFECT_TARGET_HEALTH":
      return EffectTargetEnumDTO.EFFECT_TARGET_HEALTH;
    case 1:
    case "EFFECT_TARGET_STAMINA":
      return EffectTargetEnumDTO.EFFECT_TARGET_STAMINA;
    case 2:
    case "EFFECT_TARGET_MANA":
      return EffectTargetEnumDTO.EFFECT_TARGET_MANA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectTargetEnumDTO.UNRECOGNIZED;
  }
}

export function effectTargetEnumDTOToJSON(object: EffectTargetEnumDTO): string {
  switch (object) {
    case EffectTargetEnumDTO.EFFECT_TARGET_HEALTH:
      return "EFFECT_TARGET_HEALTH";
    case EffectTargetEnumDTO.EFFECT_TARGET_STAMINA:
      return "EFFECT_TARGET_STAMINA";
    case EffectTargetEnumDTO.EFFECT_TARGET_MANA:
      return "EFFECT_TARGET_MANA";
    case EffectTargetEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EffectModeEnumDTO {
  EFFECT_MODE_INSTANT = 0,
  EFFECT_MODE_GRADUAL = 1,
  EFFECT_MODE_PERSISTENT = 2,
  UNRECOGNIZED = -1,
}

export function effectModeEnumDTOFromJSON(object: any): EffectModeEnumDTO {
  switch (object) {
    case 0:
    case "EFFECT_MODE_INSTANT":
      return EffectModeEnumDTO.EFFECT_MODE_INSTANT;
    case 1:
    case "EFFECT_MODE_GRADUAL":
      return EffectModeEnumDTO.EFFECT_MODE_GRADUAL;
    case 2:
    case "EFFECT_MODE_PERSISTENT":
      return EffectModeEnumDTO.EFFECT_MODE_PERSISTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectModeEnumDTO.UNRECOGNIZED;
  }
}

export function effectModeEnumDTOToJSON(object: EffectModeEnumDTO): string {
  switch (object) {
    case EffectModeEnumDTO.EFFECT_MODE_INSTANT:
      return "EFFECT_MODE_INSTANT";
    case EffectModeEnumDTO.EFFECT_MODE_GRADUAL:
      return "EFFECT_MODE_GRADUAL";
    case EffectModeEnumDTO.EFFECT_MODE_PERSISTENT:
      return "EFFECT_MODE_PERSISTENT";
    case EffectModeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EffectElementEnumDTO {
  EFFECT_ELEMENT_FIRE = 0,
  EFFECT_ELEMENT_FROST = 1,
  EFFECT_ELEMENT_POISON = 2,
  EFFECT_ELEMENT_SHOCK = 3,
  UNRECOGNIZED = -1,
}

export function effectElementEnumDTOFromJSON(object: any): EffectElementEnumDTO {
  switch (object) {
    case 0:
    case "EFFECT_ELEMENT_FIRE":
      return EffectElementEnumDTO.EFFECT_ELEMENT_FIRE;
    case 1:
    case "EFFECT_ELEMENT_FROST":
      return EffectElementEnumDTO.EFFECT_ELEMENT_FROST;
    case 2:
    case "EFFECT_ELEMENT_POISON":
      return EffectElementEnumDTO.EFFECT_ELEMENT_POISON;
    case 3:
    case "EFFECT_ELEMENT_SHOCK":
      return EffectElementEnumDTO.EFFECT_ELEMENT_SHOCK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectElementEnumDTO.UNRECOGNIZED;
  }
}

export function effectElementEnumDTOToJSON(object: EffectElementEnumDTO): string {
  switch (object) {
    case EffectElementEnumDTO.EFFECT_ELEMENT_FIRE:
      return "EFFECT_ELEMENT_FIRE";
    case EffectElementEnumDTO.EFFECT_ELEMENT_FROST:
      return "EFFECT_ELEMENT_FROST";
    case EffectElementEnumDTO.EFFECT_ELEMENT_POISON:
      return "EFFECT_ELEMENT_POISON";
    case EffectElementEnumDTO.EFFECT_ELEMENT_SHOCK:
      return "EFFECT_ELEMENT_SHOCK";
    case EffectElementEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NeedTypeEnumDTO {
  NEED_TYPE_DYNAMIC = 0,
  NEED_TYPE_THRESHOLD = 1,
  NEED_TYPE_EXTERNAL = 2,
  UNRECOGNIZED = -1,
}

export function needTypeEnumDTOFromJSON(object: any): NeedTypeEnumDTO {
  switch (object) {
    case 0:
    case "NEED_TYPE_DYNAMIC":
      return NeedTypeEnumDTO.NEED_TYPE_DYNAMIC;
    case 1:
    case "NEED_TYPE_THRESHOLD":
      return NeedTypeEnumDTO.NEED_TYPE_THRESHOLD;
    case 2:
    case "NEED_TYPE_EXTERNAL":
      return NeedTypeEnumDTO.NEED_TYPE_EXTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NeedTypeEnumDTO.UNRECOGNIZED;
  }
}

export function needTypeEnumDTOToJSON(object: NeedTypeEnumDTO): string {
  switch (object) {
    case NeedTypeEnumDTO.NEED_TYPE_DYNAMIC:
      return "NEED_TYPE_DYNAMIC";
    case NeedTypeEnumDTO.NEED_TYPE_THRESHOLD:
      return "NEED_TYPE_THRESHOLD";
    case NeedTypeEnumDTO.NEED_TYPE_EXTERNAL:
      return "NEED_TYPE_EXTERNAL";
    case NeedTypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NeedLayerEnumDTO {
  NEED_LAYER_PHYSIOLOGICAL = 0,
  NEED_LAYER_SAFETY = 1,
  NEED_LAYER_BELONGING_AND_LOVE = 2,
  NEED_LAYER_ESTEEM = 3,
  NEED_LAYER_COGNITIVE = 4,
  NEED_LAYER_AESTHETIC = 5,
  NEED_LAYER_SELF_ACTUALIZATION = 6,
  NEED_LAYER_TRANSCENDENCE = 7,
  UNRECOGNIZED = -1,
}

export function needLayerEnumDTOFromJSON(object: any): NeedLayerEnumDTO {
  switch (object) {
    case 0:
    case "NEED_LAYER_PHYSIOLOGICAL":
      return NeedLayerEnumDTO.NEED_LAYER_PHYSIOLOGICAL;
    case 1:
    case "NEED_LAYER_SAFETY":
      return NeedLayerEnumDTO.NEED_LAYER_SAFETY;
    case 2:
    case "NEED_LAYER_BELONGING_AND_LOVE":
      return NeedLayerEnumDTO.NEED_LAYER_BELONGING_AND_LOVE;
    case 3:
    case "NEED_LAYER_ESTEEM":
      return NeedLayerEnumDTO.NEED_LAYER_ESTEEM;
    case 4:
    case "NEED_LAYER_COGNITIVE":
      return NeedLayerEnumDTO.NEED_LAYER_COGNITIVE;
    case 5:
    case "NEED_LAYER_AESTHETIC":
      return NeedLayerEnumDTO.NEED_LAYER_AESTHETIC;
    case 6:
    case "NEED_LAYER_SELF_ACTUALIZATION":
      return NeedLayerEnumDTO.NEED_LAYER_SELF_ACTUALIZATION;
    case 7:
    case "NEED_LAYER_TRANSCENDENCE":
      return NeedLayerEnumDTO.NEED_LAYER_TRANSCENDENCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NeedLayerEnumDTO.UNRECOGNIZED;
  }
}

export function needLayerEnumDTOToJSON(object: NeedLayerEnumDTO): string {
  switch (object) {
    case NeedLayerEnumDTO.NEED_LAYER_PHYSIOLOGICAL:
      return "NEED_LAYER_PHYSIOLOGICAL";
    case NeedLayerEnumDTO.NEED_LAYER_SAFETY:
      return "NEED_LAYER_SAFETY";
    case NeedLayerEnumDTO.NEED_LAYER_BELONGING_AND_LOVE:
      return "NEED_LAYER_BELONGING_AND_LOVE";
    case NeedLayerEnumDTO.NEED_LAYER_ESTEEM:
      return "NEED_LAYER_ESTEEM";
    case NeedLayerEnumDTO.NEED_LAYER_COGNITIVE:
      return "NEED_LAYER_COGNITIVE";
    case NeedLayerEnumDTO.NEED_LAYER_AESTHETIC:
      return "NEED_LAYER_AESTHETIC";
    case NeedLayerEnumDTO.NEED_LAYER_SELF_ACTUALIZATION:
      return "NEED_LAYER_SELF_ACTUALIZATION";
    case NeedLayerEnumDTO.NEED_LAYER_TRANSCENDENCE:
      return "NEED_LAYER_TRANSCENDENCE";
    case NeedLayerEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MemoryTypeEnumDTO {
  MEMORY_TYPE_GLOBAL = 0,
  MEMORY_TYPE_REGIONAL = 1,
  MEMORY_TYPE_EVENT_RELATED = 2,
  MEMORY_TYPE_HISTORIC = 3,
  MEMORY_TYPE_PERSONAL = 4,
  UNRECOGNIZED = -1,
}

export function memoryTypeEnumDTOFromJSON(object: any): MemoryTypeEnumDTO {
  switch (object) {
    case 0:
    case "MEMORY_TYPE_GLOBAL":
      return MemoryTypeEnumDTO.MEMORY_TYPE_GLOBAL;
    case 1:
    case "MEMORY_TYPE_REGIONAL":
      return MemoryTypeEnumDTO.MEMORY_TYPE_REGIONAL;
    case 2:
    case "MEMORY_TYPE_EVENT_RELATED":
      return MemoryTypeEnumDTO.MEMORY_TYPE_EVENT_RELATED;
    case 3:
    case "MEMORY_TYPE_HISTORIC":
      return MemoryTypeEnumDTO.MEMORY_TYPE_HISTORIC;
    case 4:
    case "MEMORY_TYPE_PERSONAL":
      return MemoryTypeEnumDTO.MEMORY_TYPE_PERSONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MemoryTypeEnumDTO.UNRECOGNIZED;
  }
}

export function memoryTypeEnumDTOToJSON(object: MemoryTypeEnumDTO): string {
  switch (object) {
    case MemoryTypeEnumDTO.MEMORY_TYPE_GLOBAL:
      return "MEMORY_TYPE_GLOBAL";
    case MemoryTypeEnumDTO.MEMORY_TYPE_REGIONAL:
      return "MEMORY_TYPE_REGIONAL";
    case MemoryTypeEnumDTO.MEMORY_TYPE_EVENT_RELATED:
      return "MEMORY_TYPE_EVENT_RELATED";
    case MemoryTypeEnumDTO.MEMORY_TYPE_HISTORIC:
      return "MEMORY_TYPE_HISTORIC";
    case MemoryTypeEnumDTO.MEMORY_TYPE_PERSONAL:
      return "MEMORY_TYPE_PERSONAL";
    case MemoryTypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConditionEnumDTO {
  CONDITION_OR = 0,
  CONDITION_ANY = 1,
  CONDITION_AND = 2,
  UNRECOGNIZED = -1,
}

export function conditionEnumDTOFromJSON(object: any): ConditionEnumDTO {
  switch (object) {
    case 0:
    case "CONDITION_OR":
      return ConditionEnumDTO.CONDITION_OR;
    case 1:
    case "CONDITION_ANY":
      return ConditionEnumDTO.CONDITION_ANY;
    case 2:
    case "CONDITION_AND":
      return ConditionEnumDTO.CONDITION_AND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConditionEnumDTO.UNRECOGNIZED;
  }
}

export function conditionEnumDTOToJSON(object: ConditionEnumDTO): string {
  switch (object) {
    case ConditionEnumDTO.CONDITION_OR:
      return "CONDITION_OR";
    case ConditionEnumDTO.CONDITION_ANY:
      return "CONDITION_ANY";
    case ConditionEnumDTO.CONDITION_AND:
      return "CONDITION_AND";
    case ConditionEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PresetEnumDTO {
  PRESET_DEFAULT = 0,
  PRESET_MORROWIND = 1,
  UNRECOGNIZED = -1,
}

export function presetEnumDTOFromJSON(object: any): PresetEnumDTO {
  switch (object) {
    case 0:
    case "PRESET_DEFAULT":
      return PresetEnumDTO.PRESET_DEFAULT;
    case 1:
    case "PRESET_MORROWIND":
      return PresetEnumDTO.PRESET_MORROWIND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PresetEnumDTO.UNRECOGNIZED;
  }
}

export function presetEnumDTOToJSON(object: PresetEnumDTO): string {
  switch (object) {
    case PresetEnumDTO.PRESET_DEFAULT:
      return "PRESET_DEFAULT";
    case PresetEnumDTO.PRESET_MORROWIND:
      return "PRESET_MORROWIND";
    case PresetEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TagSubtypeEnumDTO {
  TAG_SUBTYPE_MATERIAL = 0,
  TAG_SUBTYPE_CULTURE = 1,
  TAG_SUBTYPE_RELATION = 2,
  TAG_SUBTYPE_FACTION = 3,
  TAG_SUBTYPE_RELIGION = 4,
  TAG_SUBTYPE_WEAPON_QUALITY = 5,
  TAG_SUBTYPE_ARMOR_QUALITY = 6,
  TAG_SUBTYPE_WEAPON_TYPE = 7,
  TAG_SUBTYPE_STATUS = 8,
  TAG_SUBTYPE_QUEST = 9,
  UNRECOGNIZED = -1,
}

export function tagSubtypeEnumDTOFromJSON(object: any): TagSubtypeEnumDTO {
  switch (object) {
    case 0:
    case "TAG_SUBTYPE_MATERIAL":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_MATERIAL;
    case 1:
    case "TAG_SUBTYPE_CULTURE":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_CULTURE;
    case 2:
    case "TAG_SUBTYPE_RELATION":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_RELATION;
    case 3:
    case "TAG_SUBTYPE_FACTION":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_FACTION;
    case 4:
    case "TAG_SUBTYPE_RELIGION":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_RELIGION;
    case 5:
    case "TAG_SUBTYPE_WEAPON_QUALITY":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_WEAPON_QUALITY;
    case 6:
    case "TAG_SUBTYPE_ARMOR_QUALITY":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_ARMOR_QUALITY;
    case 7:
    case "TAG_SUBTYPE_WEAPON_TYPE":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_WEAPON_TYPE;
    case 8:
    case "TAG_SUBTYPE_STATUS":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_STATUS;
    case 9:
    case "TAG_SUBTYPE_QUEST":
      return TagSubtypeEnumDTO.TAG_SUBTYPE_QUEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TagSubtypeEnumDTO.UNRECOGNIZED;
  }
}

export function tagSubtypeEnumDTOToJSON(object: TagSubtypeEnumDTO): string {
  switch (object) {
    case TagSubtypeEnumDTO.TAG_SUBTYPE_MATERIAL:
      return "TAG_SUBTYPE_MATERIAL";
    case TagSubtypeEnumDTO.TAG_SUBTYPE_CULTURE:
      return "TAG_SUBTYPE_CULTURE";
    case TagSubtypeEnumDTO.TAG_SUBTYPE_RELATION:
      return "TAG_SUBTYPE_RELATION";
    case TagSubtypeEnumDTO.TAG_SUBTYPE_FACTION:
      return "TAG_SUBTYPE_FACTION";
    case TagSubtypeEnumDTO.TAG_SUBTYPE_RELIGION:
      return "TAG_SUBTYPE_RELIGION";
    case TagSubtypeEnumDTO.TAG_SUBTYPE_WEAPON_QUALITY:
      return "TAG_SUBTYPE_WEAPON_QUALITY";
    case TagSubtypeEnumDTO.TAG_SUBTYPE_ARMOR_QUALITY:
      return "TAG_SUBTYPE_ARMOR_QUALITY";
    case TagSubtypeEnumDTO.TAG_SUBTYPE_WEAPON_TYPE:
      return "TAG_SUBTYPE_WEAPON_TYPE";
    case TagSubtypeEnumDTO.TAG_SUBTYPE_STATUS:
      return "TAG_SUBTYPE_STATUS";
    case TagSubtypeEnumDTO.TAG_SUBTYPE_QUEST:
      return "TAG_SUBTYPE_QUEST";
    case TagSubtypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FactStatusEnumDTO {
  FACT_STATUS_ACCESSIBLE = 0,
  FACT_STATUS_INACCESSIBLE = 1,
  UNRECOGNIZED = -1,
}

export function factStatusEnumDTOFromJSON(object: any): FactStatusEnumDTO {
  switch (object) {
    case 0:
    case "FACT_STATUS_ACCESSIBLE":
      return FactStatusEnumDTO.FACT_STATUS_ACCESSIBLE;
    case 1:
    case "FACT_STATUS_INACCESSIBLE":
      return FactStatusEnumDTO.FACT_STATUS_INACCESSIBLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FactStatusEnumDTO.UNRECOGNIZED;
  }
}

export function factStatusEnumDTOToJSON(object: FactStatusEnumDTO): string {
  switch (object) {
    case FactStatusEnumDTO.FACT_STATUS_ACCESSIBLE:
      return "FACT_STATUS_ACCESSIBLE";
    case FactStatusEnumDTO.FACT_STATUS_INACCESSIBLE:
      return "FACT_STATUS_INACCESSIBLE";
    case FactStatusEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SkillCategoryEnumDTO {
  SKILL_CATEGORY_CRAFTING = 0,
  SKILL_CATEGORY_MAGIC = 1,
  SKILL_CATEGORY_COMBAT = 2,
  SKILL_CATEGORY_STEALTH = 3,
  SKILL_CATEGORY_SOCIAL = 4,
  UNRECOGNIZED = -1,
}

export function skillCategoryEnumDTOFromJSON(object: any): SkillCategoryEnumDTO {
  switch (object) {
    case 0:
    case "SKILL_CATEGORY_CRAFTING":
      return SkillCategoryEnumDTO.SKILL_CATEGORY_CRAFTING;
    case 1:
    case "SKILL_CATEGORY_MAGIC":
      return SkillCategoryEnumDTO.SKILL_CATEGORY_MAGIC;
    case 2:
    case "SKILL_CATEGORY_COMBAT":
      return SkillCategoryEnumDTO.SKILL_CATEGORY_COMBAT;
    case 3:
    case "SKILL_CATEGORY_STEALTH":
      return SkillCategoryEnumDTO.SKILL_CATEGORY_STEALTH;
    case 4:
    case "SKILL_CATEGORY_SOCIAL":
      return SkillCategoryEnumDTO.SKILL_CATEGORY_SOCIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SkillCategoryEnumDTO.UNRECOGNIZED;
  }
}

export function skillCategoryEnumDTOToJSON(object: SkillCategoryEnumDTO): string {
  switch (object) {
    case SkillCategoryEnumDTO.SKILL_CATEGORY_CRAFTING:
      return "SKILL_CATEGORY_CRAFTING";
    case SkillCategoryEnumDTO.SKILL_CATEGORY_MAGIC:
      return "SKILL_CATEGORY_MAGIC";
    case SkillCategoryEnumDTO.SKILL_CATEGORY_COMBAT:
      return "SKILL_CATEGORY_COMBAT";
    case SkillCategoryEnumDTO.SKILL_CATEGORY_STEALTH:
      return "SKILL_CATEGORY_STEALTH";
    case SkillCategoryEnumDTO.SKILL_CATEGORY_SOCIAL:
      return "SKILL_CATEGORY_SOCIAL";
    case SkillCategoryEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum DataSourceEnumDTO {
  DATA_SOURCE_WORLD = 0,
  DATA_SOURCE_CAMPAIGN = 1,
  UNRECOGNIZED = -1,
}

export function dataSourceEnumDTOFromJSON(object: any): DataSourceEnumDTO {
  switch (object) {
    case 0:
    case "DATA_SOURCE_WORLD":
      return DataSourceEnumDTO.DATA_SOURCE_WORLD;
    case 1:
    case "DATA_SOURCE_CAMPAIGN":
      return DataSourceEnumDTO.DATA_SOURCE_CAMPAIGN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataSourceEnumDTO.UNRECOGNIZED;
  }
}

export function dataSourceEnumDTOToJSON(object: DataSourceEnumDTO): string {
  switch (object) {
    case DataSourceEnumDTO.DATA_SOURCE_WORLD:
      return "DATA_SOURCE_WORLD";
    case DataSourceEnumDTO.DATA_SOURCE_CAMPAIGN:
      return "DATA_SOURCE_CAMPAIGN";
    case DataSourceEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GenderEnumDTO {
  GENDER_MALE = 0,
  GENDER_FEMALE = 1,
  UNRECOGNIZED = -1,
}

export function genderEnumDTOFromJSON(object: any): GenderEnumDTO {
  switch (object) {
    case 0:
    case "GENDER_MALE":
      return GenderEnumDTO.GENDER_MALE;
    case 1:
    case "GENDER_FEMALE":
      return GenderEnumDTO.GENDER_FEMALE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GenderEnumDTO.UNRECOGNIZED;
  }
}

export function genderEnumDTOToJSON(object: GenderEnumDTO): string {
  switch (object) {
    case GenderEnumDTO.GENDER_MALE:
      return "GENDER_MALE";
    case GenderEnumDTO.GENDER_FEMALE:
      return "GENDER_FEMALE";
    case GenderEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ItemActionEnumDTO {
  ITEM_ACTION_ATTACK = 0,
  ITEM_ACTION_BLOCK = 1,
  ITEM_ACTION_USE = 2,
  UNRECOGNIZED = -1,
}

export function itemActionEnumDTOFromJSON(object: any): ItemActionEnumDTO {
  switch (object) {
    case 0:
    case "ITEM_ACTION_ATTACK":
      return ItemActionEnumDTO.ITEM_ACTION_ATTACK;
    case 1:
    case "ITEM_ACTION_BLOCK":
      return ItemActionEnumDTO.ITEM_ACTION_BLOCK;
    case 2:
    case "ITEM_ACTION_USE":
      return ItemActionEnumDTO.ITEM_ACTION_USE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ItemActionEnumDTO.UNRECOGNIZED;
  }
}

export function itemActionEnumDTOToJSON(object: ItemActionEnumDTO): string {
  switch (object) {
    case ItemActionEnumDTO.ITEM_ACTION_ATTACK:
      return "ITEM_ACTION_ATTACK";
    case ItemActionEnumDTO.ITEM_ACTION_BLOCK:
      return "ITEM_ACTION_BLOCK";
    case ItemActionEnumDTO.ITEM_ACTION_USE:
      return "ITEM_ACTION_USE";
    case ItemActionEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TraitTypeEnumDTO {
  TRAIT_CONGENITAL = 0,
  TRAIT_COPING = 1,
  TRAIT_EDUCATION = 2,
  TRAIT_FAITH = 3,
  TRAIT_HEALTH = 4,
  TRAIT_INFAMY = 5,
  TRAIT_LEVELED = 6,
  TRAIT_LIFESTYLE = 7,
  TRAIT_PERSONALITY = 8,
  TRAIT_PHYSICAL = 9,
  UNRECOGNIZED = -1,
}

export function traitTypeEnumDTOFromJSON(object: any): TraitTypeEnumDTO {
  switch (object) {
    case 0:
    case "TRAIT_CONGENITAL":
      return TraitTypeEnumDTO.TRAIT_CONGENITAL;
    case 1:
    case "TRAIT_COPING":
      return TraitTypeEnumDTO.TRAIT_COPING;
    case 2:
    case "TRAIT_EDUCATION":
      return TraitTypeEnumDTO.TRAIT_EDUCATION;
    case 3:
    case "TRAIT_FAITH":
      return TraitTypeEnumDTO.TRAIT_FAITH;
    case 4:
    case "TRAIT_HEALTH":
      return TraitTypeEnumDTO.TRAIT_HEALTH;
    case 5:
    case "TRAIT_INFAMY":
      return TraitTypeEnumDTO.TRAIT_INFAMY;
    case 6:
    case "TRAIT_LEVELED":
      return TraitTypeEnumDTO.TRAIT_LEVELED;
    case 7:
    case "TRAIT_LIFESTYLE":
      return TraitTypeEnumDTO.TRAIT_LIFESTYLE;
    case 8:
    case "TRAIT_PERSONALITY":
      return TraitTypeEnumDTO.TRAIT_PERSONALITY;
    case 9:
    case "TRAIT_PHYSICAL":
      return TraitTypeEnumDTO.TRAIT_PHYSICAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TraitTypeEnumDTO.UNRECOGNIZED;
  }
}

export function traitTypeEnumDTOToJSON(object: TraitTypeEnumDTO): string {
  switch (object) {
    case TraitTypeEnumDTO.TRAIT_CONGENITAL:
      return "TRAIT_CONGENITAL";
    case TraitTypeEnumDTO.TRAIT_COPING:
      return "TRAIT_COPING";
    case TraitTypeEnumDTO.TRAIT_EDUCATION:
      return "TRAIT_EDUCATION";
    case TraitTypeEnumDTO.TRAIT_FAITH:
      return "TRAIT_FAITH";
    case TraitTypeEnumDTO.TRAIT_HEALTH:
      return "TRAIT_HEALTH";
    case TraitTypeEnumDTO.TRAIT_INFAMY:
      return "TRAIT_INFAMY";
    case TraitTypeEnumDTO.TRAIT_LEVELED:
      return "TRAIT_LEVELED";
    case TraitTypeEnumDTO.TRAIT_LIFESTYLE:
      return "TRAIT_LIFESTYLE";
    case TraitTypeEnumDTO.TRAIT_PERSONALITY:
      return "TRAIT_PERSONALITY";
    case TraitTypeEnumDTO.TRAIT_PHYSICAL:
      return "TRAIT_PHYSICAL";
    case TraitTypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PastExperienceTypeEnumDTO {
  PAST_EXPERIENCE_CHILD = 0,
  PAST_EXPERIENCE_ADULT = 1,
  UNRECOGNIZED = -1,
}

export function pastExperienceTypeEnumDTOFromJSON(object: any): PastExperienceTypeEnumDTO {
  switch (object) {
    case 0:
    case "PAST_EXPERIENCE_CHILD":
      return PastExperienceTypeEnumDTO.PAST_EXPERIENCE_CHILD;
    case 1:
    case "PAST_EXPERIENCE_ADULT":
      return PastExperienceTypeEnumDTO.PAST_EXPERIENCE_ADULT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PastExperienceTypeEnumDTO.UNRECOGNIZED;
  }
}

export function pastExperienceTypeEnumDTOToJSON(object: PastExperienceTypeEnumDTO): string {
  switch (object) {
    case PastExperienceTypeEnumDTO.PAST_EXPERIENCE_CHILD:
      return "PAST_EXPERIENCE_CHILD";
    case PastExperienceTypeEnumDTO.PAST_EXPERIENCE_ADULT:
      return "PAST_EXPERIENCE_ADULT";
    case PastExperienceTypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ####################################################################################### */
export interface BackgroundDTO {
  id: string;
  name: string;
  faction: GenerationInstructionsDTO | undefined;
  disease: GenerationInstructionsDTO | undefined;
  addiction: GenerationInstructionsDTO | undefined;
  profession: GenerationInstructionsDTO | undefined;
  race: GenerationInstructionsDTO | undefined;
  religion: GenerationInstructionsDTO | undefined;
  personality: GenerationInstructionsDTO | undefined;
  items: GenerationInstructionsDTO | undefined;
  pastExpChild: GenerationInstructionsDTO | undefined;
  pastExpAdult: GenerationInstructionsDTO | undefined;
  memoryPools: GenerationInstructionsDTO | undefined;
  skillSets: GenerationInstructionsDTO | undefined;
  skillAdjustments: { [key: string]: number };
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  targetEntity: string;
  gender: GenerationInstructionDTO | undefined;
}

export interface BackgroundDTO_SkillAdjustmentsEntry {
  key: string;
  value: number;
}

export interface BackgroundsDTO {
  arr: BackgroundDTO[];
}

/** ####################################################################################### */
export interface Metadata {
  metadata: { [key: string]: string };
}

export interface Metadata_MetadataEntry {
  key: string;
  value: string;
}

/** ####################################################################################### */
export interface EffectDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  type: EffectTypeEnumDTO;
  target: EffectTargetEnumDTO;
  mode: EffectModeEnumDTO;
  element?: EffectElementEnumDTO | undefined;
  targetEntity: string;
}

export interface EffectsDTO {
  arr: EffectDTO[];
}

/** ####################################################################################### */
export interface ResistanceDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  effectType: EffectTypeEnumDTO;
  targetEffect?: string | undefined;
  targetEntity: string;
}

export interface ResistancesDTO {
  arr: ResistanceDTO[];
}

/** ####################################################################################### */
export interface StatusDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  type: EffectTypeEnumDTO;
  effects: string[];
  duration: number;
  description: string;
  targetEntity: string;
}

export interface StatusesDTO {
  arr: StatusDTO[];
}

/** ####################################################################################### */
export interface ItemSetDTO {
  id: string;
  blueprintId: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  set: GenerationInstructionDTO | undefined;
  targetEntity: string;
}

export interface ItemSetsDTO {
  arr: ItemSetDTO[];
}

/** ####################################################################################### */
export interface ItemDTO {
  blueprintId: string;
  metadata?: Metadata | undefined;
  targetEntity: string;
  id: string;
  name: string;
  description: string;
  size: number[];
  quantity?: number | undefined;
  maxQuantity?: number | undefined;
  baseValue?: number | undefined;
  actions?: ItemActionsDTO | undefined;
  requirements?: ItemRequirementsDTO | undefined;
  stackable?: boolean | undefined;
  repairable?: boolean | undefined;
  drinkable?: boolean | undefined;
  edible?: boolean | undefined;
  gridPosition?: GridPositionDTO | undefined;
  durability?: number | undefined;
  maxDurability?: number | undefined;
  damagePierce?: string | undefined;
  armorClass?: number | undefined;
  stealthDisadvantage?: boolean | undefined;
  damageSlash?: string | undefined;
  damageBlunt?: string | undefined;
  range?: number | undefined;
  twoHanded?: boolean | undefined;
  nutrition?: number | undefined;
  spoilage?: number | undefined;
  thirstQuenched?: number | undefined;
  type?: string | undefined;
  storageSlot: string[];
  storageSlots?: StorageSlotsDTO | undefined;
  equipmentSlot: string[];
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  trainedSkill?: string | undefined;
  storageSlotDefinition?: StorageSlotDefinitionsDTO | undefined;
  weight?: number | undefined;
}

export interface ItemsDTO {
  arr: ItemDTO[];
}

/** ####################################################################################### */
export interface ItemActionsDTO {
  actions: ItemActionEnumDTO[];
}

/** ####################################################################################### */
export interface StorageSlotDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  grid: number[];
  gridState: StorageGridDTO | undefined;
  maxWeight: number;
  parentItem?: string | undefined;
  storedItems?: ItemsDTO | undefined;
  targetEntity: string;
}

export interface StorageSlotsDTO {
  arr: StorageSlotDTO[];
}

/** ####################################################################################### */
export interface StorageGridDTO {
  cells: StorageGridCellDTO[];
}

/** ####################################################################################### */
export interface StorageGridCellDTO {
  row: number;
  column: number;
  value: string;
}

/** ####################################################################################### */
export interface ItemRequirementDTO {
  /** The outer "type" key */
  type: string;
  /** The inner "name" key */
  name: string;
  /** Numerical value */
  number?:
    | number
    | undefined;
  /** Boolean value */
  flag?: boolean | undefined;
}

export interface ItemRequirementsDTO {
  arr: ItemRequirementDTO[];
}

/** ####################################################################################### */
export interface CharacterDTO {
  id: string;
  blueprintId: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  firstName: string;
  lastName: string;
  race: string;
  gender: GenderEnumDTO;
  birthsign: string;
  birthYear?: number | undefined;
  birthMonth?: string | undefined;
  birthDay?: number | undefined;
  skills: { [key: string]: number };
  equipmentSlots?: EquipmentSlotsDTO | undefined;
  professions: string[];
  memoryPools: string[];
  characterMemories: string[];
  enneagramType: string;
  traits: string[];
  diseases: string[];
  addictions: string[];
  factions: string[];
  tags: string[];
  targetEntity: string;
  birthEra?: string | undefined;
  pastExperiences: string[];
}

export interface CharacterDTO_SkillsEntry {
  key: string;
  value: number;
}

export interface CharactersDTO {
  arr: CharacterDTO[];
}

/** ####################################################################################### */
export interface AddictionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  characters: string[];
  targetEntity: string;
}

export interface AddictionsDTO {
  arr: AddictionDTO[];
}

/** ####################################################################################### */
export interface CharacterMemoryDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  character?: string | undefined;
  factStatus: FactStatusDTO[];
  importance: number;
  resistance: number;
  accumulator: number;
  acquiredAt?: number | undefined;
  lastUpdatedAt?: number | undefined;
  tags: string[];
  memory: string;
  targetEntity: string;
}

export interface CharacterMemoriesDTO {
  arr: CharacterMemoryDTO[];
}

/** ####################################################################################### */
export interface FactStatusDTO {
  factId: string;
  status: FactStatusEnumDTO;
}

export interface FactStatusesDTO {
  arr: FactStatusDTO[];
}

/** ####################################################################################### */
export interface TagDTO {
  id: string;
  blueprintId: string;
  metadata?: Metadata | undefined;
  label: string;
  subtype: TagSubtypeEnumDTO;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  targetEntity: string;
}

export interface TagsDTO {
  arr: TagDTO[];
}

/** ####################################################################################### */
export interface SkillDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  description: string;
  category: SkillCategoryEnumDTO;
  targetEntity: string;
}

export interface SkillsDTO {
  arr: SkillDTO[];
}

/** ####################################################################################### */
export interface TraitDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  targetEntity: string;
  type: TraitTypeEnumDTO;
}

export interface TraitsDTO {
  arr: TraitDTO[];
}

/** ####################################################################################### */
export interface DiseaseDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  description: string;
  severity: string;
  characters: string[];
  targetEntity: string;
}

export interface DiseasesDTO {
  arr: DiseaseDTO[];
}

/** ####################################################################################### */
export interface FactDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  description: string;
  weight: number;
  targetEntity: string;
}

export interface FactsDTO {
  arr: FactDTO[];
}

/** ####################################################################################### */
export interface FactionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  targetEntity: string;
}

export interface FactionsDTO {
  arr: FactionDTO[];
}

/** ####################################################################################### */
export interface MemoryPoolDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  description?: string | undefined;
  memoryPoolEntries: string[];
  tags: string[];
  targetEntity: string;
}

export interface MemoryPoolsDTO {
  arr: MemoryPoolDTO[];
}

/** ####################################################################################### */
export interface MemoryPoolEntryDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  memoryPool?: string | undefined;
  memory?: string | undefined;
  probability: number;
  defaultClarity: number;
  defaultImportance: number;
  targetEntity: string;
}

export interface MemoryPoolEntriesDTO {
  arr: MemoryPoolEntryDTO[];
}

/** ####################################################################################### */
export interface CharacterProfessionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  memoryPools: string[];
  targetEntity: string;
}

export interface CharacterProfessionsDTO {
  arr: CharacterProfessionDTO[];
}

/** ####################################################################################### */
export interface EquipmentSlotDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  allowedEntities: string[];
  equippedItem?: ItemDTO | undefined;
  character?: string | undefined;
  targetEntity: string;
}

export interface EquipmentSlotsDTO {
  arr: EquipmentSlotDTO[];
}

/** ####################################################################################### */
export interface BirthsignDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  targetEntity: string;
}

export interface BirthsignsDTO {
  arr: BirthsignDTO[];
}

/** ####################################################################################### */
export interface RaceDTO {
  id: string;
  blueprintId: string;
  name: string;
  equipmentSlotDefinitions?: EquipmentSlotDefinitionsDTO | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  metadata?: Metadata | undefined;
  targetEntity: string;
}

export interface RacesDTO {
  arr: RaceDTO[];
}

/** ####################################################################################### */
export interface EquipmentSlotDefinitionDTO {
  name: string;
  allowedEntities: string[];
}

export interface EquipmentSlotDefinitionsDTO {
  arr: EquipmentSlotDefinitionDTO[];
}

/** ####################################################################################### */
export interface StorageSlotDefinitionDTO {
  grid: number[];
  name: string;
  maxWeight: number;
}

export interface StorageSlotDefinitionsDTO {
  arr: StorageSlotDefinitionDTO[];
}

/** ####################################################################################### */
export interface MoodDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  description: string;
  targetEntity: string;
}

export interface MoodsDTO {
  arr: MoodDTO[];
}

/** ####################################################################################### */
export interface ReligionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  description: string;
  rituals?: ReligionRitualsDTO | undefined;
  tenets?: ReligionTenetsDTO | undefined;
  targetEntity: string;
}

export interface ReligionsDTO {
  arr: ReligionDTO[];
}

/** ####################################################################################### */
export interface ReligionRitualDTO {
  name: string;
  description: string;
}

export interface ReligionRitualsDTO {
  arr: ReligionRitualDTO[];
}

/** ####################################################################################### */
export interface ReligionTenetDTO {
  name: string;
  description: string;
}

export interface ReligionTenetsDTO {
  arr: ReligionTenetDTO[];
}

/** ####################################################################################### */
export interface GridPositionDTO {
  x: number;
  y: number;
}

/** ####################################################################################### */
export interface GenerationInstructionDTO {
  blueprintId?: string | undefined;
  idAndQuant?: IdAndQuantDTO | undefined;
  simpleProb?: SimpleProbDTO | undefined;
  gaussianProb?: GaussianProbDTO | undefined;
  combinator?: CombinatorDTO | undefined;
}

export interface GenerationInstructionsDTO {
  arr: GenerationInstructionDTO[];
}

/** ####################################################################################### */
export interface IdAndQuantDTO {
  blueprintId: string;
  quantity?: number | undefined;
}

export interface IdsAndQuantsDTO {
  arr: IdAndQuantDTO[];
}

/** ####################################################################################### */
export interface CharacterGenInstructionDTO {
  blueprintId: string;
  backgroundBlueprintId: string;
  targetEntity: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  gender?: GenderEnumDTO | undefined;
  birthEra?: string | undefined;
  birthYear?: number | undefined;
  birthMonth?: string | undefined;
  birthDay?: number | undefined;
  backgroundCustomization?: BackgroundCustomizationDTO | undefined;
  birthSign?: string | undefined;
  id: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
}

export interface CharacterGenInstructions {
  arr: CharacterGenInstructionDTO[];
}

/** ####################################################################################### */
export interface CharacterGroupGenInstructionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  set: CombinatorDTO | undefined;
  targetEntity: string;
}

export interface CharacterGroupGenInstructionsDTO {
  arr: CharacterGroupGenInstructionDTO[];
}

/** ####################################################################################### */
export interface BackgroundCustomizationDTO {
  race?: GenerationInstructionsDTO | undefined;
  faction?: GenerationInstructionsDTO | undefined;
  disease?: GenerationInstructionsDTO | undefined;
  addiction?: GenerationInstructionsDTO | undefined;
  profession?: GenerationInstructionsDTO | undefined;
  religion?: GenerationInstructionsDTO | undefined;
  itemSets?: GenerationInstructionsDTO | undefined;
  items?: GenerationInstructionsDTO | undefined;
  pastExpChild?: GenerationInstructionsDTO | undefined;
  pastExpAdult?: GenerationInstructionsDTO | undefined;
  skillSets?: GenerationInstructionsDTO | undefined;
  skillAdjustments?: SkillAdjustmentsDTO | undefined;
  personality?: GenerationInstructionsDTO | undefined;
  gender?: GenerationInstructionDTO | undefined;
}

/** ####################################################################################### */
export interface SkillAdjustmentsDTO {
  skillAdjustments: { [key: string]: number };
}

export interface SkillAdjustmentsDTO_SkillAdjustmentsEntry {
  key: string;
  value: number;
}

/** ####################################################################################### */
export interface SimpleProbDTO {
  cond: ConditionEnumDTO;
  prob: { [key: string]: number };
  clazz: string;
}

export interface SimpleProbDTO_ProbEntry {
  key: string;
  value: number;
}

/** ####################################################################################### */
export interface GaussianProbDTO {
  blueprintId: string;
  prob?: number | undefined;
  avgQuan?: number | undefined;
  stDev?: number | undefined;
  skew?: number | undefined;
  clazz: string;
}

/** ####################################################################################### */
export interface CombinatorDTO {
  name?: string | undefined;
  cond: ConditionEnumDTO;
  /** prob must be a float value between 0 and 1 inclusive */
  prob?: number | undefined;
  instructions: GenerationInstructionDTO[];
  clazz: string;
}

/** ####################################################################################### */
export interface PastExperienceDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  type: PastExperienceTypeEnumDTO;
  targetEntity: string;
}

export interface PastExperiencesDTO {
  arr: PastExperienceDTO[];
}

/** ####################################################################################### */
export interface MemoryDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  facts?: FactsDTO | undefined;
  type: MemoryTypeEnumDTO;
  description: string;
  targetEntity: string;
}

export interface MemoriesDTO {
  arr: MemoryDTO[];
}

/** ####################################################################################### */
export interface SkillSetDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  tags: string[];
  skillImprovement: SkillImprovementDTO | undefined;
  targetEntity: string;
}

export interface SkillSetsDTO {
  arr: SkillSetDTO[];
}

/** ####################################################################################### */
export interface SkillImprovementDTO {
  skillImprovement: { [key: string]: number };
}

export interface SkillImprovementDTO_SkillImprovementEntry {
  key: string;
  value: number;
}

/** ####################################################################################### */
export interface PersonalityProfileDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  enneagramType: string;
  traits: GenerationInstructionDTO[];
  targetEntity: string;
}

export interface PersonalityProfilesDTO {
  arr: PersonalityProfileDTO[];
}

/** ####################################################################################### */
export interface NeedDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: string | undefined;
  campaign?: string | undefined;
  world?: string | undefined;
  description: string;
  type: NeedTypeEnumDTO;
  layer: NeedLayerEnumDTO;
  targetEntity: string;
}

export interface NeedsDTO {
  arr: NeedDTO[];
}

/** ####################################################################################### */
export interface UserDTO {
  id: string;
  /** relations */
  backgrounds?: BackgroundsDTO | undefined;
  worlds?: WorldsDTO | undefined;
  campaigns?: CampaignsDTO | undefined;
  account?: AccountDTO | undefined;
}

export interface UsersDTO {
  arr: UserDTO[];
}

/** ####################################################################################### */
export interface AccountDTO {
  id: string;
  username: string;
  email: string;
  role: string;
  user?: UserDTO | undefined;
  preferences?: PreferencesDTO | undefined;
}

/** ####################################################################################### */
export interface PreferencesDTO {
}

/** ####################################################################################### */
export interface WorldSettings {
  settings: { [key: string]: string };
}

export interface WorldSettings_SettingsEntry {
  key: string;
  value: string;
}

/** ####################################################################################### */
export interface WorldDTO {
  id: string;
  name: string;
  description?: string | undefined;
  settings?: WorldSettings | undefined;
  frozen: boolean;
  /** relations */
  user?: string | undefined;
  campaigns?: CampaignsDTO | undefined;
}

export interface WorldsDTO {
  arr: WorldDTO[];
}

/** ####################################################################################### */
export interface CampaignDTO {
  id: string;
  name: string;
  description?: string | undefined;
  dynamicState: { [key: string]: string };
  createdAt: string;
  world?: string | undefined;
  user?: string | undefined;
}

export interface CampaignDTO_DynamicStateEntry {
  key: string;
  value: string;
}

export interface CampaignsDTO {
  arr: CampaignDTO[];
}

function createBaseBackgroundDTO(): BackgroundDTO {
  return {
    id: "",
    name: "",
    faction: undefined,
    disease: undefined,
    addiction: undefined,
    profession: undefined,
    race: undefined,
    religion: undefined,
    personality: undefined,
    items: undefined,
    pastExpChild: undefined,
    pastExpAdult: undefined,
    memoryPools: undefined,
    skillSets: undefined,
    skillAdjustments: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    targetEntity: "",
    gender: undefined,
  };
}

export const BackgroundDTO: MessageFns<BackgroundDTO> = {
  encode(message: BackgroundDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.faction !== undefined) {
      GenerationInstructionsDTO.encode(message.faction, writer.uint32(26).fork()).join();
    }
    if (message.disease !== undefined) {
      GenerationInstructionsDTO.encode(message.disease, writer.uint32(34).fork()).join();
    }
    if (message.addiction !== undefined) {
      GenerationInstructionsDTO.encode(message.addiction, writer.uint32(42).fork()).join();
    }
    if (message.profession !== undefined) {
      GenerationInstructionsDTO.encode(message.profession, writer.uint32(50).fork()).join();
    }
    if (message.race !== undefined) {
      GenerationInstructionsDTO.encode(message.race, writer.uint32(58).fork()).join();
    }
    if (message.religion !== undefined) {
      GenerationInstructionsDTO.encode(message.religion, writer.uint32(66).fork()).join();
    }
    if (message.personality !== undefined) {
      GenerationInstructionsDTO.encode(message.personality, writer.uint32(74).fork()).join();
    }
    if (message.items !== undefined) {
      GenerationInstructionsDTO.encode(message.items, writer.uint32(82).fork()).join();
    }
    if (message.pastExpChild !== undefined) {
      GenerationInstructionsDTO.encode(message.pastExpChild, writer.uint32(90).fork()).join();
    }
    if (message.pastExpAdult !== undefined) {
      GenerationInstructionsDTO.encode(message.pastExpAdult, writer.uint32(98).fork()).join();
    }
    if (message.memoryPools !== undefined) {
      GenerationInstructionsDTO.encode(message.memoryPools, writer.uint32(106).fork()).join();
    }
    if (message.skillSets !== undefined) {
      GenerationInstructionsDTO.encode(message.skillSets, writer.uint32(114).fork()).join();
    }
    Object.entries(message.skillAdjustments).forEach(([key, value]) => {
      BackgroundDTO_SkillAdjustmentsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.user !== undefined) {
      writer.uint32(130).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(138).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(146).string(message.world);
    }
    if (message.targetEntity !== "") {
      writer.uint32(154).string(message.targetEntity);
    }
    if (message.gender !== undefined) {
      GenerationInstructionDTO.encode(message.gender, writer.uint32(162).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.faction = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.disease = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addiction = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.profession = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.race = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.religion = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.personality = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.items = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.pastExpChild = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.pastExpAdult = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.memoryPools = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.skillSets = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = BackgroundDTO_SkillAdjustmentsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.skillAdjustments[entry15.key] = entry15.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.gender = GenerationInstructionDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      faction: isSet(object.faction) ? GenerationInstructionsDTO.fromJSON(object.faction) : undefined,
      disease: isSet(object.disease) ? GenerationInstructionsDTO.fromJSON(object.disease) : undefined,
      addiction: isSet(object.addiction) ? GenerationInstructionsDTO.fromJSON(object.addiction) : undefined,
      profession: isSet(object.profession) ? GenerationInstructionsDTO.fromJSON(object.profession) : undefined,
      race: isSet(object.race) ? GenerationInstructionsDTO.fromJSON(object.race) : undefined,
      religion: isSet(object.religion) ? GenerationInstructionsDTO.fromJSON(object.religion) : undefined,
      personality: isSet(object.personality) ? GenerationInstructionsDTO.fromJSON(object.personality) : undefined,
      items: isSet(object.items) ? GenerationInstructionsDTO.fromJSON(object.items) : undefined,
      pastExpChild: isSet(object.pastExpChild) ? GenerationInstructionsDTO.fromJSON(object.pastExpChild) : undefined,
      pastExpAdult: isSet(object.pastExpAdult) ? GenerationInstructionsDTO.fromJSON(object.pastExpAdult) : undefined,
      memoryPools: isSet(object.memoryPools) ? GenerationInstructionsDTO.fromJSON(object.memoryPools) : undefined,
      skillSets: isSet(object.skillSets) ? GenerationInstructionsDTO.fromJSON(object.skillSets) : undefined,
      skillAdjustments: isObject(object.skillAdjustments)
        ? Object.entries(object.skillAdjustments).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      gender: isSet(object.gender) ? GenerationInstructionDTO.fromJSON(object.gender) : undefined,
    };
  },

  toJSON(message: BackgroundDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.faction !== undefined) {
      obj.faction = GenerationInstructionsDTO.toJSON(message.faction);
    }
    if (message.disease !== undefined) {
      obj.disease = GenerationInstructionsDTO.toJSON(message.disease);
    }
    if (message.addiction !== undefined) {
      obj.addiction = GenerationInstructionsDTO.toJSON(message.addiction);
    }
    if (message.profession !== undefined) {
      obj.profession = GenerationInstructionsDTO.toJSON(message.profession);
    }
    if (message.race !== undefined) {
      obj.race = GenerationInstructionsDTO.toJSON(message.race);
    }
    if (message.religion !== undefined) {
      obj.religion = GenerationInstructionsDTO.toJSON(message.religion);
    }
    if (message.personality !== undefined) {
      obj.personality = GenerationInstructionsDTO.toJSON(message.personality);
    }
    if (message.items !== undefined) {
      obj.items = GenerationInstructionsDTO.toJSON(message.items);
    }
    if (message.pastExpChild !== undefined) {
      obj.pastExpChild = GenerationInstructionsDTO.toJSON(message.pastExpChild);
    }
    if (message.pastExpAdult !== undefined) {
      obj.pastExpAdult = GenerationInstructionsDTO.toJSON(message.pastExpAdult);
    }
    if (message.memoryPools !== undefined) {
      obj.memoryPools = GenerationInstructionsDTO.toJSON(message.memoryPools);
    }
    if (message.skillSets !== undefined) {
      obj.skillSets = GenerationInstructionsDTO.toJSON(message.skillSets);
    }
    if (message.skillAdjustments) {
      const entries = Object.entries(message.skillAdjustments);
      if (entries.length > 0) {
        obj.skillAdjustments = {};
        entries.forEach(([k, v]) => {
          obj.skillAdjustments[k] = Math.round(v);
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.gender !== undefined) {
      obj.gender = GenerationInstructionDTO.toJSON(message.gender);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundDTO>, I>>(base?: I): BackgroundDTO {
    return BackgroundDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundDTO>, I>>(object: I): BackgroundDTO {
    const message = createBaseBackgroundDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.faction = (object.faction !== undefined && object.faction !== null)
      ? GenerationInstructionsDTO.fromPartial(object.faction)
      : undefined;
    message.disease = (object.disease !== undefined && object.disease !== null)
      ? GenerationInstructionsDTO.fromPartial(object.disease)
      : undefined;
    message.addiction = (object.addiction !== undefined && object.addiction !== null)
      ? GenerationInstructionsDTO.fromPartial(object.addiction)
      : undefined;
    message.profession = (object.profession !== undefined && object.profession !== null)
      ? GenerationInstructionsDTO.fromPartial(object.profession)
      : undefined;
    message.race = (object.race !== undefined && object.race !== null)
      ? GenerationInstructionsDTO.fromPartial(object.race)
      : undefined;
    message.religion = (object.religion !== undefined && object.religion !== null)
      ? GenerationInstructionsDTO.fromPartial(object.religion)
      : undefined;
    message.personality = (object.personality !== undefined && object.personality !== null)
      ? GenerationInstructionsDTO.fromPartial(object.personality)
      : undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? GenerationInstructionsDTO.fromPartial(object.items)
      : undefined;
    message.pastExpChild = (object.pastExpChild !== undefined && object.pastExpChild !== null)
      ? GenerationInstructionsDTO.fromPartial(object.pastExpChild)
      : undefined;
    message.pastExpAdult = (object.pastExpAdult !== undefined && object.pastExpAdult !== null)
      ? GenerationInstructionsDTO.fromPartial(object.pastExpAdult)
      : undefined;
    message.memoryPools = (object.memoryPools !== undefined && object.memoryPools !== null)
      ? GenerationInstructionsDTO.fromPartial(object.memoryPools)
      : undefined;
    message.skillSets = (object.skillSets !== undefined && object.skillSets !== null)
      ? GenerationInstructionsDTO.fromPartial(object.skillSets)
      : undefined;
    message.skillAdjustments = Object.entries(object.skillAdjustments ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.targetEntity = object.targetEntity ?? "";
    message.gender = (object.gender !== undefined && object.gender !== null)
      ? GenerationInstructionDTO.fromPartial(object.gender)
      : undefined;
    return message;
  },
};

function createBaseBackgroundDTO_SkillAdjustmentsEntry(): BackgroundDTO_SkillAdjustmentsEntry {
  return { key: "", value: 0 };
}

export const BackgroundDTO_SkillAdjustmentsEntry: MessageFns<BackgroundDTO_SkillAdjustmentsEntry> = {
  encode(message: BackgroundDTO_SkillAdjustmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundDTO_SkillAdjustmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundDTO_SkillAdjustmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundDTO_SkillAdjustmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: BackgroundDTO_SkillAdjustmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundDTO_SkillAdjustmentsEntry>, I>>(
    base?: I,
  ): BackgroundDTO_SkillAdjustmentsEntry {
    return BackgroundDTO_SkillAdjustmentsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundDTO_SkillAdjustmentsEntry>, I>>(
    object: I,
  ): BackgroundDTO_SkillAdjustmentsEntry {
    const message = createBaseBackgroundDTO_SkillAdjustmentsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseBackgroundsDTO(): BackgroundsDTO {
  return { arr: [] };
}

export const BackgroundsDTO: MessageFns<BackgroundsDTO> = {
  encode(message: BackgroundsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      BackgroundDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(BackgroundDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => BackgroundDTO.fromJSON(e)) : [] };
  },

  toJSON(message: BackgroundsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => BackgroundDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundsDTO>, I>>(base?: I): BackgroundsDTO {
    return BackgroundsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundsDTO>, I>>(object: I): BackgroundsDTO {
    const message = createBaseBackgroundsDTO();
    message.arr = object.arr?.map((e) => BackgroundDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return { metadata: {} };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.metadata).forEach(([key, value]) => {
      Metadata_MetadataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Metadata_MetadataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.metadata[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata>, I>>(base?: I): Metadata {
    return Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(object: I): Metadata {
    const message = createBaseMetadata();
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMetadata_MetadataEntry(): Metadata_MetadataEntry {
  return { key: "", value: "" };
}

export const Metadata_MetadataEntry: MessageFns<Metadata_MetadataEntry> = {
  encode(message: Metadata_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Metadata_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata_MetadataEntry>, I>>(base?: I): Metadata_MetadataEntry {
    return Metadata_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata_MetadataEntry>, I>>(object: I): Metadata_MetadataEntry {
    const message = createBaseMetadata_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEffectDTO(): EffectDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    type: 0,
    target: 0,
    mode: 0,
    element: undefined,
    targetEntity: "",
  };
}

export const EffectDTO: MessageFns<EffectDTO> = {
  encode(message: EffectDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.target !== 0) {
      writer.uint32(80).int32(message.target);
    }
    if (message.mode !== 0) {
      writer.uint32(88).int32(message.mode);
    }
    if (message.element !== undefined) {
      writer.uint32(96).int32(message.element);
    }
    if (message.targetEntity !== "") {
      writer.uint32(106).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.element = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      type: isSet(object.type) ? effectTypeEnumDTOFromJSON(object.type) : 0,
      target: isSet(object.target) ? effectTargetEnumDTOFromJSON(object.target) : 0,
      mode: isSet(object.mode) ? effectModeEnumDTOFromJSON(object.mode) : 0,
      element: isSet(object.element) ? effectElementEnumDTOFromJSON(object.element) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: EffectDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.type !== 0) {
      obj.type = effectTypeEnumDTOToJSON(message.type);
    }
    if (message.target !== 0) {
      obj.target = effectTargetEnumDTOToJSON(message.target);
    }
    if (message.mode !== 0) {
      obj.mode = effectModeEnumDTOToJSON(message.mode);
    }
    if (message.element !== undefined) {
      obj.element = effectElementEnumDTOToJSON(message.element);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectDTO>, I>>(base?: I): EffectDTO {
    return EffectDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectDTO>, I>>(object: I): EffectDTO {
    const message = createBaseEffectDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.type = object.type ?? 0;
    message.target = object.target ?? 0;
    message.mode = object.mode ?? 0;
    message.element = object.element ?? undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseEffectsDTO(): EffectsDTO {
  return { arr: [] };
}

export const EffectsDTO: MessageFns<EffectsDTO> = {
  encode(message: EffectsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      EffectDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(EffectDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => EffectDTO.fromJSON(e)) : [] };
  },

  toJSON(message: EffectsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => EffectDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectsDTO>, I>>(base?: I): EffectsDTO {
    return EffectsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectsDTO>, I>>(object: I): EffectsDTO {
    const message = createBaseEffectsDTO();
    message.arr = object.arr?.map((e) => EffectDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResistanceDTO(): ResistanceDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    effectType: 0,
    targetEffect: undefined,
    targetEntity: "",
  };
}

export const ResistanceDTO: MessageFns<ResistanceDTO> = {
  encode(message: ResistanceDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.effectType !== 0) {
      writer.uint32(64).int32(message.effectType);
    }
    if (message.targetEffect !== undefined) {
      writer.uint32(74).string(message.targetEffect);
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResistanceDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResistanceDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.effectType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEffect = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResistanceDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      effectType: isSet(object.effectType) ? effectTypeEnumDTOFromJSON(object.effectType) : 0,
      targetEffect: isSet(object.targetEffect) ? globalThis.String(object.targetEffect) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: ResistanceDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.effectType !== 0) {
      obj.effectType = effectTypeEnumDTOToJSON(message.effectType);
    }
    if (message.targetEffect !== undefined) {
      obj.targetEffect = message.targetEffect;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResistanceDTO>, I>>(base?: I): ResistanceDTO {
    return ResistanceDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResistanceDTO>, I>>(object: I): ResistanceDTO {
    const message = createBaseResistanceDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.effectType = object.effectType ?? 0;
    message.targetEffect = object.targetEffect ?? undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseResistancesDTO(): ResistancesDTO {
  return { arr: [] };
}

export const ResistancesDTO: MessageFns<ResistancesDTO> = {
  encode(message: ResistancesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      ResistanceDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResistancesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResistancesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(ResistanceDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResistancesDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => ResistanceDTO.fromJSON(e)) : [] };
  },

  toJSON(message: ResistancesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => ResistanceDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResistancesDTO>, I>>(base?: I): ResistancesDTO {
    return ResistancesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResistancesDTO>, I>>(object: I): ResistancesDTO {
    const message = createBaseResistancesDTO();
    message.arr = object.arr?.map((e) => ResistanceDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStatusDTO(): StatusDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    type: 0,
    effects: [],
    duration: 0,
    description: "",
    targetEntity: "",
  };
}

export const StatusDTO: MessageFns<StatusDTO> = {
  encode(message: StatusDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    for (const v of message.effects) {
      writer.uint32(74).string(v!);
    }
    if (message.duration !== 0) {
      writer.uint32(80).int32(message.duration);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.targetEntity !== "") {
      writer.uint32(98).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.effects.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      type: isSet(object.type) ? effectTypeEnumDTOFromJSON(object.type) : 0,
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => globalThis.String(e)) : [],
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: StatusDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.type !== 0) {
      obj.type = effectTypeEnumDTOToJSON(message.type);
    }
    if (message.effects?.length) {
      obj.effects = message.effects;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusDTO>, I>>(base?: I): StatusDTO {
    return StatusDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusDTO>, I>>(object: I): StatusDTO {
    const message = createBaseStatusDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.type = object.type ?? 0;
    message.effects = object.effects?.map((e) => e) || [];
    message.duration = object.duration ?? 0;
    message.description = object.description ?? "";
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseStatusesDTO(): StatusesDTO {
  return { arr: [] };
}

export const StatusesDTO: MessageFns<StatusesDTO> = {
  encode(message: StatusesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      StatusDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(StatusDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusesDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => StatusDTO.fromJSON(e)) : [] };
  },

  toJSON(message: StatusesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => StatusDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusesDTO>, I>>(base?: I): StatusesDTO {
    return StatusesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusesDTO>, I>>(object: I): StatusesDTO {
    const message = createBaseStatusesDTO();
    message.arr = object.arr?.map((e) => StatusDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItemSetDTO(): ItemSetDTO {
  return {
    id: "",
    blueprintId: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    set: undefined,
    targetEntity: "",
  };
}

export const ItemSetDTO: MessageFns<ItemSetDTO> = {
  encode(message: ItemSetDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(34).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(42).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(50).string(message.world);
    }
    if (message.set !== undefined) {
      GenerationInstructionDTO.encode(message.set, writer.uint32(58).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(66).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemSetDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemSetDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.set = GenerationInstructionDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemSetDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      set: isSet(object.set) ? GenerationInstructionDTO.fromJSON(object.set) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: ItemSetDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.set !== undefined) {
      obj.set = GenerationInstructionDTO.toJSON(message.set);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemSetDTO>, I>>(base?: I): ItemSetDTO {
    return ItemSetDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemSetDTO>, I>>(object: I): ItemSetDTO {
    const message = createBaseItemSetDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.set = (object.set !== undefined && object.set !== null)
      ? GenerationInstructionDTO.fromPartial(object.set)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseItemSetsDTO(): ItemSetsDTO {
  return { arr: [] };
}

export const ItemSetsDTO: MessageFns<ItemSetsDTO> = {
  encode(message: ItemSetsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      ItemSetDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemSetsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemSetsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(ItemSetDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemSetsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => ItemSetDTO.fromJSON(e)) : [] };
  },

  toJSON(message: ItemSetsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => ItemSetDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemSetsDTO>, I>>(base?: I): ItemSetsDTO {
    return ItemSetsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemSetsDTO>, I>>(object: I): ItemSetsDTO {
    const message = createBaseItemSetsDTO();
    message.arr = object.arr?.map((e) => ItemSetDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItemDTO(): ItemDTO {
  return {
    blueprintId: "",
    metadata: undefined,
    targetEntity: "",
    id: "",
    name: "",
    description: "",
    size: [],
    quantity: undefined,
    maxQuantity: undefined,
    baseValue: undefined,
    actions: undefined,
    requirements: undefined,
    stackable: undefined,
    repairable: undefined,
    drinkable: undefined,
    edible: undefined,
    gridPosition: undefined,
    durability: undefined,
    maxDurability: undefined,
    damagePierce: undefined,
    armorClass: undefined,
    stealthDisadvantage: undefined,
    damageSlash: undefined,
    damageBlunt: undefined,
    range: undefined,
    twoHanded: undefined,
    nutrition: undefined,
    spoilage: undefined,
    thirstQuenched: undefined,
    type: undefined,
    storageSlot: [],
    storageSlots: undefined,
    equipmentSlot: [],
    user: undefined,
    campaign: undefined,
    world: undefined,
    trainedSkill: undefined,
    storageSlotDefinition: undefined,
    weight: undefined,
  };
}

export const ItemDTO: MessageFns<ItemDTO> = {
  encode(message: ItemDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(26).string(message.targetEntity);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    writer.uint32(58).fork();
    for (const v of message.size) {
      writer.int32(v);
    }
    writer.join();
    if (message.quantity !== undefined) {
      writer.uint32(64).int32(message.quantity);
    }
    if (message.maxQuantity !== undefined) {
      writer.uint32(72).int32(message.maxQuantity);
    }
    if (message.baseValue !== undefined) {
      writer.uint32(80).int32(message.baseValue);
    }
    if (message.actions !== undefined) {
      ItemActionsDTO.encode(message.actions, writer.uint32(90).fork()).join();
    }
    if (message.requirements !== undefined) {
      ItemRequirementsDTO.encode(message.requirements, writer.uint32(98).fork()).join();
    }
    if (message.stackable !== undefined) {
      writer.uint32(104).bool(message.stackable);
    }
    if (message.repairable !== undefined) {
      writer.uint32(112).bool(message.repairable);
    }
    if (message.drinkable !== undefined) {
      writer.uint32(120).bool(message.drinkable);
    }
    if (message.edible !== undefined) {
      writer.uint32(128).bool(message.edible);
    }
    if (message.gridPosition !== undefined) {
      GridPositionDTO.encode(message.gridPosition, writer.uint32(138).fork()).join();
    }
    if (message.durability !== undefined) {
      writer.uint32(144).int32(message.durability);
    }
    if (message.maxDurability !== undefined) {
      writer.uint32(152).int32(message.maxDurability);
    }
    if (message.damagePierce !== undefined) {
      writer.uint32(162).string(message.damagePierce);
    }
    if (message.armorClass !== undefined) {
      writer.uint32(168).int32(message.armorClass);
    }
    if (message.stealthDisadvantage !== undefined) {
      writer.uint32(176).bool(message.stealthDisadvantage);
    }
    if (message.damageSlash !== undefined) {
      writer.uint32(186).string(message.damageSlash);
    }
    if (message.damageBlunt !== undefined) {
      writer.uint32(194).string(message.damageBlunt);
    }
    if (message.range !== undefined) {
      writer.uint32(200).int32(message.range);
    }
    if (message.twoHanded !== undefined) {
      writer.uint32(208).bool(message.twoHanded);
    }
    if (message.nutrition !== undefined) {
      writer.uint32(216).int32(message.nutrition);
    }
    if (message.spoilage !== undefined) {
      writer.uint32(224).int32(message.spoilage);
    }
    if (message.thirstQuenched !== undefined) {
      writer.uint32(232).int32(message.thirstQuenched);
    }
    if (message.type !== undefined) {
      writer.uint32(242).string(message.type);
    }
    for (const v of message.storageSlot) {
      writer.uint32(250).string(v!);
    }
    if (message.storageSlots !== undefined) {
      StorageSlotsDTO.encode(message.storageSlots, writer.uint32(258).fork()).join();
    }
    for (const v of message.equipmentSlot) {
      writer.uint32(266).string(v!);
    }
    if (message.user !== undefined) {
      writer.uint32(274).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(282).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(290).string(message.world);
    }
    if (message.trainedSkill !== undefined) {
      writer.uint32(298).string(message.trainedSkill);
    }
    if (message.storageSlotDefinition !== undefined) {
      StorageSlotDefinitionsDTO.encode(message.storageSlotDefinition, writer.uint32(306).fork()).join();
    }
    if (message.weight !== undefined) {
      writer.uint32(317).float(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.size.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.size.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxQuantity = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.baseValue = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.actions = ItemActionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.requirements = ItemRequirementsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.stackable = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.repairable = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.drinkable = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.edible = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.gridPosition = GridPositionDTO.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.durability = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.maxDurability = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.damagePierce = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.armorClass = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.stealthDisadvantage = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.damageSlash = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.damageBlunt = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.range = reader.int32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.twoHanded = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.nutrition = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.spoilage = reader.int32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.thirstQuenched = reader.int32();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.storageSlot.push(reader.string());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.storageSlots = StorageSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.equipmentSlot.push(reader.string());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.trainedSkill = reader.string();
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.storageSlotDefinition = StorageSlotDefinitionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 39: {
          if (tag !== 317) {
            break;
          }

          message.weight = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemDTO {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      size: globalThis.Array.isArray(object?.size) ? object.size.map((e: any) => globalThis.Number(e)) : [],
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : undefined,
      maxQuantity: isSet(object.maxQuantity) ? globalThis.Number(object.maxQuantity) : undefined,
      baseValue: isSet(object.baseValue) ? globalThis.Number(object.baseValue) : undefined,
      actions: isSet(object.actions) ? ItemActionsDTO.fromJSON(object.actions) : undefined,
      requirements: isSet(object.requirements) ? ItemRequirementsDTO.fromJSON(object.requirements) : undefined,
      stackable: isSet(object.stackable) ? globalThis.Boolean(object.stackable) : undefined,
      repairable: isSet(object.repairable) ? globalThis.Boolean(object.repairable) : undefined,
      drinkable: isSet(object.drinkable) ? globalThis.Boolean(object.drinkable) : undefined,
      edible: isSet(object.edible) ? globalThis.Boolean(object.edible) : undefined,
      gridPosition: isSet(object.gridPosition) ? GridPositionDTO.fromJSON(object.gridPosition) : undefined,
      durability: isSet(object.durability) ? globalThis.Number(object.durability) : undefined,
      maxDurability: isSet(object.maxDurability) ? globalThis.Number(object.maxDurability) : undefined,
      damagePierce: isSet(object.damagePierce) ? globalThis.String(object.damagePierce) : undefined,
      armorClass: isSet(object.armorClass) ? globalThis.Number(object.armorClass) : undefined,
      stealthDisadvantage: isSet(object.stealthDisadvantage)
        ? globalThis.Boolean(object.stealthDisadvantage)
        : undefined,
      damageSlash: isSet(object.damageSlash) ? globalThis.String(object.damageSlash) : undefined,
      damageBlunt: isSet(object.damageBlunt) ? globalThis.String(object.damageBlunt) : undefined,
      range: isSet(object.range) ? globalThis.Number(object.range) : undefined,
      twoHanded: isSet(object.twoHanded) ? globalThis.Boolean(object.twoHanded) : undefined,
      nutrition: isSet(object.nutrition) ? globalThis.Number(object.nutrition) : undefined,
      spoilage: isSet(object.spoilage) ? globalThis.Number(object.spoilage) : undefined,
      thirstQuenched: isSet(object.thirstQuenched) ? globalThis.Number(object.thirstQuenched) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      storageSlot: globalThis.Array.isArray(object?.storageSlot)
        ? object.storageSlot.map((e: any) => globalThis.String(e))
        : [],
      storageSlots: isSet(object.storageSlots) ? StorageSlotsDTO.fromJSON(object.storageSlots) : undefined,
      equipmentSlot: globalThis.Array.isArray(object?.equipmentSlot)
        ? object.equipmentSlot.map((e: any) => globalThis.String(e))
        : [],
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      trainedSkill: isSet(object.trainedSkill) ? globalThis.String(object.trainedSkill) : undefined,
      storageSlotDefinition: isSet(object.storageSlotDefinition)
        ? StorageSlotDefinitionsDTO.fromJSON(object.storageSlotDefinition)
        : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
    };
  },

  toJSON(message: ItemDTO): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.size?.length) {
      obj.size = message.size.map((e) => Math.round(e));
    }
    if (message.quantity !== undefined) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.maxQuantity !== undefined) {
      obj.maxQuantity = Math.round(message.maxQuantity);
    }
    if (message.baseValue !== undefined) {
      obj.baseValue = Math.round(message.baseValue);
    }
    if (message.actions !== undefined) {
      obj.actions = ItemActionsDTO.toJSON(message.actions);
    }
    if (message.requirements !== undefined) {
      obj.requirements = ItemRequirementsDTO.toJSON(message.requirements);
    }
    if (message.stackable !== undefined) {
      obj.stackable = message.stackable;
    }
    if (message.repairable !== undefined) {
      obj.repairable = message.repairable;
    }
    if (message.drinkable !== undefined) {
      obj.drinkable = message.drinkable;
    }
    if (message.edible !== undefined) {
      obj.edible = message.edible;
    }
    if (message.gridPosition !== undefined) {
      obj.gridPosition = GridPositionDTO.toJSON(message.gridPosition);
    }
    if (message.durability !== undefined) {
      obj.durability = Math.round(message.durability);
    }
    if (message.maxDurability !== undefined) {
      obj.maxDurability = Math.round(message.maxDurability);
    }
    if (message.damagePierce !== undefined) {
      obj.damagePierce = message.damagePierce;
    }
    if (message.armorClass !== undefined) {
      obj.armorClass = Math.round(message.armorClass);
    }
    if (message.stealthDisadvantage !== undefined) {
      obj.stealthDisadvantage = message.stealthDisadvantage;
    }
    if (message.damageSlash !== undefined) {
      obj.damageSlash = message.damageSlash;
    }
    if (message.damageBlunt !== undefined) {
      obj.damageBlunt = message.damageBlunt;
    }
    if (message.range !== undefined) {
      obj.range = Math.round(message.range);
    }
    if (message.twoHanded !== undefined) {
      obj.twoHanded = message.twoHanded;
    }
    if (message.nutrition !== undefined) {
      obj.nutrition = Math.round(message.nutrition);
    }
    if (message.spoilage !== undefined) {
      obj.spoilage = Math.round(message.spoilage);
    }
    if (message.thirstQuenched !== undefined) {
      obj.thirstQuenched = Math.round(message.thirstQuenched);
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.storageSlot?.length) {
      obj.storageSlot = message.storageSlot;
    }
    if (message.storageSlots !== undefined) {
      obj.storageSlots = StorageSlotsDTO.toJSON(message.storageSlots);
    }
    if (message.equipmentSlot?.length) {
      obj.equipmentSlot = message.equipmentSlot;
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.trainedSkill !== undefined) {
      obj.trainedSkill = message.trainedSkill;
    }
    if (message.storageSlotDefinition !== undefined) {
      obj.storageSlotDefinition = StorageSlotDefinitionsDTO.toJSON(message.storageSlotDefinition);
    }
    if (message.weight !== undefined) {
      obj.weight = message.weight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemDTO>, I>>(base?: I): ItemDTO {
    return ItemDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemDTO>, I>>(object: I): ItemDTO {
    const message = createBaseItemDTO();
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.size = object.size?.map((e) => e) || [];
    message.quantity = object.quantity ?? undefined;
    message.maxQuantity = object.maxQuantity ?? undefined;
    message.baseValue = object.baseValue ?? undefined;
    message.actions = (object.actions !== undefined && object.actions !== null)
      ? ItemActionsDTO.fromPartial(object.actions)
      : undefined;
    message.requirements = (object.requirements !== undefined && object.requirements !== null)
      ? ItemRequirementsDTO.fromPartial(object.requirements)
      : undefined;
    message.stackable = object.stackable ?? undefined;
    message.repairable = object.repairable ?? undefined;
    message.drinkable = object.drinkable ?? undefined;
    message.edible = object.edible ?? undefined;
    message.gridPosition = (object.gridPosition !== undefined && object.gridPosition !== null)
      ? GridPositionDTO.fromPartial(object.gridPosition)
      : undefined;
    message.durability = object.durability ?? undefined;
    message.maxDurability = object.maxDurability ?? undefined;
    message.damagePierce = object.damagePierce ?? undefined;
    message.armorClass = object.armorClass ?? undefined;
    message.stealthDisadvantage = object.stealthDisadvantage ?? undefined;
    message.damageSlash = object.damageSlash ?? undefined;
    message.damageBlunt = object.damageBlunt ?? undefined;
    message.range = object.range ?? undefined;
    message.twoHanded = object.twoHanded ?? undefined;
    message.nutrition = object.nutrition ?? undefined;
    message.spoilage = object.spoilage ?? undefined;
    message.thirstQuenched = object.thirstQuenched ?? undefined;
    message.type = object.type ?? undefined;
    message.storageSlot = object.storageSlot?.map((e) => e) || [];
    message.storageSlots = (object.storageSlots !== undefined && object.storageSlots !== null)
      ? StorageSlotsDTO.fromPartial(object.storageSlots)
      : undefined;
    message.equipmentSlot = object.equipmentSlot?.map((e) => e) || [];
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.trainedSkill = object.trainedSkill ?? undefined;
    message.storageSlotDefinition =
      (object.storageSlotDefinition !== undefined && object.storageSlotDefinition !== null)
        ? StorageSlotDefinitionsDTO.fromPartial(object.storageSlotDefinition)
        : undefined;
    message.weight = object.weight ?? undefined;
    return message;
  },
};

function createBaseItemsDTO(): ItemsDTO {
  return { arr: [] };
}

export const ItemsDTO: MessageFns<ItemsDTO> = {
  encode(message: ItemsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      ItemDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(ItemDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => ItemDTO.fromJSON(e)) : [] };
  },

  toJSON(message: ItemsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => ItemDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemsDTO>, I>>(base?: I): ItemsDTO {
    return ItemsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemsDTO>, I>>(object: I): ItemsDTO {
    const message = createBaseItemsDTO();
    message.arr = object.arr?.map((e) => ItemDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItemActionsDTO(): ItemActionsDTO {
  return { actions: [] };
}

export const ItemActionsDTO: MessageFns<ItemActionsDTO> = {
  encode(message: ItemActionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.actions) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemActionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemActionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.actions.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.actions.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemActionsDTO {
    return {
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => itemActionEnumDTOFromJSON(e))
        : [],
    };
  },

  toJSON(message: ItemActionsDTO): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => itemActionEnumDTOToJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemActionsDTO>, I>>(base?: I): ItemActionsDTO {
    return ItemActionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemActionsDTO>, I>>(object: I): ItemActionsDTO {
    const message = createBaseItemActionsDTO();
    message.actions = object.actions?.map((e) => e) || [];
    return message;
  },
};

function createBaseStorageSlotDTO(): StorageSlotDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    grid: [],
    gridState: undefined,
    maxWeight: 0,
    parentItem: undefined,
    storedItems: undefined,
    targetEntity: "",
  };
}

export const StorageSlotDTO: MessageFns<StorageSlotDTO> = {
  encode(message: StorageSlotDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    writer.uint32(66).fork();
    for (const v of message.grid) {
      writer.int32(v);
    }
    writer.join();
    if (message.gridState !== undefined) {
      StorageGridDTO.encode(message.gridState, writer.uint32(74).fork()).join();
    }
    if (message.maxWeight !== 0) {
      writer.uint32(80).int32(message.maxWeight);
    }
    if (message.parentItem !== undefined) {
      writer.uint32(90).string(message.parentItem);
    }
    if (message.storedItems !== undefined) {
      ItemsDTO.encode(message.storedItems, writer.uint32(98).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(106).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlotDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlotDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.grid.push(reader.int32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.grid.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.gridState = StorageGridDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxWeight = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.parentItem = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.storedItems = ItemsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlotDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      grid: globalThis.Array.isArray(object?.grid) ? object.grid.map((e: any) => globalThis.Number(e)) : [],
      gridState: isSet(object.gridState) ? StorageGridDTO.fromJSON(object.gridState) : undefined,
      maxWeight: isSet(object.maxWeight) ? globalThis.Number(object.maxWeight) : 0,
      parentItem: isSet(object.parentItem) ? globalThis.String(object.parentItem) : undefined,
      storedItems: isSet(object.storedItems) ? ItemsDTO.fromJSON(object.storedItems) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: StorageSlotDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.grid?.length) {
      obj.grid = message.grid.map((e) => Math.round(e));
    }
    if (message.gridState !== undefined) {
      obj.gridState = StorageGridDTO.toJSON(message.gridState);
    }
    if (message.maxWeight !== 0) {
      obj.maxWeight = Math.round(message.maxWeight);
    }
    if (message.parentItem !== undefined) {
      obj.parentItem = message.parentItem;
    }
    if (message.storedItems !== undefined) {
      obj.storedItems = ItemsDTO.toJSON(message.storedItems);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlotDTO>, I>>(base?: I): StorageSlotDTO {
    return StorageSlotDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlotDTO>, I>>(object: I): StorageSlotDTO {
    const message = createBaseStorageSlotDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.grid = object.grid?.map((e) => e) || [];
    message.gridState = (object.gridState !== undefined && object.gridState !== null)
      ? StorageGridDTO.fromPartial(object.gridState)
      : undefined;
    message.maxWeight = object.maxWeight ?? 0;
    message.parentItem = object.parentItem ?? undefined;
    message.storedItems = (object.storedItems !== undefined && object.storedItems !== null)
      ? ItemsDTO.fromPartial(object.storedItems)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseStorageSlotsDTO(): StorageSlotsDTO {
  return { arr: [] };
}

export const StorageSlotsDTO: MessageFns<StorageSlotsDTO> = {
  encode(message: StorageSlotsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      StorageSlotDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlotsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlotsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(StorageSlotDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlotsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => StorageSlotDTO.fromJSON(e)) : [] };
  },

  toJSON(message: StorageSlotsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => StorageSlotDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlotsDTO>, I>>(base?: I): StorageSlotsDTO {
    return StorageSlotsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlotsDTO>, I>>(object: I): StorageSlotsDTO {
    const message = createBaseStorageSlotsDTO();
    message.arr = object.arr?.map((e) => StorageSlotDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorageGridDTO(): StorageGridDTO {
  return { cells: [] };
}

export const StorageGridDTO: MessageFns<StorageGridDTO> = {
  encode(message: StorageGridDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cells) {
      StorageGridCellDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageGridDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageGridDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cells.push(StorageGridCellDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageGridDTO {
    return {
      cells: globalThis.Array.isArray(object?.cells)
        ? object.cells.map((e: any) => StorageGridCellDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StorageGridDTO): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => StorageGridCellDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageGridDTO>, I>>(base?: I): StorageGridDTO {
    return StorageGridDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageGridDTO>, I>>(object: I): StorageGridDTO {
    const message = createBaseStorageGridDTO();
    message.cells = object.cells?.map((e) => StorageGridCellDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorageGridCellDTO(): StorageGridCellDTO {
  return { row: 0, column: 0, value: "" };
}

export const StorageGridCellDTO: MessageFns<StorageGridCellDTO> = {
  encode(message: StorageGridCellDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.row !== 0) {
      writer.uint32(8).int32(message.row);
    }
    if (message.column !== 0) {
      writer.uint32(16).int32(message.column);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageGridCellDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageGridCellDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.row = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.column = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageGridCellDTO {
    return {
      row: isSet(object.row) ? globalThis.Number(object.row) : 0,
      column: isSet(object.column) ? globalThis.Number(object.column) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StorageGridCellDTO): unknown {
    const obj: any = {};
    if (message.row !== 0) {
      obj.row = Math.round(message.row);
    }
    if (message.column !== 0) {
      obj.column = Math.round(message.column);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageGridCellDTO>, I>>(base?: I): StorageGridCellDTO {
    return StorageGridCellDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageGridCellDTO>, I>>(object: I): StorageGridCellDTO {
    const message = createBaseStorageGridCellDTO();
    message.row = object.row ?? 0;
    message.column = object.column ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseItemRequirementDTO(): ItemRequirementDTO {
  return { type: "", name: "", number: undefined, flag: undefined };
}

export const ItemRequirementDTO: MessageFns<ItemRequirementDTO> = {
  encode(message: ItemRequirementDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.number !== undefined) {
      writer.uint32(24).int32(message.number);
    }
    if (message.flag !== undefined) {
      writer.uint32(32).bool(message.flag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemRequirementDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemRequirementDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.number = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.flag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemRequirementDTO {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      number: isSet(object.number) ? globalThis.Number(object.number) : undefined,
      flag: isSet(object.flag) ? globalThis.Boolean(object.flag) : undefined,
    };
  },

  toJSON(message: ItemRequirementDTO): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.number !== undefined) {
      obj.number = Math.round(message.number);
    }
    if (message.flag !== undefined) {
      obj.flag = message.flag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemRequirementDTO>, I>>(base?: I): ItemRequirementDTO {
    return ItemRequirementDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemRequirementDTO>, I>>(object: I): ItemRequirementDTO {
    const message = createBaseItemRequirementDTO();
    message.type = object.type ?? "";
    message.name = object.name ?? "";
    message.number = object.number ?? undefined;
    message.flag = object.flag ?? undefined;
    return message;
  },
};

function createBaseItemRequirementsDTO(): ItemRequirementsDTO {
  return { arr: [] };
}

export const ItemRequirementsDTO: MessageFns<ItemRequirementsDTO> = {
  encode(message: ItemRequirementsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      ItemRequirementDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemRequirementsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemRequirementsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(ItemRequirementDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemRequirementsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => ItemRequirementDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: ItemRequirementsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => ItemRequirementDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemRequirementsDTO>, I>>(base?: I): ItemRequirementsDTO {
    return ItemRequirementsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemRequirementsDTO>, I>>(object: I): ItemRequirementsDTO {
    const message = createBaseItemRequirementsDTO();
    message.arr = object.arr?.map((e) => ItemRequirementDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterDTO(): CharacterDTO {
  return {
    id: "",
    blueprintId: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    firstName: "",
    lastName: "",
    race: "",
    gender: 0,
    birthsign: "",
    birthYear: undefined,
    birthMonth: undefined,
    birthDay: undefined,
    skills: {},
    equipmentSlots: undefined,
    professions: [],
    memoryPools: [],
    characterMemories: [],
    enneagramType: "",
    traits: [],
    diseases: [],
    addictions: [],
    factions: [],
    tags: [],
    targetEntity: "",
    birthEra: undefined,
    pastExperiences: [],
  };
}

export const CharacterDTO: MessageFns<CharacterDTO> = {
  encode(message: CharacterDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(34).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(42).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(50).string(message.world);
    }
    if (message.firstName !== "") {
      writer.uint32(58).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(66).string(message.lastName);
    }
    if (message.race !== "") {
      writer.uint32(74).string(message.race);
    }
    if (message.gender !== 0) {
      writer.uint32(80).int32(message.gender);
    }
    if (message.birthsign !== "") {
      writer.uint32(90).string(message.birthsign);
    }
    if (message.birthYear !== undefined) {
      writer.uint32(96).int32(message.birthYear);
    }
    if (message.birthMonth !== undefined) {
      writer.uint32(106).string(message.birthMonth);
    }
    if (message.birthDay !== undefined) {
      writer.uint32(112).int32(message.birthDay);
    }
    Object.entries(message.skills).forEach(([key, value]) => {
      CharacterDTO_SkillsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.equipmentSlots !== undefined) {
      EquipmentSlotsDTO.encode(message.equipmentSlots, writer.uint32(130).fork()).join();
    }
    for (const v of message.professions) {
      writer.uint32(138).string(v!);
    }
    for (const v of message.memoryPools) {
      writer.uint32(146).string(v!);
    }
    for (const v of message.characterMemories) {
      writer.uint32(154).string(v!);
    }
    if (message.enneagramType !== "") {
      writer.uint32(162).string(message.enneagramType);
    }
    for (const v of message.traits) {
      writer.uint32(170).string(v!);
    }
    for (const v of message.diseases) {
      writer.uint32(178).string(v!);
    }
    for (const v of message.addictions) {
      writer.uint32(186).string(v!);
    }
    for (const v of message.factions) {
      writer.uint32(194).string(v!);
    }
    for (const v of message.tags) {
      writer.uint32(202).string(v!);
    }
    if (message.targetEntity !== "") {
      writer.uint32(210).string(message.targetEntity);
    }
    if (message.birthEra !== undefined) {
      writer.uint32(218).string(message.birthEra);
    }
    for (const v of message.pastExperiences) {
      writer.uint32(226).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.race = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.birthsign = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.birthYear = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.birthMonth = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.birthDay = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = CharacterDTO_SkillsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.skills[entry15.key] = entry15.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.equipmentSlots = EquipmentSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.professions.push(reader.string());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.memoryPools.push(reader.string());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.characterMemories.push(reader.string());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.enneagramType = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.traits.push(reader.string());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.diseases.push(reader.string());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.addictions.push(reader.string());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.factions.push(reader.string());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.birthEra = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.pastExperiences.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      race: isSet(object.race) ? globalThis.String(object.race) : "",
      gender: isSet(object.gender) ? genderEnumDTOFromJSON(object.gender) : 0,
      birthsign: isSet(object.birthsign) ? globalThis.String(object.birthsign) : "",
      birthYear: isSet(object.birthYear) ? globalThis.Number(object.birthYear) : undefined,
      birthMonth: isSet(object.birthMonth) ? globalThis.String(object.birthMonth) : undefined,
      birthDay: isSet(object.birthDay) ? globalThis.Number(object.birthDay) : undefined,
      skills: isObject(object.skills)
        ? Object.entries(object.skills).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      equipmentSlots: isSet(object.equipmentSlots) ? EquipmentSlotsDTO.fromJSON(object.equipmentSlots) : undefined,
      professions: globalThis.Array.isArray(object?.professions)
        ? object.professions.map((e: any) => globalThis.String(e))
        : [],
      memoryPools: globalThis.Array.isArray(object?.memoryPools)
        ? object.memoryPools.map((e: any) => globalThis.String(e))
        : [],
      characterMemories: globalThis.Array.isArray(object?.characterMemories)
        ? object.characterMemories.map((e: any) => globalThis.String(e))
        : [],
      enneagramType: isSet(object.enneagramType) ? globalThis.String(object.enneagramType) : "",
      traits: globalThis.Array.isArray(object?.traits)
        ? object.traits.map((e: any) => globalThis.String(e))
        : [],
      diseases: globalThis.Array.isArray(object?.diseases) ? object.diseases.map((e: any) => globalThis.String(e)) : [],
      addictions: globalThis.Array.isArray(object?.addictions)
        ? object.addictions.map((e: any) => globalThis.String(e))
        : [],
      factions: globalThis.Array.isArray(object?.factions) ? object.factions.map((e: any) => globalThis.String(e)) : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      birthEra: isSet(object.birthEra) ? globalThis.String(object.birthEra) : undefined,
      pastExperiences: globalThis.Array.isArray(object?.pastExperiences)
        ? object.pastExperiences.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CharacterDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.race !== "") {
      obj.race = message.race;
    }
    if (message.gender !== 0) {
      obj.gender = genderEnumDTOToJSON(message.gender);
    }
    if (message.birthsign !== "") {
      obj.birthsign = message.birthsign;
    }
    if (message.birthYear !== undefined) {
      obj.birthYear = Math.round(message.birthYear);
    }
    if (message.birthMonth !== undefined) {
      obj.birthMonth = message.birthMonth;
    }
    if (message.birthDay !== undefined) {
      obj.birthDay = Math.round(message.birthDay);
    }
    if (message.skills) {
      const entries = Object.entries(message.skills);
      if (entries.length > 0) {
        obj.skills = {};
        entries.forEach(([k, v]) => {
          obj.skills[k] = Math.round(v);
        });
      }
    }
    if (message.equipmentSlots !== undefined) {
      obj.equipmentSlots = EquipmentSlotsDTO.toJSON(message.equipmentSlots);
    }
    if (message.professions?.length) {
      obj.professions = message.professions;
    }
    if (message.memoryPools?.length) {
      obj.memoryPools = message.memoryPools;
    }
    if (message.characterMemories?.length) {
      obj.characterMemories = message.characterMemories;
    }
    if (message.enneagramType !== "") {
      obj.enneagramType = message.enneagramType;
    }
    if (message.traits?.length) {
      obj.traits = message.traits;
    }
    if (message.diseases?.length) {
      obj.diseases = message.diseases;
    }
    if (message.addictions?.length) {
      obj.addictions = message.addictions;
    }
    if (message.factions?.length) {
      obj.factions = message.factions;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.birthEra !== undefined) {
      obj.birthEra = message.birthEra;
    }
    if (message.pastExperiences?.length) {
      obj.pastExperiences = message.pastExperiences;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterDTO>, I>>(base?: I): CharacterDTO {
    return CharacterDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterDTO>, I>>(object: I): CharacterDTO {
    const message = createBaseCharacterDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.race = object.race ?? "";
    message.gender = object.gender ?? 0;
    message.birthsign = object.birthsign ?? "";
    message.birthYear = object.birthYear ?? undefined;
    message.birthMonth = object.birthMonth ?? undefined;
    message.birthDay = object.birthDay ?? undefined;
    message.skills = Object.entries(object.skills ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.equipmentSlots = (object.equipmentSlots !== undefined && object.equipmentSlots !== null)
      ? EquipmentSlotsDTO.fromPartial(object.equipmentSlots)
      : undefined;
    message.professions = object.professions?.map((e) => e) || [];
    message.memoryPools = object.memoryPools?.map((e) => e) || [];
    message.characterMemories = object.characterMemories?.map((e) => e) || [];
    message.enneagramType = object.enneagramType ?? "";
    message.traits = object.traits?.map((e) => e) || [];
    message.diseases = object.diseases?.map((e) => e) || [];
    message.addictions = object.addictions?.map((e) => e) || [];
    message.factions = object.factions?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.targetEntity = object.targetEntity ?? "";
    message.birthEra = object.birthEra ?? undefined;
    message.pastExperiences = object.pastExperiences?.map((e) => e) || [];
    return message;
  },
};

function createBaseCharacterDTO_SkillsEntry(): CharacterDTO_SkillsEntry {
  return { key: "", value: 0 };
}

export const CharacterDTO_SkillsEntry: MessageFns<CharacterDTO_SkillsEntry> = {
  encode(message: CharacterDTO_SkillsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterDTO_SkillsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterDTO_SkillsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterDTO_SkillsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CharacterDTO_SkillsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterDTO_SkillsEntry>, I>>(base?: I): CharacterDTO_SkillsEntry {
    return CharacterDTO_SkillsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterDTO_SkillsEntry>, I>>(object: I): CharacterDTO_SkillsEntry {
    const message = createBaseCharacterDTO_SkillsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCharactersDTO(): CharactersDTO {
  return { arr: [] };
}

export const CharactersDTO: MessageFns<CharactersDTO> = {
  encode(message: CharactersDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      CharacterDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharactersDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharactersDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(CharacterDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharactersDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => CharacterDTO.fromJSON(e)) : [] };
  },

  toJSON(message: CharactersDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharactersDTO>, I>>(base?: I): CharactersDTO {
    return CharactersDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharactersDTO>, I>>(object: I): CharactersDTO {
    const message = createBaseCharactersDTO();
    message.arr = object.arr?.map((e) => CharacterDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddictionDTO(): AddictionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    characters: [],
    targetEntity: "",
  };
}

export const AddictionDTO: MessageFns<AddictionDTO> = {
  encode(message: AddictionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.characters) {
      writer.uint32(66).string(v!);
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddictionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddictionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.characters.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddictionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => globalThis.String(e))
        : [],
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: AddictionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.characters?.length) {
      obj.characters = message.characters;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddictionDTO>, I>>(base?: I): AddictionDTO {
    return AddictionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddictionDTO>, I>>(object: I): AddictionDTO {
    const message = createBaseAddictionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.characters = object.characters?.map((e) => e) || [];
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseAddictionsDTO(): AddictionsDTO {
  return { arr: [] };
}

export const AddictionsDTO: MessageFns<AddictionsDTO> = {
  encode(message: AddictionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      AddictionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddictionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddictionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(AddictionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddictionsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => AddictionDTO.fromJSON(e)) : [] };
  },

  toJSON(message: AddictionsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => AddictionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddictionsDTO>, I>>(base?: I): AddictionsDTO {
    return AddictionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddictionsDTO>, I>>(object: I): AddictionsDTO {
    const message = createBaseAddictionsDTO();
    message.arr = object.arr?.map((e) => AddictionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterMemoryDTO(): CharacterMemoryDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    character: undefined,
    factStatus: [],
    importance: 0,
    resistance: 0,
    accumulator: 0,
    acquiredAt: undefined,
    lastUpdatedAt: undefined,
    tags: [],
    memory: "",
    targetEntity: "",
  };
}

export const CharacterMemoryDTO: MessageFns<CharacterMemoryDTO> = {
  encode(message: CharacterMemoryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.character !== undefined) {
      writer.uint32(66).string(message.character);
    }
    for (const v of message.factStatus) {
      FactStatusDTO.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.importance !== 0) {
      writer.uint32(80).int32(message.importance);
    }
    if (message.resistance !== 0) {
      writer.uint32(88).int32(message.resistance);
    }
    if (message.accumulator !== 0) {
      writer.uint32(96).int32(message.accumulator);
    }
    if (message.acquiredAt !== undefined) {
      writer.uint32(104).int32(message.acquiredAt);
    }
    if (message.lastUpdatedAt !== undefined) {
      writer.uint32(112).int32(message.lastUpdatedAt);
    }
    for (const v of message.tags) {
      writer.uint32(122).string(v!);
    }
    if (message.memory !== "") {
      writer.uint32(130).string(message.memory);
    }
    if (message.targetEntity !== "") {
      writer.uint32(138).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterMemoryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterMemoryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.character = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.factStatus.push(FactStatusDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.importance = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.resistance = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.accumulator = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.acquiredAt = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.lastUpdatedAt = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.memory = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterMemoryDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      character: isSet(object.character) ? globalThis.String(object.character) : undefined,
      factStatus: globalThis.Array.isArray(object?.factStatus)
        ? object.factStatus.map((e: any) => FactStatusDTO.fromJSON(e))
        : [],
      importance: isSet(object.importance) ? globalThis.Number(object.importance) : 0,
      resistance: isSet(object.resistance) ? globalThis.Number(object.resistance) : 0,
      accumulator: isSet(object.accumulator) ? globalThis.Number(object.accumulator) : 0,
      acquiredAt: isSet(object.acquiredAt) ? globalThis.Number(object.acquiredAt) : undefined,
      lastUpdatedAt: isSet(object.lastUpdatedAt) ? globalThis.Number(object.lastUpdatedAt) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      memory: isSet(object.memory) ? globalThis.String(object.memory) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: CharacterMemoryDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.character !== undefined) {
      obj.character = message.character;
    }
    if (message.factStatus?.length) {
      obj.factStatus = message.factStatus.map((e) => FactStatusDTO.toJSON(e));
    }
    if (message.importance !== 0) {
      obj.importance = Math.round(message.importance);
    }
    if (message.resistance !== 0) {
      obj.resistance = Math.round(message.resistance);
    }
    if (message.accumulator !== 0) {
      obj.accumulator = Math.round(message.accumulator);
    }
    if (message.acquiredAt !== undefined) {
      obj.acquiredAt = Math.round(message.acquiredAt);
    }
    if (message.lastUpdatedAt !== undefined) {
      obj.lastUpdatedAt = Math.round(message.lastUpdatedAt);
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.memory !== "") {
      obj.memory = message.memory;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterMemoryDTO>, I>>(base?: I): CharacterMemoryDTO {
    return CharacterMemoryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterMemoryDTO>, I>>(object: I): CharacterMemoryDTO {
    const message = createBaseCharacterMemoryDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.character = object.character ?? undefined;
    message.factStatus = object.factStatus?.map((e) => FactStatusDTO.fromPartial(e)) || [];
    message.importance = object.importance ?? 0;
    message.resistance = object.resistance ?? 0;
    message.accumulator = object.accumulator ?? 0;
    message.acquiredAt = object.acquiredAt ?? undefined;
    message.lastUpdatedAt = object.lastUpdatedAt ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.memory = object.memory ?? "";
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseCharacterMemoriesDTO(): CharacterMemoriesDTO {
  return { arr: [] };
}

export const CharacterMemoriesDTO: MessageFns<CharacterMemoriesDTO> = {
  encode(message: CharacterMemoriesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      CharacterMemoryDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterMemoriesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterMemoriesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(CharacterMemoryDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterMemoriesDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => CharacterMemoryDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: CharacterMemoriesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterMemoryDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterMemoriesDTO>, I>>(base?: I): CharacterMemoriesDTO {
    return CharacterMemoriesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterMemoriesDTO>, I>>(object: I): CharacterMemoriesDTO {
    const message = createBaseCharacterMemoriesDTO();
    message.arr = object.arr?.map((e) => CharacterMemoryDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFactStatusDTO(): FactStatusDTO {
  return { factId: "", status: 0 };
}

export const FactStatusDTO: MessageFns<FactStatusDTO> = {
  encode(message: FactStatusDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.factId !== "") {
      writer.uint32(10).string(message.factId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactStatusDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactStatusDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.factId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactStatusDTO {
    return {
      factId: isSet(object.factId) ? globalThis.String(object.factId) : "",
      status: isSet(object.status) ? factStatusEnumDTOFromJSON(object.status) : 0,
    };
  },

  toJSON(message: FactStatusDTO): unknown {
    const obj: any = {};
    if (message.factId !== "") {
      obj.factId = message.factId;
    }
    if (message.status !== 0) {
      obj.status = factStatusEnumDTOToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactStatusDTO>, I>>(base?: I): FactStatusDTO {
    return FactStatusDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactStatusDTO>, I>>(object: I): FactStatusDTO {
    const message = createBaseFactStatusDTO();
    message.factId = object.factId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseFactStatusesDTO(): FactStatusesDTO {
  return { arr: [] };
}

export const FactStatusesDTO: MessageFns<FactStatusesDTO> = {
  encode(message: FactStatusesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      FactStatusDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactStatusesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactStatusesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(FactStatusDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactStatusesDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => FactStatusDTO.fromJSON(e)) : [] };
  },

  toJSON(message: FactStatusesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => FactStatusDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactStatusesDTO>, I>>(base?: I): FactStatusesDTO {
    return FactStatusesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactStatusesDTO>, I>>(object: I): FactStatusesDTO {
    const message = createBaseFactStatusesDTO();
    message.arr = object.arr?.map((e) => FactStatusDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTagDTO(): TagDTO {
  return {
    id: "",
    blueprintId: "",
    metadata: undefined,
    label: "",
    subtype: 0,
    user: undefined,
    campaign: undefined,
    world: undefined,
    targetEntity: "",
  };
}

export const TagDTO: MessageFns<TagDTO> = {
  encode(message: TagDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    if (message.subtype !== 0) {
      writer.uint32(40).int32(message.subtype);
    }
    if (message.user !== undefined) {
      writer.uint32(50).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(58).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(66).string(message.world);
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subtype = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      subtype: isSet(object.subtype) ? tagSubtypeEnumDTOFromJSON(object.subtype) : 0,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: TagDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.subtype !== 0) {
      obj.subtype = tagSubtypeEnumDTOToJSON(message.subtype);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagDTO>, I>>(base?: I): TagDTO {
    return TagDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagDTO>, I>>(object: I): TagDTO {
    const message = createBaseTagDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.label = object.label ?? "";
    message.subtype = object.subtype ?? 0;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseTagsDTO(): TagsDTO {
  return { arr: [] };
}

export const TagsDTO: MessageFns<TagsDTO> = {
  encode(message: TagsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      TagDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(TagDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => TagDTO.fromJSON(e)) : [] };
  },

  toJSON(message: TagsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => TagDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagsDTO>, I>>(base?: I): TagsDTO {
    return TagsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagsDTO>, I>>(object: I): TagsDTO {
    const message = createBaseTagsDTO();
    message.arr = object.arr?.map((e) => TagDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkillDTO(): SkillDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    description: "",
    category: 0,
    targetEntity: "",
  };
}

export const SkillDTO: MessageFns<SkillDTO> = {
  encode(message: SkillDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.category !== 0) {
      writer.uint32(80).int32(message.category);
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? skillCategoryEnumDTOFromJSON(object.category) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: SkillDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== 0) {
      obj.category = skillCategoryEnumDTOToJSON(message.category);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillDTO>, I>>(base?: I): SkillDTO {
    return SkillDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillDTO>, I>>(object: I): SkillDTO {
    const message = createBaseSkillDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? "";
    message.category = object.category ?? 0;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseSkillsDTO(): SkillsDTO {
  return { arr: [] };
}

export const SkillsDTO: MessageFns<SkillsDTO> = {
  encode(message: SkillsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      SkillDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(SkillDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => SkillDTO.fromJSON(e)) : [] };
  },

  toJSON(message: SkillsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => SkillDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillsDTO>, I>>(base?: I): SkillsDTO {
    return SkillsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillsDTO>, I>>(object: I): SkillsDTO {
    const message = createBaseSkillsDTO();
    message.arr = object.arr?.map((e) => SkillDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTraitDTO(): TraitDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    targetEntity: "",
    type: 0,
  };
}

export const TraitDTO: MessageFns<TraitDTO> = {
  encode(message: TraitDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraitDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraitDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraitDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      type: isSet(object.type) ? traitTypeEnumDTOFromJSON(object.type) : 0,
    };
  },

  toJSON(message: TraitDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.type !== 0) {
      obj.type = traitTypeEnumDTOToJSON(message.type);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraitDTO>, I>>(base?: I): TraitDTO {
    return TraitDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraitDTO>, I>>(object: I): TraitDTO {
    const message = createBaseTraitDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.targetEntity = object.targetEntity ?? "";
    message.type = object.type ?? 0;
    return message;
  },
};

function createBaseTraitsDTO(): TraitsDTO {
  return { arr: [] };
}

export const TraitsDTO: MessageFns<TraitsDTO> = {
  encode(message: TraitsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      TraitDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraitsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraitsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(TraitDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraitsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => TraitDTO.fromJSON(e)) : [] };
  },

  toJSON(message: TraitsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => TraitDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraitsDTO>, I>>(base?: I): TraitsDTO {
    return TraitsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraitsDTO>, I>>(object: I): TraitsDTO {
    const message = createBaseTraitsDTO();
    message.arr = object.arr?.map((e) => TraitDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDiseaseDTO(): DiseaseDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    description: "",
    severity: "",
    characters: [],
    targetEntity: "",
  };
}

export const DiseaseDTO: MessageFns<DiseaseDTO> = {
  encode(message: DiseaseDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.severity !== "") {
      writer.uint32(82).string(message.severity);
    }
    for (const v of message.characters) {
      writer.uint32(90).string(v!);
    }
    if (message.targetEntity !== "") {
      writer.uint32(98).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiseaseDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiseaseDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.characters.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiseaseDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => globalThis.String(e))
        : [],
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: DiseaseDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.characters?.length) {
      obj.characters = message.characters;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiseaseDTO>, I>>(base?: I): DiseaseDTO {
    return DiseaseDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiseaseDTO>, I>>(object: I): DiseaseDTO {
    const message = createBaseDiseaseDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? "";
    message.severity = object.severity ?? "";
    message.characters = object.characters?.map((e) => e) || [];
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseDiseasesDTO(): DiseasesDTO {
  return { arr: [] };
}

export const DiseasesDTO: MessageFns<DiseasesDTO> = {
  encode(message: DiseasesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      DiseaseDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiseasesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiseasesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(DiseaseDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiseasesDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => DiseaseDTO.fromJSON(e)) : [] };
  },

  toJSON(message: DiseasesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => DiseaseDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiseasesDTO>, I>>(base?: I): DiseasesDTO {
    return DiseasesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiseasesDTO>, I>>(object: I): DiseasesDTO {
    const message = createBaseDiseasesDTO();
    message.arr = object.arr?.map((e) => DiseaseDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFactDTO(): FactDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    description: "",
    weight: 0,
    targetEntity: "",
  };
}

export const FactDTO: MessageFns<FactDTO> = {
  encode(message: FactDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.weight !== 0) {
      writer.uint32(80).int32(message.weight);
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: FactDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactDTO>, I>>(base?: I): FactDTO {
    return FactDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactDTO>, I>>(object: I): FactDTO {
    const message = createBaseFactDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.description = object.description ?? "";
    message.weight = object.weight ?? 0;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseFactsDTO(): FactsDTO {
  return { arr: [] };
}

export const FactsDTO: MessageFns<FactsDTO> = {
  encode(message: FactsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      FactDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(FactDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => FactDTO.fromJSON(e)) : [] };
  },

  toJSON(message: FactsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => FactDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactsDTO>, I>>(base?: I): FactsDTO {
    return FactsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactsDTO>, I>>(object: I): FactsDTO {
    const message = createBaseFactsDTO();
    message.arr = object.arr?.map((e) => FactDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFactionDTO(): FactionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    targetEntity: "",
  };
}

export const FactionDTO: MessageFns<FactionDTO> = {
  encode(message: FactionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: FactionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactionDTO>, I>>(base?: I): FactionDTO {
    return FactionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactionDTO>, I>>(object: I): FactionDTO {
    const message = createBaseFactionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseFactionsDTO(): FactionsDTO {
  return { arr: [] };
}

export const FactionsDTO: MessageFns<FactionsDTO> = {
  encode(message: FactionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      FactionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(FactionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactionsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => FactionDTO.fromJSON(e)) : [] };
  },

  toJSON(message: FactionsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => FactionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactionsDTO>, I>>(base?: I): FactionsDTO {
    return FactionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactionsDTO>, I>>(object: I): FactionsDTO {
    const message = createBaseFactionsDTO();
    message.arr = object.arr?.map((e) => FactionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemoryPoolDTO(): MemoryPoolDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: undefined,
    memoryPoolEntries: [],
    tags: [],
    targetEntity: "",
  };
}

export const MemoryPoolDTO: MessageFns<MemoryPoolDTO> = {
  encode(message: MemoryPoolDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.description !== undefined) {
      writer.uint32(66).string(message.description);
    }
    for (const v of message.memoryPoolEntries) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.tags) {
      writer.uint32(82).string(v!);
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memoryPoolEntries.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      memoryPoolEntries: globalThis.Array.isArray(object?.memoryPoolEntries)
        ? object.memoryPoolEntries.map((e: any) => globalThis.String(e))
        : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: MemoryPoolDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.memoryPoolEntries?.length) {
      obj.memoryPoolEntries = message.memoryPoolEntries;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolDTO>, I>>(base?: I): MemoryPoolDTO {
    return MemoryPoolDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolDTO>, I>>(object: I): MemoryPoolDTO {
    const message = createBaseMemoryPoolDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.description = object.description ?? undefined;
    message.memoryPoolEntries = object.memoryPoolEntries?.map((e) => e) || [];
    message.tags = object.tags?.map((e) => e) || [];
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseMemoryPoolsDTO(): MemoryPoolsDTO {
  return { arr: [] };
}

export const MemoryPoolsDTO: MessageFns<MemoryPoolsDTO> = {
  encode(message: MemoryPoolsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      MemoryPoolDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(MemoryPoolDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => MemoryPoolDTO.fromJSON(e)) : [] };
  },

  toJSON(message: MemoryPoolsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => MemoryPoolDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolsDTO>, I>>(base?: I): MemoryPoolsDTO {
    return MemoryPoolsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolsDTO>, I>>(object: I): MemoryPoolsDTO {
    const message = createBaseMemoryPoolsDTO();
    message.arr = object.arr?.map((e) => MemoryPoolDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemoryPoolEntryDTO(): MemoryPoolEntryDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    memoryPool: undefined,
    memory: undefined,
    probability: 0,
    defaultClarity: 0,
    defaultImportance: 0,
    targetEntity: "",
  };
}

export const MemoryPoolEntryDTO: MessageFns<MemoryPoolEntryDTO> = {
  encode(message: MemoryPoolEntryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.memoryPool !== undefined) {
      writer.uint32(66).string(message.memoryPool);
    }
    if (message.memory !== undefined) {
      writer.uint32(74).string(message.memory);
    }
    if (message.probability !== 0) {
      writer.uint32(80).int32(message.probability);
    }
    if (message.defaultClarity !== 0) {
      writer.uint32(88).int32(message.defaultClarity);
    }
    if (message.defaultImportance !== 0) {
      writer.uint32(96).int32(message.defaultImportance);
    }
    if (message.targetEntity !== "") {
      writer.uint32(106).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolEntryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolEntryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.memoryPool = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memory = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.probability = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.defaultClarity = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.defaultImportance = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolEntryDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      memoryPool: isSet(object.memoryPool) ? globalThis.String(object.memoryPool) : undefined,
      memory: isSet(object.memory) ? globalThis.String(object.memory) : undefined,
      probability: isSet(object.probability) ? globalThis.Number(object.probability) : 0,
      defaultClarity: isSet(object.defaultClarity) ? globalThis.Number(object.defaultClarity) : 0,
      defaultImportance: isSet(object.defaultImportance) ? globalThis.Number(object.defaultImportance) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: MemoryPoolEntryDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.memoryPool !== undefined) {
      obj.memoryPool = message.memoryPool;
    }
    if (message.memory !== undefined) {
      obj.memory = message.memory;
    }
    if (message.probability !== 0) {
      obj.probability = Math.round(message.probability);
    }
    if (message.defaultClarity !== 0) {
      obj.defaultClarity = Math.round(message.defaultClarity);
    }
    if (message.defaultImportance !== 0) {
      obj.defaultImportance = Math.round(message.defaultImportance);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolEntryDTO>, I>>(base?: I): MemoryPoolEntryDTO {
    return MemoryPoolEntryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolEntryDTO>, I>>(object: I): MemoryPoolEntryDTO {
    const message = createBaseMemoryPoolEntryDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.memoryPool = object.memoryPool ?? undefined;
    message.memory = object.memory ?? undefined;
    message.probability = object.probability ?? 0;
    message.defaultClarity = object.defaultClarity ?? 0;
    message.defaultImportance = object.defaultImportance ?? 0;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseMemoryPoolEntriesDTO(): MemoryPoolEntriesDTO {
  return { arr: [] };
}

export const MemoryPoolEntriesDTO: MessageFns<MemoryPoolEntriesDTO> = {
  encode(message: MemoryPoolEntriesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      MemoryPoolEntryDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolEntriesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolEntriesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(MemoryPoolEntryDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolEntriesDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => MemoryPoolEntryDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: MemoryPoolEntriesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => MemoryPoolEntryDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolEntriesDTO>, I>>(base?: I): MemoryPoolEntriesDTO {
    return MemoryPoolEntriesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolEntriesDTO>, I>>(object: I): MemoryPoolEntriesDTO {
    const message = createBaseMemoryPoolEntriesDTO();
    message.arr = object.arr?.map((e) => MemoryPoolEntryDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterProfessionDTO(): CharacterProfessionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    memoryPools: [],
    targetEntity: "",
  };
}

export const CharacterProfessionDTO: MessageFns<CharacterProfessionDTO> = {
  encode(message: CharacterProfessionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    for (const v of message.memoryPools) {
      writer.uint32(74).string(v!);
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfessionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfessionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memoryPools.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfessionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      memoryPools: globalThis.Array.isArray(object?.memoryPools)
        ? object.memoryPools.map((e: any) => globalThis.String(e))
        : [],
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: CharacterProfessionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.memoryPools?.length) {
      obj.memoryPools = message.memoryPools;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfessionDTO>, I>>(base?: I): CharacterProfessionDTO {
    return CharacterProfessionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfessionDTO>, I>>(object: I): CharacterProfessionDTO {
    const message = createBaseCharacterProfessionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.memoryPools = object.memoryPools?.map((e) => e) || [];
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseCharacterProfessionsDTO(): CharacterProfessionsDTO {
  return { arr: [] };
}

export const CharacterProfessionsDTO: MessageFns<CharacterProfessionsDTO> = {
  encode(message: CharacterProfessionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      CharacterProfessionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfessionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfessionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(CharacterProfessionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfessionsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => CharacterProfessionDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: CharacterProfessionsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterProfessionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfessionsDTO>, I>>(base?: I): CharacterProfessionsDTO {
    return CharacterProfessionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfessionsDTO>, I>>(object: I): CharacterProfessionsDTO {
    const message = createBaseCharacterProfessionsDTO();
    message.arr = object.arr?.map((e) => CharacterProfessionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEquipmentSlotDTO(): EquipmentSlotDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    allowedEntities: [],
    equippedItem: undefined,
    character: undefined,
    targetEntity: "",
  };
}

export const EquipmentSlotDTO: MessageFns<EquipmentSlotDTO> = {
  encode(message: EquipmentSlotDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.allowedEntities) {
      writer.uint32(66).string(v!);
    }
    if (message.equippedItem !== undefined) {
      ItemDTO.encode(message.equippedItem, writer.uint32(74).fork()).join();
    }
    if (message.character !== undefined) {
      writer.uint32(82).string(message.character);
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlotDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlotDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.allowedEntities.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.equippedItem = ItemDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.character = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlotDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      allowedEntities: globalThis.Array.isArray(object?.allowedEntities)
        ? object.allowedEntities.map((e: any) => globalThis.String(e))
        : [],
      equippedItem: isSet(object.equippedItem) ? ItemDTO.fromJSON(object.equippedItem) : undefined,
      character: isSet(object.character) ? globalThis.String(object.character) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: EquipmentSlotDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.allowedEntities?.length) {
      obj.allowedEntities = message.allowedEntities;
    }
    if (message.equippedItem !== undefined) {
      obj.equippedItem = ItemDTO.toJSON(message.equippedItem);
    }
    if (message.character !== undefined) {
      obj.character = message.character;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlotDTO>, I>>(base?: I): EquipmentSlotDTO {
    return EquipmentSlotDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlotDTO>, I>>(object: I): EquipmentSlotDTO {
    const message = createBaseEquipmentSlotDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.allowedEntities = object.allowedEntities?.map((e) => e) || [];
    message.equippedItem = (object.equippedItem !== undefined && object.equippedItem !== null)
      ? ItemDTO.fromPartial(object.equippedItem)
      : undefined;
    message.character = object.character ?? undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseEquipmentSlotsDTO(): EquipmentSlotsDTO {
  return { arr: [] };
}

export const EquipmentSlotsDTO: MessageFns<EquipmentSlotsDTO> = {
  encode(message: EquipmentSlotsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      EquipmentSlotDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlotsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlotsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(EquipmentSlotDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlotsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => EquipmentSlotDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: EquipmentSlotsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => EquipmentSlotDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlotsDTO>, I>>(base?: I): EquipmentSlotsDTO {
    return EquipmentSlotsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlotsDTO>, I>>(object: I): EquipmentSlotsDTO {
    const message = createBaseEquipmentSlotsDTO();
    message.arr = object.arr?.map((e) => EquipmentSlotDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBirthsignDTO(): BirthsignDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    targetEntity: "",
  };
}

export const BirthsignDTO: MessageFns<BirthsignDTO> = {
  encode(message: BirthsignDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.targetEntity !== "") {
      writer.uint32(66).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BirthsignDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBirthsignDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BirthsignDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: BirthsignDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BirthsignDTO>, I>>(base?: I): BirthsignDTO {
    return BirthsignDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BirthsignDTO>, I>>(object: I): BirthsignDTO {
    const message = createBaseBirthsignDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseBirthsignsDTO(): BirthsignsDTO {
  return { arr: [] };
}

export const BirthsignsDTO: MessageFns<BirthsignsDTO> = {
  encode(message: BirthsignsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      BirthsignDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BirthsignsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBirthsignsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(BirthsignDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BirthsignsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => BirthsignDTO.fromJSON(e)) : [] };
  },

  toJSON(message: BirthsignsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => BirthsignDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BirthsignsDTO>, I>>(base?: I): BirthsignsDTO {
    return BirthsignsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BirthsignsDTO>, I>>(object: I): BirthsignsDTO {
    const message = createBaseBirthsignsDTO();
    message.arr = object.arr?.map((e) => BirthsignDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRaceDTO(): RaceDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    equipmentSlotDefinitions: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    metadata: undefined,
    targetEntity: "",
  };
}

export const RaceDTO: MessageFns<RaceDTO> = {
  encode(message: RaceDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.equipmentSlotDefinitions !== undefined) {
      EquipmentSlotDefinitionsDTO.encode(message.equipmentSlotDefinitions, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RaceDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaceDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.equipmentSlotDefinitions = EquipmentSlotDefinitionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaceDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      equipmentSlotDefinitions: isSet(object.equipmentSlotDefinitions)
        ? EquipmentSlotDefinitionsDTO.fromJSON(object.equipmentSlotDefinitions)
        : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: RaceDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.equipmentSlotDefinitions !== undefined) {
      obj.equipmentSlotDefinitions = EquipmentSlotDefinitionsDTO.toJSON(message.equipmentSlotDefinitions);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RaceDTO>, I>>(base?: I): RaceDTO {
    return RaceDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RaceDTO>, I>>(object: I): RaceDTO {
    const message = createBaseRaceDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.equipmentSlotDefinitions =
      (object.equipmentSlotDefinitions !== undefined && object.equipmentSlotDefinitions !== null)
        ? EquipmentSlotDefinitionsDTO.fromPartial(object.equipmentSlotDefinitions)
        : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseRacesDTO(): RacesDTO {
  return { arr: [] };
}

export const RacesDTO: MessageFns<RacesDTO> = {
  encode(message: RacesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      RaceDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RacesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRacesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(RaceDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RacesDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => RaceDTO.fromJSON(e)) : [] };
  },

  toJSON(message: RacesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => RaceDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RacesDTO>, I>>(base?: I): RacesDTO {
    return RacesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RacesDTO>, I>>(object: I): RacesDTO {
    const message = createBaseRacesDTO();
    message.arr = object.arr?.map((e) => RaceDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEquipmentSlotDefinitionDTO(): EquipmentSlotDefinitionDTO {
  return { name: "", allowedEntities: [] };
}

export const EquipmentSlotDefinitionDTO: MessageFns<EquipmentSlotDefinitionDTO> = {
  encode(message: EquipmentSlotDefinitionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.allowedEntities) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlotDefinitionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlotDefinitionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowedEntities.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlotDefinitionDTO {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      allowedEntities: globalThis.Array.isArray(object?.allowedEntities)
        ? object.allowedEntities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EquipmentSlotDefinitionDTO): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.allowedEntities?.length) {
      obj.allowedEntities = message.allowedEntities;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlotDefinitionDTO>, I>>(base?: I): EquipmentSlotDefinitionDTO {
    return EquipmentSlotDefinitionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlotDefinitionDTO>, I>>(object: I): EquipmentSlotDefinitionDTO {
    const message = createBaseEquipmentSlotDefinitionDTO();
    message.name = object.name ?? "";
    message.allowedEntities = object.allowedEntities?.map((e) => e) || [];
    return message;
  },
};

function createBaseEquipmentSlotDefinitionsDTO(): EquipmentSlotDefinitionsDTO {
  return { arr: [] };
}

export const EquipmentSlotDefinitionsDTO: MessageFns<EquipmentSlotDefinitionsDTO> = {
  encode(message: EquipmentSlotDefinitionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      EquipmentSlotDefinitionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlotDefinitionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlotDefinitionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(EquipmentSlotDefinitionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlotDefinitionsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr)
        ? object.arr.map((e: any) => EquipmentSlotDefinitionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EquipmentSlotDefinitionsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => EquipmentSlotDefinitionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlotDefinitionsDTO>, I>>(base?: I): EquipmentSlotDefinitionsDTO {
    return EquipmentSlotDefinitionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlotDefinitionsDTO>, I>>(object: I): EquipmentSlotDefinitionsDTO {
    const message = createBaseEquipmentSlotDefinitionsDTO();
    message.arr = object.arr?.map((e) => EquipmentSlotDefinitionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorageSlotDefinitionDTO(): StorageSlotDefinitionDTO {
  return { grid: [], name: "", maxWeight: 0 };
}

export const StorageSlotDefinitionDTO: MessageFns<StorageSlotDefinitionDTO> = {
  encode(message: StorageSlotDefinitionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.grid) {
      writer.int32(v);
    }
    writer.join();
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.maxWeight !== 0) {
      writer.uint32(24).int32(message.maxWeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlotDefinitionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlotDefinitionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.grid.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.grid.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxWeight = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlotDefinitionDTO {
    return {
      grid: globalThis.Array.isArray(object?.grid) ? object.grid.map((e: any) => globalThis.Number(e)) : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      maxWeight: isSet(object.maxWeight) ? globalThis.Number(object.maxWeight) : 0,
    };
  },

  toJSON(message: StorageSlotDefinitionDTO): unknown {
    const obj: any = {};
    if (message.grid?.length) {
      obj.grid = message.grid.map((e) => Math.round(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.maxWeight !== 0) {
      obj.maxWeight = Math.round(message.maxWeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlotDefinitionDTO>, I>>(base?: I): StorageSlotDefinitionDTO {
    return StorageSlotDefinitionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlotDefinitionDTO>, I>>(object: I): StorageSlotDefinitionDTO {
    const message = createBaseStorageSlotDefinitionDTO();
    message.grid = object.grid?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.maxWeight = object.maxWeight ?? 0;
    return message;
  },
};

function createBaseStorageSlotDefinitionsDTO(): StorageSlotDefinitionsDTO {
  return { arr: [] };
}

export const StorageSlotDefinitionsDTO: MessageFns<StorageSlotDefinitionsDTO> = {
  encode(message: StorageSlotDefinitionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      StorageSlotDefinitionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlotDefinitionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlotDefinitionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(StorageSlotDefinitionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlotDefinitionsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr)
        ? object.arr.map((e: any) => StorageSlotDefinitionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StorageSlotDefinitionsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => StorageSlotDefinitionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlotDefinitionsDTO>, I>>(base?: I): StorageSlotDefinitionsDTO {
    return StorageSlotDefinitionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlotDefinitionsDTO>, I>>(object: I): StorageSlotDefinitionsDTO {
    const message = createBaseStorageSlotDefinitionsDTO();
    message.arr = object.arr?.map((e) => StorageSlotDefinitionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMoodDTO(): MoodDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
    targetEntity: "",
  };
}

export const MoodDTO: MessageFns<MoodDTO> = {
  encode(message: MoodDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoodDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoodDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoodDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: MoodDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoodDTO>, I>>(base?: I): MoodDTO {
    return MoodDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoodDTO>, I>>(object: I): MoodDTO {
    const message = createBaseMoodDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.description = object.description ?? "";
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseMoodsDTO(): MoodsDTO {
  return { arr: [] };
}

export const MoodsDTO: MessageFns<MoodsDTO> = {
  encode(message: MoodsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      MoodDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoodsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoodsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(MoodDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoodsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => MoodDTO.fromJSON(e)) : [] };
  },

  toJSON(message: MoodsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => MoodDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoodsDTO>, I>>(base?: I): MoodsDTO {
    return MoodsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoodsDTO>, I>>(object: I): MoodsDTO {
    const message = createBaseMoodsDTO();
    message.arr = object.arr?.map((e) => MoodDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReligionDTO(): ReligionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
    rituals: undefined,
    tenets: undefined,
    targetEntity: "",
  };
}

export const ReligionDTO: MessageFns<ReligionDTO> = {
  encode(message: ReligionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.rituals !== undefined) {
      ReligionRitualsDTO.encode(message.rituals, writer.uint32(74).fork()).join();
    }
    if (message.tenets !== undefined) {
      ReligionTenetsDTO.encode(message.tenets, writer.uint32(82).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rituals = ReligionRitualsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tenets = ReligionTenetsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      rituals: isSet(object.rituals) ? ReligionRitualsDTO.fromJSON(object.rituals) : undefined,
      tenets: isSet(object.tenets) ? ReligionTenetsDTO.fromJSON(object.tenets) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: ReligionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.rituals !== undefined) {
      obj.rituals = ReligionRitualsDTO.toJSON(message.rituals);
    }
    if (message.tenets !== undefined) {
      obj.tenets = ReligionTenetsDTO.toJSON(message.tenets);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionDTO>, I>>(base?: I): ReligionDTO {
    return ReligionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionDTO>, I>>(object: I): ReligionDTO {
    const message = createBaseReligionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.description = object.description ?? "";
    message.rituals = (object.rituals !== undefined && object.rituals !== null)
      ? ReligionRitualsDTO.fromPartial(object.rituals)
      : undefined;
    message.tenets = (object.tenets !== undefined && object.tenets !== null)
      ? ReligionTenetsDTO.fromPartial(object.tenets)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseReligionsDTO(): ReligionsDTO {
  return { arr: [] };
}

export const ReligionsDTO: MessageFns<ReligionsDTO> = {
  encode(message: ReligionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      ReligionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(ReligionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => ReligionDTO.fromJSON(e)) : [] };
  },

  toJSON(message: ReligionsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => ReligionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionsDTO>, I>>(base?: I): ReligionsDTO {
    return ReligionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionsDTO>, I>>(object: I): ReligionsDTO {
    const message = createBaseReligionsDTO();
    message.arr = object.arr?.map((e) => ReligionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReligionRitualDTO(): ReligionRitualDTO {
  return { name: "", description: "" };
}

export const ReligionRitualDTO: MessageFns<ReligionRitualDTO> = {
  encode(message: ReligionRitualDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionRitualDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionRitualDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionRitualDTO {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ReligionRitualDTO): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionRitualDTO>, I>>(base?: I): ReligionRitualDTO {
    return ReligionRitualDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionRitualDTO>, I>>(object: I): ReligionRitualDTO {
    const message = createBaseReligionRitualDTO();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseReligionRitualsDTO(): ReligionRitualsDTO {
  return { arr: [] };
}

export const ReligionRitualsDTO: MessageFns<ReligionRitualsDTO> = {
  encode(message: ReligionRitualsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      ReligionRitualDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionRitualsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionRitualsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(ReligionRitualDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionRitualsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => ReligionRitualDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReligionRitualsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => ReligionRitualDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionRitualsDTO>, I>>(base?: I): ReligionRitualsDTO {
    return ReligionRitualsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionRitualsDTO>, I>>(object: I): ReligionRitualsDTO {
    const message = createBaseReligionRitualsDTO();
    message.arr = object.arr?.map((e) => ReligionRitualDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReligionTenetDTO(): ReligionTenetDTO {
  return { name: "", description: "" };
}

export const ReligionTenetDTO: MessageFns<ReligionTenetDTO> = {
  encode(message: ReligionTenetDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionTenetDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionTenetDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionTenetDTO {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ReligionTenetDTO): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionTenetDTO>, I>>(base?: I): ReligionTenetDTO {
    return ReligionTenetDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionTenetDTO>, I>>(object: I): ReligionTenetDTO {
    const message = createBaseReligionTenetDTO();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseReligionTenetsDTO(): ReligionTenetsDTO {
  return { arr: [] };
}

export const ReligionTenetsDTO: MessageFns<ReligionTenetsDTO> = {
  encode(message: ReligionTenetsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      ReligionTenetDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionTenetsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionTenetsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(ReligionTenetDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionTenetsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => ReligionTenetDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReligionTenetsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => ReligionTenetDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionTenetsDTO>, I>>(base?: I): ReligionTenetsDTO {
    return ReligionTenetsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionTenetsDTO>, I>>(object: I): ReligionTenetsDTO {
    const message = createBaseReligionTenetsDTO();
    message.arr = object.arr?.map((e) => ReligionTenetDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGridPositionDTO(): GridPositionDTO {
  return { x: 0, y: 0 };
}

export const GridPositionDTO: MessageFns<GridPositionDTO> = {
  encode(message: GridPositionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GridPositionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGridPositionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GridPositionDTO {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: GridPositionDTO): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GridPositionDTO>, I>>(base?: I): GridPositionDTO {
    return GridPositionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GridPositionDTO>, I>>(object: I): GridPositionDTO {
    const message = createBaseGridPositionDTO();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseGenerationInstructionDTO(): GenerationInstructionDTO {
  return {
    blueprintId: undefined,
    idAndQuant: undefined,
    simpleProb: undefined,
    gaussianProb: undefined,
    combinator: undefined,
  };
}

export const GenerationInstructionDTO: MessageFns<GenerationInstructionDTO> = {
  encode(message: GenerationInstructionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== undefined) {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.idAndQuant !== undefined) {
      IdAndQuantDTO.encode(message.idAndQuant, writer.uint32(18).fork()).join();
    }
    if (message.simpleProb !== undefined) {
      SimpleProbDTO.encode(message.simpleProb, writer.uint32(26).fork()).join();
    }
    if (message.gaussianProb !== undefined) {
      GaussianProbDTO.encode(message.gaussianProb, writer.uint32(34).fork()).join();
    }
    if (message.combinator !== undefined) {
      CombinatorDTO.encode(message.combinator, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationInstructionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationInstructionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idAndQuant = IdAndQuantDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.simpleProb = SimpleProbDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gaussianProb = GaussianProbDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.combinator = CombinatorDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationInstructionDTO {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : undefined,
      idAndQuant: isSet(object.idAndQuant) ? IdAndQuantDTO.fromJSON(object.idAndQuant) : undefined,
      simpleProb: isSet(object.simpleProb) ? SimpleProbDTO.fromJSON(object.simpleProb) : undefined,
      gaussianProb: isSet(object.gaussianProb) ? GaussianProbDTO.fromJSON(object.gaussianProb) : undefined,
      combinator: isSet(object.combinator) ? CombinatorDTO.fromJSON(object.combinator) : undefined,
    };
  },

  toJSON(message: GenerationInstructionDTO): unknown {
    const obj: any = {};
    if (message.blueprintId !== undefined) {
      obj.blueprintId = message.blueprintId;
    }
    if (message.idAndQuant !== undefined) {
      obj.idAndQuant = IdAndQuantDTO.toJSON(message.idAndQuant);
    }
    if (message.simpleProb !== undefined) {
      obj.simpleProb = SimpleProbDTO.toJSON(message.simpleProb);
    }
    if (message.gaussianProb !== undefined) {
      obj.gaussianProb = GaussianProbDTO.toJSON(message.gaussianProb);
    }
    if (message.combinator !== undefined) {
      obj.combinator = CombinatorDTO.toJSON(message.combinator);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerationInstructionDTO>, I>>(base?: I): GenerationInstructionDTO {
    return GenerationInstructionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerationInstructionDTO>, I>>(object: I): GenerationInstructionDTO {
    const message = createBaseGenerationInstructionDTO();
    message.blueprintId = object.blueprintId ?? undefined;
    message.idAndQuant = (object.idAndQuant !== undefined && object.idAndQuant !== null)
      ? IdAndQuantDTO.fromPartial(object.idAndQuant)
      : undefined;
    message.simpleProb = (object.simpleProb !== undefined && object.simpleProb !== null)
      ? SimpleProbDTO.fromPartial(object.simpleProb)
      : undefined;
    message.gaussianProb = (object.gaussianProb !== undefined && object.gaussianProb !== null)
      ? GaussianProbDTO.fromPartial(object.gaussianProb)
      : undefined;
    message.combinator = (object.combinator !== undefined && object.combinator !== null)
      ? CombinatorDTO.fromPartial(object.combinator)
      : undefined;
    return message;
  },
};

function createBaseGenerationInstructionsDTO(): GenerationInstructionsDTO {
  return { arr: [] };
}

export const GenerationInstructionsDTO: MessageFns<GenerationInstructionsDTO> = {
  encode(message: GenerationInstructionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      GenerationInstructionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationInstructionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationInstructionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(GenerationInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationInstructionsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr)
        ? object.arr.map((e: any) => GenerationInstructionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerationInstructionsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => GenerationInstructionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerationInstructionsDTO>, I>>(base?: I): GenerationInstructionsDTO {
    return GenerationInstructionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerationInstructionsDTO>, I>>(object: I): GenerationInstructionsDTO {
    const message = createBaseGenerationInstructionsDTO();
    message.arr = object.arr?.map((e) => GenerationInstructionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIdAndQuantDTO(): IdAndQuantDTO {
  return { blueprintId: "", quantity: undefined };
}

export const IdAndQuantDTO: MessageFns<IdAndQuantDTO> = {
  encode(message: IdAndQuantDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.quantity !== undefined) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdAndQuantDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdAndQuantDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdAndQuantDTO {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : undefined,
    };
  },

  toJSON(message: IdAndQuantDTO): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.quantity !== undefined) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdAndQuantDTO>, I>>(base?: I): IdAndQuantDTO {
    return IdAndQuantDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdAndQuantDTO>, I>>(object: I): IdAndQuantDTO {
    const message = createBaseIdAndQuantDTO();
    message.blueprintId = object.blueprintId ?? "";
    message.quantity = object.quantity ?? undefined;
    return message;
  },
};

function createBaseIdsAndQuantsDTO(): IdsAndQuantsDTO {
  return { arr: [] };
}

export const IdsAndQuantsDTO: MessageFns<IdsAndQuantsDTO> = {
  encode(message: IdsAndQuantsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      IdAndQuantDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdsAndQuantsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdsAndQuantsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(IdAndQuantDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdsAndQuantsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => IdAndQuantDTO.fromJSON(e)) : [] };
  },

  toJSON(message: IdsAndQuantsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => IdAndQuantDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdsAndQuantsDTO>, I>>(base?: I): IdsAndQuantsDTO {
    return IdsAndQuantsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdsAndQuantsDTO>, I>>(object: I): IdsAndQuantsDTO {
    const message = createBaseIdsAndQuantsDTO();
    message.arr = object.arr?.map((e) => IdAndQuantDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterGenInstructionDTO(): CharacterGenInstructionDTO {
  return {
    blueprintId: "",
    backgroundBlueprintId: "",
    targetEntity: "",
    firstName: undefined,
    lastName: undefined,
    gender: undefined,
    birthEra: undefined,
    birthYear: undefined,
    birthMonth: undefined,
    birthDay: undefined,
    backgroundCustomization: undefined,
    birthSign: undefined,
    id: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
  };
}

export const CharacterGenInstructionDTO: MessageFns<CharacterGenInstructionDTO> = {
  encode(message: CharacterGenInstructionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.backgroundBlueprintId !== "") {
      writer.uint32(18).string(message.backgroundBlueprintId);
    }
    if (message.targetEntity !== "") {
      writer.uint32(26).string(message.targetEntity);
    }
    if (message.firstName !== undefined) {
      writer.uint32(34).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(42).string(message.lastName);
    }
    if (message.gender !== undefined) {
      writer.uint32(48).int32(message.gender);
    }
    if (message.birthEra !== undefined) {
      writer.uint32(58).string(message.birthEra);
    }
    if (message.birthYear !== undefined) {
      writer.uint32(64).int32(message.birthYear);
    }
    if (message.birthMonth !== undefined) {
      writer.uint32(74).string(message.birthMonth);
    }
    if (message.birthDay !== undefined) {
      writer.uint32(80).int32(message.birthDay);
    }
    if (message.backgroundCustomization !== undefined) {
      BackgroundCustomizationDTO.encode(message.backgroundCustomization, writer.uint32(90).fork()).join();
    }
    if (message.birthSign !== undefined) {
      writer.uint32(98).string(message.birthSign);
    }
    if (message.id !== "") {
      writer.uint32(106).string(message.id);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(114).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(122).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(130).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(138).string(message.world);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGenInstructionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGenInstructionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.backgroundBlueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.gender = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.birthEra = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.birthYear = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.birthMonth = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.birthDay = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.backgroundCustomization = BackgroundCustomizationDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.birthSign = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.world = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGenInstructionDTO {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      backgroundBlueprintId: isSet(object.backgroundBlueprintId) ? globalThis.String(object.backgroundBlueprintId) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
      gender: isSet(object.gender) ? genderEnumDTOFromJSON(object.gender) : undefined,
      birthEra: isSet(object.birthEra) ? globalThis.String(object.birthEra) : undefined,
      birthYear: isSet(object.birthYear) ? globalThis.Number(object.birthYear) : undefined,
      birthMonth: isSet(object.birthMonth) ? globalThis.String(object.birthMonth) : undefined,
      birthDay: isSet(object.birthDay) ? globalThis.Number(object.birthDay) : undefined,
      backgroundCustomization: isSet(object.backgroundCustomization)
        ? BackgroundCustomizationDTO.fromJSON(object.backgroundCustomization)
        : undefined,
      birthSign: isSet(object.birthSign) ? globalThis.String(object.birthSign) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
    };
  },

  toJSON(message: CharacterGenInstructionDTO): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.backgroundBlueprintId !== "") {
      obj.backgroundBlueprintId = message.backgroundBlueprintId;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    if (message.gender !== undefined) {
      obj.gender = genderEnumDTOToJSON(message.gender);
    }
    if (message.birthEra !== undefined) {
      obj.birthEra = message.birthEra;
    }
    if (message.birthYear !== undefined) {
      obj.birthYear = Math.round(message.birthYear);
    }
    if (message.birthMonth !== undefined) {
      obj.birthMonth = message.birthMonth;
    }
    if (message.birthDay !== undefined) {
      obj.birthDay = Math.round(message.birthDay);
    }
    if (message.backgroundCustomization !== undefined) {
      obj.backgroundCustomization = BackgroundCustomizationDTO.toJSON(message.backgroundCustomization);
    }
    if (message.birthSign !== undefined) {
      obj.birthSign = message.birthSign;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGenInstructionDTO>, I>>(base?: I): CharacterGenInstructionDTO {
    return CharacterGenInstructionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGenInstructionDTO>, I>>(object: I): CharacterGenInstructionDTO {
    const message = createBaseCharacterGenInstructionDTO();
    message.blueprintId = object.blueprintId ?? "";
    message.backgroundBlueprintId = object.backgroundBlueprintId ?? "";
    message.targetEntity = object.targetEntity ?? "";
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    message.gender = object.gender ?? undefined;
    message.birthEra = object.birthEra ?? undefined;
    message.birthYear = object.birthYear ?? undefined;
    message.birthMonth = object.birthMonth ?? undefined;
    message.birthDay = object.birthDay ?? undefined;
    message.backgroundCustomization =
      (object.backgroundCustomization !== undefined && object.backgroundCustomization !== null)
        ? BackgroundCustomizationDTO.fromPartial(object.backgroundCustomization)
        : undefined;
    message.birthSign = object.birthSign ?? undefined;
    message.id = object.id ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    return message;
  },
};

function createBaseCharacterGenInstructions(): CharacterGenInstructions {
  return { arr: [] };
}

export const CharacterGenInstructions: MessageFns<CharacterGenInstructions> = {
  encode(message: CharacterGenInstructions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      CharacterGenInstructionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGenInstructions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGenInstructions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(CharacterGenInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGenInstructions {
    return {
      arr: globalThis.Array.isArray(object?.arr)
        ? object.arr.map((e: any) => CharacterGenInstructionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterGenInstructions): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterGenInstructionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGenInstructions>, I>>(base?: I): CharacterGenInstructions {
    return CharacterGenInstructions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGenInstructions>, I>>(object: I): CharacterGenInstructions {
    const message = createBaseCharacterGenInstructions();
    message.arr = object.arr?.map((e) => CharacterGenInstructionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterGroupGenInstructionDTO(): CharacterGroupGenInstructionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    set: undefined,
    targetEntity: "",
  };
}

export const CharacterGroupGenInstructionDTO: MessageFns<CharacterGroupGenInstructionDTO> = {
  encode(message: CharacterGroupGenInstructionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.set !== undefined) {
      CombinatorDTO.encode(message.set, writer.uint32(66).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGroupGenInstructionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGroupGenInstructionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.set = CombinatorDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGroupGenInstructionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      set: isSet(object.set) ? CombinatorDTO.fromJSON(object.set) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: CharacterGroupGenInstructionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.set !== undefined) {
      obj.set = CombinatorDTO.toJSON(message.set);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGroupGenInstructionDTO>, I>>(base?: I): CharacterGroupGenInstructionDTO {
    return CharacterGroupGenInstructionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGroupGenInstructionDTO>, I>>(
    object: I,
  ): CharacterGroupGenInstructionDTO {
    const message = createBaseCharacterGroupGenInstructionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.set = (object.set !== undefined && object.set !== null) ? CombinatorDTO.fromPartial(object.set) : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseCharacterGroupGenInstructionsDTO(): CharacterGroupGenInstructionsDTO {
  return { arr: [] };
}

export const CharacterGroupGenInstructionsDTO: MessageFns<CharacterGroupGenInstructionsDTO> = {
  encode(message: CharacterGroupGenInstructionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      CharacterGroupGenInstructionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGroupGenInstructionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGroupGenInstructionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(CharacterGroupGenInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGroupGenInstructionsDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr)
        ? object.arr.map((e: any) => CharacterGroupGenInstructionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterGroupGenInstructionsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CharacterGroupGenInstructionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGroupGenInstructionsDTO>, I>>(
    base?: I,
  ): CharacterGroupGenInstructionsDTO {
    return CharacterGroupGenInstructionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGroupGenInstructionsDTO>, I>>(
    object: I,
  ): CharacterGroupGenInstructionsDTO {
    const message = createBaseCharacterGroupGenInstructionsDTO();
    message.arr = object.arr?.map((e) => CharacterGroupGenInstructionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBackgroundCustomizationDTO(): BackgroundCustomizationDTO {
  return {
    race: undefined,
    faction: undefined,
    disease: undefined,
    addiction: undefined,
    profession: undefined,
    religion: undefined,
    itemSets: undefined,
    items: undefined,
    pastExpChild: undefined,
    pastExpAdult: undefined,
    skillSets: undefined,
    skillAdjustments: undefined,
    personality: undefined,
    gender: undefined,
  };
}

export const BackgroundCustomizationDTO: MessageFns<BackgroundCustomizationDTO> = {
  encode(message: BackgroundCustomizationDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.race !== undefined) {
      GenerationInstructionsDTO.encode(message.race, writer.uint32(10).fork()).join();
    }
    if (message.faction !== undefined) {
      GenerationInstructionsDTO.encode(message.faction, writer.uint32(18).fork()).join();
    }
    if (message.disease !== undefined) {
      GenerationInstructionsDTO.encode(message.disease, writer.uint32(26).fork()).join();
    }
    if (message.addiction !== undefined) {
      GenerationInstructionsDTO.encode(message.addiction, writer.uint32(34).fork()).join();
    }
    if (message.profession !== undefined) {
      GenerationInstructionsDTO.encode(message.profession, writer.uint32(42).fork()).join();
    }
    if (message.religion !== undefined) {
      GenerationInstructionsDTO.encode(message.religion, writer.uint32(50).fork()).join();
    }
    if (message.itemSets !== undefined) {
      GenerationInstructionsDTO.encode(message.itemSets, writer.uint32(58).fork()).join();
    }
    if (message.items !== undefined) {
      GenerationInstructionsDTO.encode(message.items, writer.uint32(66).fork()).join();
    }
    if (message.pastExpChild !== undefined) {
      GenerationInstructionsDTO.encode(message.pastExpChild, writer.uint32(74).fork()).join();
    }
    if (message.pastExpAdult !== undefined) {
      GenerationInstructionsDTO.encode(message.pastExpAdult, writer.uint32(82).fork()).join();
    }
    if (message.skillSets !== undefined) {
      GenerationInstructionsDTO.encode(message.skillSets, writer.uint32(90).fork()).join();
    }
    if (message.skillAdjustments !== undefined) {
      SkillAdjustmentsDTO.encode(message.skillAdjustments, writer.uint32(98).fork()).join();
    }
    if (message.personality !== undefined) {
      GenerationInstructionsDTO.encode(message.personality, writer.uint32(106).fork()).join();
    }
    if (message.gender !== undefined) {
      GenerationInstructionDTO.encode(message.gender, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundCustomizationDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundCustomizationDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.race = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.faction = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.disease = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.addiction = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.profession = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.religion = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.itemSets = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.items = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pastExpChild = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.pastExpAdult = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.skillSets = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.skillAdjustments = SkillAdjustmentsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.personality = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.gender = GenerationInstructionDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundCustomizationDTO {
    return {
      race: isSet(object.race) ? GenerationInstructionsDTO.fromJSON(object.race) : undefined,
      faction: isSet(object.faction) ? GenerationInstructionsDTO.fromJSON(object.faction) : undefined,
      disease: isSet(object.disease) ? GenerationInstructionsDTO.fromJSON(object.disease) : undefined,
      addiction: isSet(object.addiction) ? GenerationInstructionsDTO.fromJSON(object.addiction) : undefined,
      profession: isSet(object.profession) ? GenerationInstructionsDTO.fromJSON(object.profession) : undefined,
      religion: isSet(object.religion) ? GenerationInstructionsDTO.fromJSON(object.religion) : undefined,
      itemSets: isSet(object.itemSets) ? GenerationInstructionsDTO.fromJSON(object.itemSets) : undefined,
      items: isSet(object.items) ? GenerationInstructionsDTO.fromJSON(object.items) : undefined,
      pastExpChild: isSet(object.pastExpChild) ? GenerationInstructionsDTO.fromJSON(object.pastExpChild) : undefined,
      pastExpAdult: isSet(object.pastExpAdult) ? GenerationInstructionsDTO.fromJSON(object.pastExpAdult) : undefined,
      skillSets: isSet(object.skillSets) ? GenerationInstructionsDTO.fromJSON(object.skillSets) : undefined,
      skillAdjustments: isSet(object.skillAdjustments)
        ? SkillAdjustmentsDTO.fromJSON(object.skillAdjustments)
        : undefined,
      personality: isSet(object.personality) ? GenerationInstructionsDTO.fromJSON(object.personality) : undefined,
      gender: isSet(object.gender) ? GenerationInstructionDTO.fromJSON(object.gender) : undefined,
    };
  },

  toJSON(message: BackgroundCustomizationDTO): unknown {
    const obj: any = {};
    if (message.race !== undefined) {
      obj.race = GenerationInstructionsDTO.toJSON(message.race);
    }
    if (message.faction !== undefined) {
      obj.faction = GenerationInstructionsDTO.toJSON(message.faction);
    }
    if (message.disease !== undefined) {
      obj.disease = GenerationInstructionsDTO.toJSON(message.disease);
    }
    if (message.addiction !== undefined) {
      obj.addiction = GenerationInstructionsDTO.toJSON(message.addiction);
    }
    if (message.profession !== undefined) {
      obj.profession = GenerationInstructionsDTO.toJSON(message.profession);
    }
    if (message.religion !== undefined) {
      obj.religion = GenerationInstructionsDTO.toJSON(message.religion);
    }
    if (message.itemSets !== undefined) {
      obj.itemSets = GenerationInstructionsDTO.toJSON(message.itemSets);
    }
    if (message.items !== undefined) {
      obj.items = GenerationInstructionsDTO.toJSON(message.items);
    }
    if (message.pastExpChild !== undefined) {
      obj.pastExpChild = GenerationInstructionsDTO.toJSON(message.pastExpChild);
    }
    if (message.pastExpAdult !== undefined) {
      obj.pastExpAdult = GenerationInstructionsDTO.toJSON(message.pastExpAdult);
    }
    if (message.skillSets !== undefined) {
      obj.skillSets = GenerationInstructionsDTO.toJSON(message.skillSets);
    }
    if (message.skillAdjustments !== undefined) {
      obj.skillAdjustments = SkillAdjustmentsDTO.toJSON(message.skillAdjustments);
    }
    if (message.personality !== undefined) {
      obj.personality = GenerationInstructionsDTO.toJSON(message.personality);
    }
    if (message.gender !== undefined) {
      obj.gender = GenerationInstructionDTO.toJSON(message.gender);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundCustomizationDTO>, I>>(base?: I): BackgroundCustomizationDTO {
    return BackgroundCustomizationDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundCustomizationDTO>, I>>(object: I): BackgroundCustomizationDTO {
    const message = createBaseBackgroundCustomizationDTO();
    message.race = (object.race !== undefined && object.race !== null)
      ? GenerationInstructionsDTO.fromPartial(object.race)
      : undefined;
    message.faction = (object.faction !== undefined && object.faction !== null)
      ? GenerationInstructionsDTO.fromPartial(object.faction)
      : undefined;
    message.disease = (object.disease !== undefined && object.disease !== null)
      ? GenerationInstructionsDTO.fromPartial(object.disease)
      : undefined;
    message.addiction = (object.addiction !== undefined && object.addiction !== null)
      ? GenerationInstructionsDTO.fromPartial(object.addiction)
      : undefined;
    message.profession = (object.profession !== undefined && object.profession !== null)
      ? GenerationInstructionsDTO.fromPartial(object.profession)
      : undefined;
    message.religion = (object.religion !== undefined && object.religion !== null)
      ? GenerationInstructionsDTO.fromPartial(object.religion)
      : undefined;
    message.itemSets = (object.itemSets !== undefined && object.itemSets !== null)
      ? GenerationInstructionsDTO.fromPartial(object.itemSets)
      : undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? GenerationInstructionsDTO.fromPartial(object.items)
      : undefined;
    message.pastExpChild = (object.pastExpChild !== undefined && object.pastExpChild !== null)
      ? GenerationInstructionsDTO.fromPartial(object.pastExpChild)
      : undefined;
    message.pastExpAdult = (object.pastExpAdult !== undefined && object.pastExpAdult !== null)
      ? GenerationInstructionsDTO.fromPartial(object.pastExpAdult)
      : undefined;
    message.skillSets = (object.skillSets !== undefined && object.skillSets !== null)
      ? GenerationInstructionsDTO.fromPartial(object.skillSets)
      : undefined;
    message.skillAdjustments = (object.skillAdjustments !== undefined && object.skillAdjustments !== null)
      ? SkillAdjustmentsDTO.fromPartial(object.skillAdjustments)
      : undefined;
    message.personality = (object.personality !== undefined && object.personality !== null)
      ? GenerationInstructionsDTO.fromPartial(object.personality)
      : undefined;
    message.gender = (object.gender !== undefined && object.gender !== null)
      ? GenerationInstructionDTO.fromPartial(object.gender)
      : undefined;
    return message;
  },
};

function createBaseSkillAdjustmentsDTO(): SkillAdjustmentsDTO {
  return { skillAdjustments: {} };
}

export const SkillAdjustmentsDTO: MessageFns<SkillAdjustmentsDTO> = {
  encode(message: SkillAdjustmentsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.skillAdjustments).forEach(([key, value]) => {
      SkillAdjustmentsDTO_SkillAdjustmentsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillAdjustmentsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillAdjustmentsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SkillAdjustmentsDTO_SkillAdjustmentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.skillAdjustments[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillAdjustmentsDTO {
    return {
      skillAdjustments: isObject(object.skillAdjustments)
        ? Object.entries(object.skillAdjustments).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SkillAdjustmentsDTO): unknown {
    const obj: any = {};
    if (message.skillAdjustments) {
      const entries = Object.entries(message.skillAdjustments);
      if (entries.length > 0) {
        obj.skillAdjustments = {};
        entries.forEach(([k, v]) => {
          obj.skillAdjustments[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillAdjustmentsDTO>, I>>(base?: I): SkillAdjustmentsDTO {
    return SkillAdjustmentsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillAdjustmentsDTO>, I>>(object: I): SkillAdjustmentsDTO {
    const message = createBaseSkillAdjustmentsDTO();
    message.skillAdjustments = Object.entries(object.skillAdjustments ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSkillAdjustmentsDTO_SkillAdjustmentsEntry(): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
  return { key: "", value: 0 };
}

export const SkillAdjustmentsDTO_SkillAdjustmentsEntry: MessageFns<SkillAdjustmentsDTO_SkillAdjustmentsEntry> = {
  encode(message: SkillAdjustmentsDTO_SkillAdjustmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillAdjustmentsDTO_SkillAdjustmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: SkillAdjustmentsDTO_SkillAdjustmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillAdjustmentsDTO_SkillAdjustmentsEntry>, I>>(
    base?: I,
  ): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
    return SkillAdjustmentsDTO_SkillAdjustmentsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillAdjustmentsDTO_SkillAdjustmentsEntry>, I>>(
    object: I,
  ): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
    const message = createBaseSkillAdjustmentsDTO_SkillAdjustmentsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSimpleProbDTO(): SimpleProbDTO {
  return { cond: 0, prob: {}, clazz: "" };
}

export const SimpleProbDTO: MessageFns<SimpleProbDTO> = {
  encode(message: SimpleProbDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cond !== 0) {
      writer.uint32(8).int32(message.cond);
    }
    Object.entries(message.prob).forEach(([key, value]) => {
      SimpleProbDTO_ProbEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.clazz !== "") {
      writer.uint32(26).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleProbDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleProbDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cond = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SimpleProbDTO_ProbEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.prob[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleProbDTO {
    return {
      cond: isSet(object.cond) ? conditionEnumDTOFromJSON(object.cond) : 0,
      prob: isObject(object.prob)
        ? Object.entries(object.prob).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: SimpleProbDTO): unknown {
    const obj: any = {};
    if (message.cond !== 0) {
      obj.cond = conditionEnumDTOToJSON(message.cond);
    }
    if (message.prob) {
      const entries = Object.entries(message.prob);
      if (entries.length > 0) {
        obj.prob = {};
        entries.forEach(([k, v]) => {
          obj.prob[k] = v;
        });
      }
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleProbDTO>, I>>(base?: I): SimpleProbDTO {
    return SimpleProbDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleProbDTO>, I>>(object: I): SimpleProbDTO {
    const message = createBaseSimpleProbDTO();
    message.cond = object.cond ?? 0;
    message.prob = Object.entries(object.prob ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseSimpleProbDTO_ProbEntry(): SimpleProbDTO_ProbEntry {
  return { key: "", value: 0 };
}

export const SimpleProbDTO_ProbEntry: MessageFns<SimpleProbDTO_ProbEntry> = {
  encode(message: SimpleProbDTO_ProbEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleProbDTO_ProbEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleProbDTO_ProbEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleProbDTO_ProbEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: SimpleProbDTO_ProbEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleProbDTO_ProbEntry>, I>>(base?: I): SimpleProbDTO_ProbEntry {
    return SimpleProbDTO_ProbEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleProbDTO_ProbEntry>, I>>(object: I): SimpleProbDTO_ProbEntry {
    const message = createBaseSimpleProbDTO_ProbEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGaussianProbDTO(): GaussianProbDTO {
  return { blueprintId: "", prob: undefined, avgQuan: undefined, stDev: undefined, skew: undefined, clazz: "" };
}

export const GaussianProbDTO: MessageFns<GaussianProbDTO> = {
  encode(message: GaussianProbDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.prob !== undefined) {
      writer.uint32(21).float(message.prob);
    }
    if (message.avgQuan !== undefined) {
      writer.uint32(24).int32(message.avgQuan);
    }
    if (message.stDev !== undefined) {
      writer.uint32(37).float(message.stDev);
    }
    if (message.skew !== undefined) {
      writer.uint32(45).float(message.skew);
    }
    if (message.clazz !== "") {
      writer.uint32(50).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GaussianProbDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGaussianProbDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.prob = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.avgQuan = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.stDev = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.skew = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GaussianProbDTO {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      prob: isSet(object.prob) ? globalThis.Number(object.prob) : undefined,
      avgQuan: isSet(object.avgQuan) ? globalThis.Number(object.avgQuan) : undefined,
      stDev: isSet(object.stDev) ? globalThis.Number(object.stDev) : undefined,
      skew: isSet(object.skew) ? globalThis.Number(object.skew) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: GaussianProbDTO): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.prob !== undefined) {
      obj.prob = message.prob;
    }
    if (message.avgQuan !== undefined) {
      obj.avgQuan = Math.round(message.avgQuan);
    }
    if (message.stDev !== undefined) {
      obj.stDev = message.stDev;
    }
    if (message.skew !== undefined) {
      obj.skew = message.skew;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GaussianProbDTO>, I>>(base?: I): GaussianProbDTO {
    return GaussianProbDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GaussianProbDTO>, I>>(object: I): GaussianProbDTO {
    const message = createBaseGaussianProbDTO();
    message.blueprintId = object.blueprintId ?? "";
    message.prob = object.prob ?? undefined;
    message.avgQuan = object.avgQuan ?? undefined;
    message.stDev = object.stDev ?? undefined;
    message.skew = object.skew ?? undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseCombinatorDTO(): CombinatorDTO {
  return { name: undefined, cond: 0, prob: undefined, instructions: [], clazz: "" };
}

export const CombinatorDTO: MessageFns<CombinatorDTO> = {
  encode(message: CombinatorDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.cond !== 0) {
      writer.uint32(16).int32(message.cond);
    }
    if (message.prob !== undefined) {
      writer.uint32(29).float(message.prob);
    }
    for (const v of message.instructions) {
      GenerationInstructionDTO.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(42).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CombinatorDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCombinatorDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cond = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.prob = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instructions.push(GenerationInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CombinatorDTO {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      cond: isSet(object.cond) ? conditionEnumDTOFromJSON(object.cond) : 0,
      prob: isSet(object.prob) ? globalThis.Number(object.prob) : undefined,
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => GenerationInstructionDTO.fromJSON(e))
        : [],
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: CombinatorDTO): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.cond !== 0) {
      obj.cond = conditionEnumDTOToJSON(message.cond);
    }
    if (message.prob !== undefined) {
      obj.prob = message.prob;
    }
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => GenerationInstructionDTO.toJSON(e));
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CombinatorDTO>, I>>(base?: I): CombinatorDTO {
    return CombinatorDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CombinatorDTO>, I>>(object: I): CombinatorDTO {
    const message = createBaseCombinatorDTO();
    message.name = object.name ?? undefined;
    message.cond = object.cond ?? 0;
    message.prob = object.prob ?? undefined;
    message.instructions = object.instructions?.map((e) => GenerationInstructionDTO.fromPartial(e)) || [];
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBasePastExperienceDTO(): PastExperienceDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    type: 0,
    targetEntity: "",
  };
}

export const PastExperienceDTO: MessageFns<PastExperienceDTO> = {
  encode(message: PastExperienceDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PastExperienceDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePastExperienceDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PastExperienceDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      type: isSet(object.type) ? pastExperienceTypeEnumDTOFromJSON(object.type) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: PastExperienceDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.type !== 0) {
      obj.type = pastExperienceTypeEnumDTOToJSON(message.type);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PastExperienceDTO>, I>>(base?: I): PastExperienceDTO {
    return PastExperienceDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PastExperienceDTO>, I>>(object: I): PastExperienceDTO {
    const message = createBasePastExperienceDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.type = object.type ?? 0;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBasePastExperiencesDTO(): PastExperiencesDTO {
  return { arr: [] };
}

export const PastExperiencesDTO: MessageFns<PastExperiencesDTO> = {
  encode(message: PastExperiencesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      PastExperienceDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PastExperiencesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePastExperiencesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(PastExperienceDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PastExperiencesDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => PastExperienceDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: PastExperiencesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => PastExperienceDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PastExperiencesDTO>, I>>(base?: I): PastExperiencesDTO {
    return PastExperiencesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PastExperiencesDTO>, I>>(object: I): PastExperiencesDTO {
    const message = createBasePastExperiencesDTO();
    message.arr = object.arr?.map((e) => PastExperienceDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemoryDTO(): MemoryDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    facts: undefined,
    type: 0,
    description: "",
    targetEntity: "",
  };
}

export const MemoryDTO: MessageFns<MemoryDTO> = {
  encode(message: MemoryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.facts !== undefined) {
      FactsDTO.encode(message.facts, writer.uint32(74).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.targetEntity !== "") {
      writer.uint32(98).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.facts = FactsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      facts: isSet(object.facts) ? FactsDTO.fromJSON(object.facts) : undefined,
      type: isSet(object.type) ? memoryTypeEnumDTOFromJSON(object.type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: MemoryDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.facts !== undefined) {
      obj.facts = FactsDTO.toJSON(message.facts);
    }
    if (message.type !== 0) {
      obj.type = memoryTypeEnumDTOToJSON(message.type);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryDTO>, I>>(base?: I): MemoryDTO {
    return MemoryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryDTO>, I>>(object: I): MemoryDTO {
    const message = createBaseMemoryDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.facts = (object.facts !== undefined && object.facts !== null)
      ? FactsDTO.fromPartial(object.facts)
      : undefined;
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseMemoriesDTO(): MemoriesDTO {
  return { arr: [] };
}

export const MemoriesDTO: MessageFns<MemoriesDTO> = {
  encode(message: MemoriesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      MemoryDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoriesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoriesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(MemoryDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoriesDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => MemoryDTO.fromJSON(e)) : [] };
  },

  toJSON(message: MemoriesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => MemoryDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoriesDTO>, I>>(base?: I): MemoriesDTO {
    return MemoriesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoriesDTO>, I>>(object: I): MemoriesDTO {
    const message = createBaseMemoriesDTO();
    message.arr = object.arr?.map((e) => MemoryDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkillSetDTO(): SkillSetDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    skillImprovement: undefined,
    targetEntity: "",
  };
}

export const SkillSetDTO: MessageFns<SkillSetDTO> = {
  encode(message: SkillSetDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    for (const v of message.tags) {
      writer.uint32(66).string(v!);
    }
    if (message.skillImprovement !== undefined) {
      SkillImprovementDTO.encode(message.skillImprovement, writer.uint32(74).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillSetDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillSetDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.skillImprovement = SkillImprovementDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillSetDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => globalThis.String(e)) : [],
      skillImprovement: isSet(object.skillImprovement)
        ? SkillImprovementDTO.fromJSON(object.skillImprovement)
        : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: SkillSetDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.tags?.length) {
      obj.tags = message.tags;
    }
    if (message.skillImprovement !== undefined) {
      obj.skillImprovement = SkillImprovementDTO.toJSON(message.skillImprovement);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillSetDTO>, I>>(base?: I): SkillSetDTO {
    return SkillSetDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillSetDTO>, I>>(object: I): SkillSetDTO {
    const message = createBaseSkillSetDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.tags = object.tags?.map((e) => e) || [];
    message.skillImprovement = (object.skillImprovement !== undefined && object.skillImprovement !== null)
      ? SkillImprovementDTO.fromPartial(object.skillImprovement)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseSkillSetsDTO(): SkillSetsDTO {
  return { arr: [] };
}

export const SkillSetsDTO: MessageFns<SkillSetsDTO> = {
  encode(message: SkillSetsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      SkillSetDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillSetsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillSetsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(SkillSetDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillSetsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => SkillSetDTO.fromJSON(e)) : [] };
  },

  toJSON(message: SkillSetsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => SkillSetDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillSetsDTO>, I>>(base?: I): SkillSetsDTO {
    return SkillSetsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillSetsDTO>, I>>(object: I): SkillSetsDTO {
    const message = createBaseSkillSetsDTO();
    message.arr = object.arr?.map((e) => SkillSetDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkillImprovementDTO(): SkillImprovementDTO {
  return { skillImprovement: {} };
}

export const SkillImprovementDTO: MessageFns<SkillImprovementDTO> = {
  encode(message: SkillImprovementDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.skillImprovement).forEach(([key, value]) => {
      SkillImprovementDTO_SkillImprovementEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillImprovementDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillImprovementDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SkillImprovementDTO_SkillImprovementEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.skillImprovement[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillImprovementDTO {
    return {
      skillImprovement: isObject(object.skillImprovement)
        ? Object.entries(object.skillImprovement).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SkillImprovementDTO): unknown {
    const obj: any = {};
    if (message.skillImprovement) {
      const entries = Object.entries(message.skillImprovement);
      if (entries.length > 0) {
        obj.skillImprovement = {};
        entries.forEach(([k, v]) => {
          obj.skillImprovement[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillImprovementDTO>, I>>(base?: I): SkillImprovementDTO {
    return SkillImprovementDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillImprovementDTO>, I>>(object: I): SkillImprovementDTO {
    const message = createBaseSkillImprovementDTO();
    message.skillImprovement = Object.entries(object.skillImprovement ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSkillImprovementDTO_SkillImprovementEntry(): SkillImprovementDTO_SkillImprovementEntry {
  return { key: "", value: 0 };
}

export const SkillImprovementDTO_SkillImprovementEntry: MessageFns<SkillImprovementDTO_SkillImprovementEntry> = {
  encode(message: SkillImprovementDTO_SkillImprovementEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillImprovementDTO_SkillImprovementEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillImprovementDTO_SkillImprovementEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillImprovementDTO_SkillImprovementEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: SkillImprovementDTO_SkillImprovementEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillImprovementDTO_SkillImprovementEntry>, I>>(
    base?: I,
  ): SkillImprovementDTO_SkillImprovementEntry {
    return SkillImprovementDTO_SkillImprovementEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillImprovementDTO_SkillImprovementEntry>, I>>(
    object: I,
  ): SkillImprovementDTO_SkillImprovementEntry {
    const message = createBaseSkillImprovementDTO_SkillImprovementEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBasePersonalityProfileDTO(): PersonalityProfileDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    enneagramType: "",
    traits: [],
    targetEntity: "",
  };
}

export const PersonalityProfileDTO: MessageFns<PersonalityProfileDTO> = {
  encode(message: PersonalityProfileDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.enneagramType !== "") {
      writer.uint32(66).string(message.enneagramType);
    }
    for (const v of message.traits) {
      GenerationInstructionDTO.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalityProfileDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalityProfileDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.enneagramType = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.traits.push(GenerationInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalityProfileDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      enneagramType: isSet(object.enneagramType) ? globalThis.String(object.enneagramType) : "",
      traits: globalThis.Array.isArray(object?.traits)
        ? object.traits.map((e: any) => GenerationInstructionDTO.fromJSON(e))
        : [],
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: PersonalityProfileDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.enneagramType !== "") {
      obj.enneagramType = message.enneagramType;
    }
    if (message.traits?.length) {
      obj.traits = message.traits.map((e) => GenerationInstructionDTO.toJSON(e));
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonalityProfileDTO>, I>>(base?: I): PersonalityProfileDTO {
    return PersonalityProfileDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonalityProfileDTO>, I>>(object: I): PersonalityProfileDTO {
    const message = createBasePersonalityProfileDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.enneagramType = object.enneagramType ?? "";
    message.traits = object.traits?.map((e) => GenerationInstructionDTO.fromPartial(e)) || [];
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBasePersonalityProfilesDTO(): PersonalityProfilesDTO {
  return { arr: [] };
}

export const PersonalityProfilesDTO: MessageFns<PersonalityProfilesDTO> = {
  encode(message: PersonalityProfilesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      PersonalityProfileDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalityProfilesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalityProfilesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(PersonalityProfileDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalityProfilesDTO {
    return {
      arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => PersonalityProfileDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: PersonalityProfilesDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => PersonalityProfileDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonalityProfilesDTO>, I>>(base?: I): PersonalityProfilesDTO {
    return PersonalityProfilesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonalityProfilesDTO>, I>>(object: I): PersonalityProfilesDTO {
    const message = createBasePersonalityProfilesDTO();
    message.arr = object.arr?.map((e) => PersonalityProfileDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNeedDTO(): NeedDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
    type: 0,
    layer: 0,
    targetEntity: "",
  };
}

export const NeedDTO: MessageFns<NeedDTO> = {
  encode(message: NeedDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      writer.uint32(42).string(message.user);
    }
    if (message.campaign !== undefined) {
      writer.uint32(50).string(message.campaign);
    }
    if (message.world !== undefined) {
      writer.uint32(58).string(message.world);
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.layer !== 0) {
      writer.uint32(80).int32(message.layer);
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NeedDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNeedDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.layer = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NeedDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaign: isSet(object.campaign) ? globalThis.String(object.campaign) : undefined,
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? needTypeEnumDTOFromJSON(object.type) : 0,
      layer: isSet(object.layer) ? needLayerEnumDTOFromJSON(object.layer) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: NeedDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaign !== undefined) {
      obj.campaign = message.campaign;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = needTypeEnumDTOToJSON(message.type);
    }
    if (message.layer !== 0) {
      obj.layer = needLayerEnumDTOToJSON(message.layer);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NeedDTO>, I>>(base?: I): NeedDTO {
    return NeedDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NeedDTO>, I>>(object: I): NeedDTO {
    const message = createBaseNeedDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = object.user ?? undefined;
    message.campaign = object.campaign ?? undefined;
    message.world = object.world ?? undefined;
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.layer = object.layer ?? 0;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseNeedsDTO(): NeedsDTO {
  return { arr: [] };
}

export const NeedsDTO: MessageFns<NeedsDTO> = {
  encode(message: NeedsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      NeedDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NeedsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNeedsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(NeedDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NeedsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => NeedDTO.fromJSON(e)) : [] };
  },

  toJSON(message: NeedsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => NeedDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NeedsDTO>, I>>(base?: I): NeedsDTO {
    return NeedsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NeedsDTO>, I>>(object: I): NeedsDTO {
    const message = createBaseNeedsDTO();
    message.arr = object.arr?.map((e) => NeedDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserDTO(): UserDTO {
  return { id: "", backgrounds: undefined, worlds: undefined, campaigns: undefined, account: undefined };
}

export const UserDTO: MessageFns<UserDTO> = {
  encode(message: UserDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.backgrounds !== undefined) {
      BackgroundsDTO.encode(message.backgrounds, writer.uint32(18).fork()).join();
    }
    if (message.worlds !== undefined) {
      WorldsDTO.encode(message.worlds, writer.uint32(26).fork()).join();
    }
    if (message.campaigns !== undefined) {
      CampaignsDTO.encode(message.campaigns, writer.uint32(34).fork()).join();
    }
    if (message.account !== undefined) {
      AccountDTO.encode(message.account, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.backgrounds = BackgroundsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.worlds = WorldsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.campaigns = CampaignsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.account = AccountDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      backgrounds: isSet(object.backgrounds) ? BackgroundsDTO.fromJSON(object.backgrounds) : undefined,
      worlds: isSet(object.worlds) ? WorldsDTO.fromJSON(object.worlds) : undefined,
      campaigns: isSet(object.campaigns) ? CampaignsDTO.fromJSON(object.campaigns) : undefined,
      account: isSet(object.account) ? AccountDTO.fromJSON(object.account) : undefined,
    };
  },

  toJSON(message: UserDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.backgrounds !== undefined) {
      obj.backgrounds = BackgroundsDTO.toJSON(message.backgrounds);
    }
    if (message.worlds !== undefined) {
      obj.worlds = WorldsDTO.toJSON(message.worlds);
    }
    if (message.campaigns !== undefined) {
      obj.campaigns = CampaignsDTO.toJSON(message.campaigns);
    }
    if (message.account !== undefined) {
      obj.account = AccountDTO.toJSON(message.account);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserDTO>, I>>(base?: I): UserDTO {
    return UserDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserDTO>, I>>(object: I): UserDTO {
    const message = createBaseUserDTO();
    message.id = object.id ?? "";
    message.backgrounds = (object.backgrounds !== undefined && object.backgrounds !== null)
      ? BackgroundsDTO.fromPartial(object.backgrounds)
      : undefined;
    message.worlds = (object.worlds !== undefined && object.worlds !== null)
      ? WorldsDTO.fromPartial(object.worlds)
      : undefined;
    message.campaigns = (object.campaigns !== undefined && object.campaigns !== null)
      ? CampaignsDTO.fromPartial(object.campaigns)
      : undefined;
    message.account = (object.account !== undefined && object.account !== null)
      ? AccountDTO.fromPartial(object.account)
      : undefined;
    return message;
  },
};

function createBaseUsersDTO(): UsersDTO {
  return { arr: [] };
}

export const UsersDTO: MessageFns<UsersDTO> = {
  encode(message: UsersDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      UserDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsersDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsersDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(UserDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsersDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => UserDTO.fromJSON(e)) : [] };
  },

  toJSON(message: UsersDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => UserDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsersDTO>, I>>(base?: I): UsersDTO {
    return UsersDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsersDTO>, I>>(object: I): UsersDTO {
    const message = createBaseUsersDTO();
    message.arr = object.arr?.map((e) => UserDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAccountDTO(): AccountDTO {
  return { id: "", username: "", email: "", role: "", user: undefined, preferences: undefined };
}

export const AccountDTO: MessageFns<AccountDTO> = {
  encode(message: AccountDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.role !== "") {
      writer.uint32(34).string(message.role);
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.preferences !== undefined) {
      PreferencesDTO.encode(message.preferences, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.preferences = PreferencesDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      preferences: isSet(object.preferences) ? PreferencesDTO.fromJSON(object.preferences) : undefined,
    };
  },

  toJSON(message: AccountDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.preferences !== undefined) {
      obj.preferences = PreferencesDTO.toJSON(message.preferences);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AccountDTO>, I>>(base?: I): AccountDTO {
    return AccountDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AccountDTO>, I>>(object: I): AccountDTO {
    const message = createBaseAccountDTO();
    message.id = object.id ?? "";
    message.username = object.username ?? "";
    message.email = object.email ?? "";
    message.role = object.role ?? "";
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.preferences = (object.preferences !== undefined && object.preferences !== null)
      ? PreferencesDTO.fromPartial(object.preferences)
      : undefined;
    return message;
  },
};

function createBasePreferencesDTO(): PreferencesDTO {
  return {};
}

export const PreferencesDTO: MessageFns<PreferencesDTO> = {
  encode(_: PreferencesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreferencesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreferencesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PreferencesDTO {
    return {};
  },

  toJSON(_: PreferencesDTO): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PreferencesDTO>, I>>(base?: I): PreferencesDTO {
    return PreferencesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreferencesDTO>, I>>(_: I): PreferencesDTO {
    const message = createBasePreferencesDTO();
    return message;
  },
};

function createBaseWorldSettings(): WorldSettings {
  return { settings: {} };
}

export const WorldSettings: MessageFns<WorldSettings> = {
  encode(message: WorldSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.settings).forEach(([key, value]) => {
      WorldSettings_SettingsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = WorldSettings_SettingsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.settings[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldSettings {
    return {
      settings: isObject(object.settings)
        ? Object.entries(object.settings).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: WorldSettings): unknown {
    const obj: any = {};
    if (message.settings) {
      const entries = Object.entries(message.settings);
      if (entries.length > 0) {
        obj.settings = {};
        entries.forEach(([k, v]) => {
          obj.settings[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldSettings>, I>>(base?: I): WorldSettings {
    return WorldSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldSettings>, I>>(object: I): WorldSettings {
    const message = createBaseWorldSettings();
    message.settings = Object.entries(object.settings ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWorldSettings_SettingsEntry(): WorldSettings_SettingsEntry {
  return { key: "", value: "" };
}

export const WorldSettings_SettingsEntry: MessageFns<WorldSettings_SettingsEntry> = {
  encode(message: WorldSettings_SettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldSettings_SettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldSettings_SettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldSettings_SettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorldSettings_SettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldSettings_SettingsEntry>, I>>(base?: I): WorldSettings_SettingsEntry {
    return WorldSettings_SettingsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldSettings_SettingsEntry>, I>>(object: I): WorldSettings_SettingsEntry {
    const message = createBaseWorldSettings_SettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorldDTO(): WorldDTO {
  return {
    id: "",
    name: "",
    description: undefined,
    settings: undefined,
    frozen: false,
    user: undefined,
    campaigns: undefined,
  };
}

export const WorldDTO: MessageFns<WorldDTO> = {
  encode(message: WorldDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    if (message.settings !== undefined) {
      WorldSettings.encode(message.settings, writer.uint32(34).fork()).join();
    }
    if (message.frozen !== false) {
      writer.uint32(40).bool(message.frozen);
    }
    if (message.user !== undefined) {
      writer.uint32(50).string(message.user);
    }
    if (message.campaigns !== undefined) {
      CampaignsDTO.encode(message.campaigns, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.settings = WorldSettings.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.frozen = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.campaigns = CampaignsDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      settings: isSet(object.settings) ? WorldSettings.fromJSON(object.settings) : undefined,
      frozen: isSet(object.frozen) ? globalThis.Boolean(object.frozen) : false,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
      campaigns: isSet(object.campaigns) ? CampaignsDTO.fromJSON(object.campaigns) : undefined,
    };
  },

  toJSON(message: WorldDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.settings !== undefined) {
      obj.settings = WorldSettings.toJSON(message.settings);
    }
    if (message.frozen !== false) {
      obj.frozen = message.frozen;
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    if (message.campaigns !== undefined) {
      obj.campaigns = CampaignsDTO.toJSON(message.campaigns);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldDTO>, I>>(base?: I): WorldDTO {
    return WorldDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldDTO>, I>>(object: I): WorldDTO {
    const message = createBaseWorldDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? WorldSettings.fromPartial(object.settings)
      : undefined;
    message.frozen = object.frozen ?? false;
    message.user = object.user ?? undefined;
    message.campaigns = (object.campaigns !== undefined && object.campaigns !== null)
      ? CampaignsDTO.fromPartial(object.campaigns)
      : undefined;
    return message;
  },
};

function createBaseWorldsDTO(): WorldsDTO {
  return { arr: [] };
}

export const WorldsDTO: MessageFns<WorldsDTO> = {
  encode(message: WorldsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      WorldDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(WorldDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => WorldDTO.fromJSON(e)) : [] };
  },

  toJSON(message: WorldsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => WorldDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldsDTO>, I>>(base?: I): WorldsDTO {
    return WorldsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldsDTO>, I>>(object: I): WorldsDTO {
    const message = createBaseWorldsDTO();
    message.arr = object.arr?.map((e) => WorldDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCampaignDTO(): CampaignDTO {
  return {
    id: "",
    name: "",
    description: undefined,
    dynamicState: {},
    createdAt: "",
    world: undefined,
    user: undefined,
  };
}

export const CampaignDTO: MessageFns<CampaignDTO> = {
  encode(message: CampaignDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== undefined) {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.dynamicState).forEach(([key, value]) => {
      CampaignDTO_DynamicStateEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.world !== undefined) {
      writer.uint32(50).string(message.world);
    }
    if (message.user !== undefined) {
      writer.uint32(58).string(message.user);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CampaignDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CampaignDTO_DynamicStateEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.dynamicState[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.world = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampaignDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      dynamicState: isObject(object.dynamicState)
        ? Object.entries(object.dynamicState).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      world: isSet(object.world) ? globalThis.String(object.world) : undefined,
      user: isSet(object.user) ? globalThis.String(object.user) : undefined,
    };
  },

  toJSON(message: CampaignDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.dynamicState) {
      const entries = Object.entries(message.dynamicState);
      if (entries.length > 0) {
        obj.dynamicState = {};
        entries.forEach(([k, v]) => {
          obj.dynamicState[k] = v;
        });
      }
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.world !== undefined) {
      obj.world = message.world;
    }
    if (message.user !== undefined) {
      obj.user = message.user;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CampaignDTO>, I>>(base?: I): CampaignDTO {
    return CampaignDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CampaignDTO>, I>>(object: I): CampaignDTO {
    const message = createBaseCampaignDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? undefined;
    message.dynamicState = Object.entries(object.dynamicState ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createdAt = object.createdAt ?? "";
    message.world = object.world ?? undefined;
    message.user = object.user ?? undefined;
    return message;
  },
};

function createBaseCampaignDTO_DynamicStateEntry(): CampaignDTO_DynamicStateEntry {
  return { key: "", value: "" };
}

export const CampaignDTO_DynamicStateEntry: MessageFns<CampaignDTO_DynamicStateEntry> = {
  encode(message: CampaignDTO_DynamicStateEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CampaignDTO_DynamicStateEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignDTO_DynamicStateEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampaignDTO_DynamicStateEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CampaignDTO_DynamicStateEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CampaignDTO_DynamicStateEntry>, I>>(base?: I): CampaignDTO_DynamicStateEntry {
    return CampaignDTO_DynamicStateEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CampaignDTO_DynamicStateEntry>, I>>(
    object: I,
  ): CampaignDTO_DynamicStateEntry {
    const message = createBaseCampaignDTO_DynamicStateEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCampaignsDTO(): CampaignsDTO {
  return { arr: [] };
}

export const CampaignsDTO: MessageFns<CampaignsDTO> = {
  encode(message: CampaignsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.arr) {
      CampaignDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CampaignsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.arr.push(CampaignDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampaignsDTO {
    return { arr: globalThis.Array.isArray(object?.arr) ? object.arr.map((e: any) => CampaignDTO.fromJSON(e)) : [] };
  },

  toJSON(message: CampaignsDTO): unknown {
    const obj: any = {};
    if (message.arr?.length) {
      obj.arr = message.arr.map((e) => CampaignDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CampaignsDTO>, I>>(base?: I): CampaignsDTO {
    return CampaignsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CampaignsDTO>, I>>(object: I): CampaignsDTO {
    const message = createBaseCampaignsDTO();
    message.arr = object.arr?.map((e) => CampaignDTO.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
