// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v3.20.3
// source: src/proto/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "common";

/** ####################################################################################### */
export enum EffectTypeEnumDTO {
  DAMAGE = 0,
  HEALING = 1,
  BUFF = 2,
  DEBUFF = 3,
  RESISTANCE = 4,
  STEALING = 5,
  NEUTRAL = 6,
  UNRECOGNIZED = -1,
}

export function effectTypeEnumDTOFromJSON(object: any): EffectTypeEnumDTO {
  switch (object) {
    case 0:
    case "DAMAGE":
      return EffectTypeEnumDTO.DAMAGE;
    case 1:
    case "HEALING":
      return EffectTypeEnumDTO.HEALING;
    case 2:
    case "BUFF":
      return EffectTypeEnumDTO.BUFF;
    case 3:
    case "DEBUFF":
      return EffectTypeEnumDTO.DEBUFF;
    case 4:
    case "RESISTANCE":
      return EffectTypeEnumDTO.RESISTANCE;
    case 5:
    case "STEALING":
      return EffectTypeEnumDTO.STEALING;
    case 6:
    case "NEUTRAL":
      return EffectTypeEnumDTO.NEUTRAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectTypeEnumDTO.UNRECOGNIZED;
  }
}

export function effectTypeEnumDTOToJSON(object: EffectTypeEnumDTO): string {
  switch (object) {
    case EffectTypeEnumDTO.DAMAGE:
      return "DAMAGE";
    case EffectTypeEnumDTO.HEALING:
      return "HEALING";
    case EffectTypeEnumDTO.BUFF:
      return "BUFF";
    case EffectTypeEnumDTO.DEBUFF:
      return "DEBUFF";
    case EffectTypeEnumDTO.RESISTANCE:
      return "RESISTANCE";
    case EffectTypeEnumDTO.STEALING:
      return "STEALING";
    case EffectTypeEnumDTO.NEUTRAL:
      return "NEUTRAL";
    case EffectTypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EffectTargetEnumDTO {
  HEALTH = 0,
  STAMINA = 1,
  MANA = 2,
  UNRECOGNIZED = -1,
}

export function effectTargetEnumDTOFromJSON(object: any): EffectTargetEnumDTO {
  switch (object) {
    case 0:
    case "HEALTH":
      return EffectTargetEnumDTO.HEALTH;
    case 1:
    case "STAMINA":
      return EffectTargetEnumDTO.STAMINA;
    case 2:
    case "MANA":
      return EffectTargetEnumDTO.MANA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectTargetEnumDTO.UNRECOGNIZED;
  }
}

export function effectTargetEnumDTOToJSON(object: EffectTargetEnumDTO): string {
  switch (object) {
    case EffectTargetEnumDTO.HEALTH:
      return "HEALTH";
    case EffectTargetEnumDTO.STAMINA:
      return "STAMINA";
    case EffectTargetEnumDTO.MANA:
      return "MANA";
    case EffectTargetEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EffectModeEnumDTO {
  INSTANT = 0,
  GRADUAL = 1,
  PERSISTENT = 2,
  UNRECOGNIZED = -1,
}

export function effectModeEnumDTOFromJSON(object: any): EffectModeEnumDTO {
  switch (object) {
    case 0:
    case "INSTANT":
      return EffectModeEnumDTO.INSTANT;
    case 1:
    case "GRADUAL":
      return EffectModeEnumDTO.GRADUAL;
    case 2:
    case "PERSISTENT":
      return EffectModeEnumDTO.PERSISTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectModeEnumDTO.UNRECOGNIZED;
  }
}

export function effectModeEnumDTOToJSON(object: EffectModeEnumDTO): string {
  switch (object) {
    case EffectModeEnumDTO.INSTANT:
      return "INSTANT";
    case EffectModeEnumDTO.GRADUAL:
      return "GRADUAL";
    case EffectModeEnumDTO.PERSISTENT:
      return "PERSISTENT";
    case EffectModeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EffectElementEnumDTO {
  FIRE = 0,
  FROST = 1,
  POISON = 2,
  SHOCK = 3,
  UNRECOGNIZED = -1,
}

export function effectElementEnumDTOFromJSON(object: any): EffectElementEnumDTO {
  switch (object) {
    case 0:
    case "FIRE":
      return EffectElementEnumDTO.FIRE;
    case 1:
    case "FROST":
      return EffectElementEnumDTO.FROST;
    case 2:
    case "POISON":
      return EffectElementEnumDTO.POISON;
    case 3:
    case "SHOCK":
      return EffectElementEnumDTO.SHOCK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectElementEnumDTO.UNRECOGNIZED;
  }
}

export function effectElementEnumDTOToJSON(object: EffectElementEnumDTO): string {
  switch (object) {
    case EffectElementEnumDTO.FIRE:
      return "FIRE";
    case EffectElementEnumDTO.FROST:
      return "FROST";
    case EffectElementEnumDTO.POISON:
      return "POISON";
    case EffectElementEnumDTO.SHOCK:
      return "SHOCK";
    case EffectElementEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NeedTypeEnumDTO {
  DYNAMIC = 0,
  THRESHOLD = 1,
  EXTERNAL = 2,
  UNRECOGNIZED = -1,
}

export function needTypeEnumDTOFromJSON(object: any): NeedTypeEnumDTO {
  switch (object) {
    case 0:
    case "DYNAMIC":
      return NeedTypeEnumDTO.DYNAMIC;
    case 1:
    case "THRESHOLD":
      return NeedTypeEnumDTO.THRESHOLD;
    case 2:
    case "EXTERNAL":
      return NeedTypeEnumDTO.EXTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NeedTypeEnumDTO.UNRECOGNIZED;
  }
}

export function needTypeEnumDTOToJSON(object: NeedTypeEnumDTO): string {
  switch (object) {
    case NeedTypeEnumDTO.DYNAMIC:
      return "DYNAMIC";
    case NeedTypeEnumDTO.THRESHOLD:
      return "THRESHOLD";
    case NeedTypeEnumDTO.EXTERNAL:
      return "EXTERNAL";
    case NeedTypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NeedLayerEnumDTO {
  PHYSIOLOGICAL = 0,
  SAFETY = 1,
  BELONGING_AND_LOVE = 2,
  ESTEEM = 3,
  COGNITIVE = 4,
  AESTHETIC = 5,
  SELF_ACTUALIZATION = 6,
  TRANSCENDENCE = 7,
  UNRECOGNIZED = -1,
}

export function needLayerEnumDTOFromJSON(object: any): NeedLayerEnumDTO {
  switch (object) {
    case 0:
    case "PHYSIOLOGICAL":
      return NeedLayerEnumDTO.PHYSIOLOGICAL;
    case 1:
    case "SAFETY":
      return NeedLayerEnumDTO.SAFETY;
    case 2:
    case "BELONGING_AND_LOVE":
      return NeedLayerEnumDTO.BELONGING_AND_LOVE;
    case 3:
    case "ESTEEM":
      return NeedLayerEnumDTO.ESTEEM;
    case 4:
    case "COGNITIVE":
      return NeedLayerEnumDTO.COGNITIVE;
    case 5:
    case "AESTHETIC":
      return NeedLayerEnumDTO.AESTHETIC;
    case 6:
    case "SELF_ACTUALIZATION":
      return NeedLayerEnumDTO.SELF_ACTUALIZATION;
    case 7:
    case "TRANSCENDENCE":
      return NeedLayerEnumDTO.TRANSCENDENCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NeedLayerEnumDTO.UNRECOGNIZED;
  }
}

export function needLayerEnumDTOToJSON(object: NeedLayerEnumDTO): string {
  switch (object) {
    case NeedLayerEnumDTO.PHYSIOLOGICAL:
      return "PHYSIOLOGICAL";
    case NeedLayerEnumDTO.SAFETY:
      return "SAFETY";
    case NeedLayerEnumDTO.BELONGING_AND_LOVE:
      return "BELONGING_AND_LOVE";
    case NeedLayerEnumDTO.ESTEEM:
      return "ESTEEM";
    case NeedLayerEnumDTO.COGNITIVE:
      return "COGNITIVE";
    case NeedLayerEnumDTO.AESTHETIC:
      return "AESTHETIC";
    case NeedLayerEnumDTO.SELF_ACTUALIZATION:
      return "SELF_ACTUALIZATION";
    case NeedLayerEnumDTO.TRANSCENDENCE:
      return "TRANSCENDENCE";
    case NeedLayerEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MemoryTypeEnumDTO {
  GLOBAL = 0,
  REGIONAL = 1,
  EVENT_RELATED = 2,
  HISTORIC = 3,
  PERSONAL = 4,
  UNRECOGNIZED = -1,
}

export function memoryTypeEnumDTOFromJSON(object: any): MemoryTypeEnumDTO {
  switch (object) {
    case 0:
    case "GLOBAL":
      return MemoryTypeEnumDTO.GLOBAL;
    case 1:
    case "REGIONAL":
      return MemoryTypeEnumDTO.REGIONAL;
    case 2:
    case "EVENT_RELATED":
      return MemoryTypeEnumDTO.EVENT_RELATED;
    case 3:
    case "HISTORIC":
      return MemoryTypeEnumDTO.HISTORIC;
    case 4:
    case "PERSONAL":
      return MemoryTypeEnumDTO.PERSONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MemoryTypeEnumDTO.UNRECOGNIZED;
  }
}

export function memoryTypeEnumDTOToJSON(object: MemoryTypeEnumDTO): string {
  switch (object) {
    case MemoryTypeEnumDTO.GLOBAL:
      return "GLOBAL";
    case MemoryTypeEnumDTO.REGIONAL:
      return "REGIONAL";
    case MemoryTypeEnumDTO.EVENT_RELATED:
      return "EVENT_RELATED";
    case MemoryTypeEnumDTO.HISTORIC:
      return "HISTORIC";
    case MemoryTypeEnumDTO.PERSONAL:
      return "PERSONAL";
    case MemoryTypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConditionEnumDTO {
  OR = 0,
  ANY = 1,
  AND = 2,
  UNRECOGNIZED = -1,
}

export function conditionEnumDTOFromJSON(object: any): ConditionEnumDTO {
  switch (object) {
    case 0:
    case "OR":
      return ConditionEnumDTO.OR;
    case 1:
    case "ANY":
      return ConditionEnumDTO.ANY;
    case 2:
    case "AND":
      return ConditionEnumDTO.AND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConditionEnumDTO.UNRECOGNIZED;
  }
}

export function conditionEnumDTOToJSON(object: ConditionEnumDTO): string {
  switch (object) {
    case ConditionEnumDTO.OR:
      return "OR";
    case ConditionEnumDTO.ANY:
      return "ANY";
    case ConditionEnumDTO.AND:
      return "AND";
    case ConditionEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PresetEnumDTO {
  default = 0,
  morrowind = 1,
  UNRECOGNIZED = -1,
}

export function presetEnumDTOFromJSON(object: any): PresetEnumDTO {
  switch (object) {
    case 0:
    case "default":
      return PresetEnumDTO.default;
    case 1:
    case "morrowind":
      return PresetEnumDTO.morrowind;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PresetEnumDTO.UNRECOGNIZED;
  }
}

export function presetEnumDTOToJSON(object: PresetEnumDTO): string {
  switch (object) {
    case PresetEnumDTO.default:
      return "default";
    case PresetEnumDTO.morrowind:
      return "morrowind";
    case PresetEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TagSubtypeEnumDTO {
  MATERIAL = 0,
  CULTURE = 1,
  RELATION = 2,
  FACTION = 3,
  RELIGION = 4,
  WEAPON_QUALITY = 5,
  ARMOR_QUALITY = 6,
  WEAPON_TYPE = 7,
  STATUS = 8,
  QUEST = 9,
  UNRECOGNIZED = -1,
}

export function tagSubtypeEnumDTOFromJSON(object: any): TagSubtypeEnumDTO {
  switch (object) {
    case 0:
    case "MATERIAL":
      return TagSubtypeEnumDTO.MATERIAL;
    case 1:
    case "CULTURE":
      return TagSubtypeEnumDTO.CULTURE;
    case 2:
    case "RELATION":
      return TagSubtypeEnumDTO.RELATION;
    case 3:
    case "FACTION":
      return TagSubtypeEnumDTO.FACTION;
    case 4:
    case "RELIGION":
      return TagSubtypeEnumDTO.RELIGION;
    case 5:
    case "WEAPON_QUALITY":
      return TagSubtypeEnumDTO.WEAPON_QUALITY;
    case 6:
    case "ARMOR_QUALITY":
      return TagSubtypeEnumDTO.ARMOR_QUALITY;
    case 7:
    case "WEAPON_TYPE":
      return TagSubtypeEnumDTO.WEAPON_TYPE;
    case 8:
    case "STATUS":
      return TagSubtypeEnumDTO.STATUS;
    case 9:
    case "QUEST":
      return TagSubtypeEnumDTO.QUEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TagSubtypeEnumDTO.UNRECOGNIZED;
  }
}

export function tagSubtypeEnumDTOToJSON(object: TagSubtypeEnumDTO): string {
  switch (object) {
    case TagSubtypeEnumDTO.MATERIAL:
      return "MATERIAL";
    case TagSubtypeEnumDTO.CULTURE:
      return "CULTURE";
    case TagSubtypeEnumDTO.RELATION:
      return "RELATION";
    case TagSubtypeEnumDTO.FACTION:
      return "FACTION";
    case TagSubtypeEnumDTO.RELIGION:
      return "RELIGION";
    case TagSubtypeEnumDTO.WEAPON_QUALITY:
      return "WEAPON_QUALITY";
    case TagSubtypeEnumDTO.ARMOR_QUALITY:
      return "ARMOR_QUALITY";
    case TagSubtypeEnumDTO.WEAPON_TYPE:
      return "WEAPON_TYPE";
    case TagSubtypeEnumDTO.STATUS:
      return "STATUS";
    case TagSubtypeEnumDTO.QUEST:
      return "QUEST";
    case TagSubtypeEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FactStatusEnumDTO {
  ACCESSIBLE = 0,
  INACCESSIBLE = 1,
  UNRECOGNIZED = -1,
}

export function factStatusEnumDTOFromJSON(object: any): FactStatusEnumDTO {
  switch (object) {
    case 0:
    case "ACCESSIBLE":
      return FactStatusEnumDTO.ACCESSIBLE;
    case 1:
    case "INACCESSIBLE":
      return FactStatusEnumDTO.INACCESSIBLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FactStatusEnumDTO.UNRECOGNIZED;
  }
}

export function factStatusEnumDTOToJSON(object: FactStatusEnumDTO): string {
  switch (object) {
    case FactStatusEnumDTO.ACCESSIBLE:
      return "ACCESSIBLE";
    case FactStatusEnumDTO.INACCESSIBLE:
      return "INACCESSIBLE";
    case FactStatusEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SkillCategoryEnumDTO {
  CRAFTING = 0,
  MAGIC = 1,
  COMBAT = 2,
  STEALTH = 3,
  SOCIAL = 4,
  UNRECOGNIZED = -1,
}

export function skillCategoryEnumDTOFromJSON(object: any): SkillCategoryEnumDTO {
  switch (object) {
    case 0:
    case "CRAFTING":
      return SkillCategoryEnumDTO.CRAFTING;
    case 1:
    case "MAGIC":
      return SkillCategoryEnumDTO.MAGIC;
    case 2:
    case "COMBAT":
      return SkillCategoryEnumDTO.COMBAT;
    case 3:
    case "STEALTH":
      return SkillCategoryEnumDTO.STEALTH;
    case 4:
    case "SOCIAL":
      return SkillCategoryEnumDTO.SOCIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SkillCategoryEnumDTO.UNRECOGNIZED;
  }
}

export function skillCategoryEnumDTOToJSON(object: SkillCategoryEnumDTO): string {
  switch (object) {
    case SkillCategoryEnumDTO.CRAFTING:
      return "CRAFTING";
    case SkillCategoryEnumDTO.MAGIC:
      return "MAGIC";
    case SkillCategoryEnumDTO.COMBAT:
      return "COMBAT";
    case SkillCategoryEnumDTO.STEALTH:
      return "STEALTH";
    case SkillCategoryEnumDTO.SOCIAL:
      return "SOCIAL";
    case SkillCategoryEnumDTO.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ####################################################################################### */
export interface BackgroundDTO {
  id: string;
  name: string;
  faction: GenerationInstructionsDTO | undefined;
  disease: GenerationInstructionsDTO | undefined;
  addiction: GenerationInstructionsDTO | undefined;
  profession: GenerationInstructionsDTO | undefined;
  race: GenerationInstructionsDTO | undefined;
  religion: GenerationInstructionsDTO | undefined;
  personality: GenerationInstructionsDTO | undefined;
  items: GenerationInstructionsDTO | undefined;
  pastExpChild: GenerationInstructionsDTO | undefined;
  pastExpAdult: GenerationInstructionsDTO | undefined;
  memoryPools: GenerationInstructionsDTO | undefined;
  skillSets: string[];
  skillAdjustments: { [key: string]: number };
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  targetEntity: string;
}

export interface BackgroundDTO_SkillAdjustmentsEntry {
  key: string;
  value: number;
}

export interface BackgroundsDTO {
  backgrounds: BackgroundDTO[];
}

/** ####################################################################################### */
export interface Metadata {
  metadata: { [key: string]: string };
}

export interface Metadata_MetadataEntry {
  key: string;
  value: string;
}

/** ####################################################################################### */
export interface EffectDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  tags?: TagsDTO | undefined;
  type: EffectTypeEnumDTO;
  target: EffectTargetEnumDTO;
  mode: EffectModeEnumDTO;
  element?: EffectElementEnumDTO | undefined;
  targetEntity: string;
}

export interface EffectsDTO {
  effects: EffectDTO[];
}

/** ####################################################################################### */
export interface ResistanceDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  effectType: EffectTypeEnumDTO;
  targetEffect?: string | undefined;
  targetEntity: string;
}

export interface ResistancesDTO {
  resistances: ResistanceDTO[];
}

/** ####################################################################################### */
export interface StatusDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  type: EffectTypeEnumDTO;
  effects: string[];
  duration: number;
  description: string;
  targetEntity: string;
}

export interface StatusesDTO {
  statuses: StatusDTO[];
}

/** ####################################################################################### */
export interface ItemSetDTO {
  id: string;
  blueprintId: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  set: GenerationInstructionDTO | undefined;
  targetEntity: string;
}

export interface ItemSetsDTO {
  itemSets: ItemSetDTO[];
}

/** ####################################################################################### */
export interface ItemDTO {
  blueprintId: string;
  metadata?: Metadata | undefined;
  targetEntity: string;
  id: string;
  name: string;
  description: string;
  size: number[];
  quantity?: number | undefined;
  maxQuantity?: number | undefined;
  baseValue?: number | undefined;
  actions?: ItemActionsDTO | undefined;
  requirements?: ItemRequirementsDTO | undefined;
  stackable?: boolean | undefined;
  repairable?: boolean | undefined;
  drinkable?: boolean | undefined;
  edible?: boolean | undefined;
  gridPosition?: GridPositionDTO | undefined;
  durability?: number | undefined;
  maxDurability?: number | undefined;
  damagePierce?: string | undefined;
  armorClass?: number | undefined;
  stealthDisadvantage?: boolean | undefined;
  damageSlash?: string | undefined;
  damageBlunt?: string | undefined;
  range?: number | undefined;
  twoHanded?: boolean | undefined;
  nutrition?: number | undefined;
  spoilage?: number | undefined;
  thirstQuenched?: number | undefined;
  type?: string | undefined;
  storageSlot?: StorageSlotDTO | undefined;
  storageSlots?: StorageSlotsDTO | undefined;
  equipmentSlot?: EquipmentSlotDTO | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  trainedSkill?: string | undefined;
  storageSlotDefinition?: StorageSlotDefinitionsDTO | undefined;
  weight?: number | undefined;
}

export interface ItemsDTO {
  items: ItemDTO[];
}

/** ####################################################################################### */
export interface ItemActionsDTO {
  actions: string[];
}

/** ####################################################################################### */
export interface StorageSlotDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  grid: number[];
  gridState: StorageGridDTO | undefined;
  maxWeight: number;
  parentItem?: ItemDTO | undefined;
  storedItems?: ItemsDTO | undefined;
  targetEntity: string;
}

export interface StorageSlotsDTO {
  storageSlots: StorageSlotDTO[];
}

/** ####################################################################################### */
export interface StorageGridDTO {
  cells: StorageGridCellDTO[];
}

/** ####################################################################################### */
export interface StorageGridCellDTO {
  row: number;
  column: number;
  value: string;
}

/** ####################################################################################### */
export interface ItemRequirementDTO {
  /** The outer "type" key */
  type: string;
  /** The inner "name" key */
  name: string;
  /** Numerical value */
  number?:
    | number
    | undefined;
  /** Boolean value */
  flag?: boolean | undefined;
}

export interface ItemRequirementsDTO {
  requirements: ItemRequirementDTO[];
}

/** ####################################################################################### */
export interface CharacterDTO {
  id: string;
  blueprintId: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  firstName: string;
  lastName: string;
  race: RaceDTO | undefined;
  gender: string;
  birthsign: BirthsignDTO | undefined;
  birthYear?: number | undefined;
  birthMonth?: string | undefined;
  birthDay?: number | undefined;
  skills: { [key: string]: number };
  equipmentSlots?: EquipmentSlotsDTO | undefined;
  professions?: CharacterProfessionsDTO | undefined;
  memoryPools?: MemoryPoolsDTO | undefined;
  characterMemories?: CharacterMemoriesDTO | undefined;
  enneagramType: string;
  traits?: TraitsDTO | undefined;
  diseases?: DiseasesDTO | undefined;
  addictions?: AddictionsDTO | undefined;
  factions?: FactionsDTO | undefined;
  tags?: TagsDTO | undefined;
  targetEntity: string;
}

export interface CharacterDTO_SkillsEntry {
  key: string;
  value: number;
}

export interface CharactersDTO {
  characters: CharacterDTO[];
}

/** ####################################################################################### */
export interface AddictionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  character?: CharacterDTO | undefined;
  characters?: CharactersDTO | undefined;
  targetEntity: string;
}

export interface AddictionsDTO {
  addictions: AddictionDTO[];
}

/** ####################################################################################### */
export interface CharacterMemoryDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  character?: CharacterDTO | undefined;
  factStatus: FactStatusDTO[];
  importance: number;
  resistance: number;
  accumulator: number;
  acquiredAt?: number | undefined;
  lastUpdatedAt?: number | undefined;
  tags?: TagsDTO | undefined;
  memory: MemoryDTO | undefined;
  targetEntity: string;
}

export interface CharacterMemoriesDTO {
  characterMemories: CharacterMemoryDTO[];
}

/** ####################################################################################### */
export interface FactStatusDTO {
  factId: string;
  status: FactStatusEnumDTO;
}

export interface FactStatusesDTO {
  factStatuses: FactStatusDTO[];
}

/** ####################################################################################### */
export interface TagDTO {
  id: string;
  blueprintId: string;
  metadata?: Metadata | undefined;
  label: string;
  subtype: TagSubtypeEnumDTO;
  items?: ItemsDTO | undefined;
  pastExperiences?: PastExperiencesDTO | undefined;
  characterMemories?: CharacterMemoriesDTO | undefined;
  memories?: MemoriesDTO | undefined;
  memoryPools?: MemoryPoolsDTO | undefined;
  skills?: SkillsDTO | undefined;
  traits?: TraitsDTO | undefined;
  characters?: CharactersDTO | undefined;
  characterProfessions?: CharacterProfessionsDTO | undefined;
  diseases?: DiseasesDTO | undefined;
  effects?: EffectsDTO | undefined;
  facts?: FactsDTO | undefined;
  factions?: FactionsDTO | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  targetEntity: string;
}

export interface TagsDTO {
  tags: TagDTO[];
}

/** ####################################################################################### */
export interface SkillDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  tags?: TagsDTO | undefined;
  description: string;
  category: SkillCategoryEnumDTO;
  targetEntity: string;
}

export interface SkillsDTO {
  skills: SkillDTO[];
}

/** ####################################################################################### */
export interface TraitDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  tags?: TagsDTO | undefined;
  targetEntity: string;
}

export interface TraitsDTO {
  traits: TraitDTO[];
}

/** ####################################################################################### */
export interface DiseaseDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  tags?: TagsDTO | undefined;
  description: string;
  severity: string;
  characters?: CharactersDTO | undefined;
  targetEntity: string;
}

export interface DiseasesDTO {
  diseases: DiseaseDTO[];
}

/** ####################################################################################### */
export interface FactDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  tags?: TagsDTO | undefined;
  description: string;
  weight: number;
  memories?: MemoriesDTO | undefined;
  characters?: CharactersDTO | undefined;
  targetEntity: string;
}

export interface FactsDTO {
  facts: FactDTO[];
}

/** ####################################################################################### */
export interface FactionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  tags?: TagsDTO | undefined;
  characters?: CharactersDTO | undefined;
  targetEntity: string;
}

export interface FactionsDTO {
  factions: FactionDTO[];
}

/** ####################################################################################### */
export interface MemoryPoolDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  description?: string | undefined;
  memoryPoolEntries?: MemoryPoolEntriesDTO | undefined;
  characterProfessions?: CharacterProfessionsDTO | undefined;
  tags?: TagsDTO | undefined;
  targetEntity: string;
}

export interface MemoryPoolsDTO {
  memoryPools: MemoryPoolDTO[];
}

/** ####################################################################################### */
export interface MemoryPoolEntryDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  memoryPool?: MemoryPoolDTO | undefined;
  memory?: MemoryDTO | undefined;
  probability: number;
  defaultClarity: number;
  defaultImportance: number;
  targetEntity: string;
}

export interface MemoryPoolEntriesDTO {
  memoryPoolEntries: MemoryPoolEntriesDTO[];
}

/** ####################################################################################### */
export interface CharacterProfessionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  characters?: CharactersDTO | undefined;
  tags?: TagsDTO | undefined;
  memoryPools?: MemoryPoolsDTO | undefined;
  targetEntity: string;
}

export interface CharacterProfessionsDTO {
  professions: CharacterProfessionDTO[];
}

/** ####################################################################################### */
export interface EquipmentSlotDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  allowedEntities: string[];
  equippedItem?: ItemDTO | undefined;
  character?: CharacterDTO | undefined;
  targetEntity: string;
}

export interface EquipmentSlotsDTO {
  equipmentSlots: EquipmentSlotDTO[];
}

/** ####################################################################################### */
export interface BirthsignDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  targetEntity: string;
}

export interface BirthsignsDTO {
  birthSigns: BirthsignDTO[];
}

/** ####################################################################################### */
export interface RaceDTO {
  id: string;
  blueprintId: string;
  name: string;
  equipmentSlotDefinitions?: EquipmentSlotDefinitionsDTO | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  metadata?: Metadata | undefined;
  targetEntity: string;
}

export interface RacesDTO {
  races: RaceDTO[];
}

/** ####################################################################################### */
export interface EquipmentSlotDefinitionDTO {
  name: string;
  allowedEntities: string[];
}

export interface EquipmentSlotDefinitionsDTO {
  equipmentSlotDefinition: EquipmentSlotDefinitionDTO[];
}

/** ####################################################################################### */
export interface StorageSlotDefinitionDTO {
  grid: number[];
  name: string;
  maxWeight: number;
}

export interface StorageSlotDefinitionsDTO {
  definitions: StorageSlotDefinitionDTO[];
}

/** ####################################################################################### */
export interface MoodDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  description: string;
  targetEntity: string;
}

export interface MoodsDTO {
  moods: MoodDTO[];
}

/** ####################################################################################### */
export interface ReligionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  description: string;
  rituals?: ReligionRitualsDTO | undefined;
  tenets?: ReligionTenetsDTO | undefined;
  targetEntity: string;
}

export interface ReligionsDTO {
  moods: ReligionDTO[];
}

/** ####################################################################################### */
export interface ReligionRitualDTO {
  name: string;
  description: string;
}

export interface ReligionRitualsDTO {
  religionRituals: ReligionRitualDTO[];
}

/** ####################################################################################### */
export interface ReligionTenetDTO {
  name: string;
  description: string;
}

export interface ReligionTenetsDTO {
  religionTenets: ReligionTenetDTO[];
}

/** ####################################################################################### */
export interface GridPositionDTO {
  x: number;
  y: number;
}

/** ####################################################################################### */
export interface GenerationInstructionDTO {
  blueprintId?: string | undefined;
  idsAndQuant?: IdAndQuantDTO | undefined;
  simpleProb?: SimpleProbDTO | undefined;
  gaussianProb?: GaussianProbDTO | undefined;
  combinator?: CombinatorDTO | undefined;
}

export interface GenerationInstructionsDTO {
  instructions: GenerationInstructionDTO[];
}

/** ####################################################################################### */
export interface IdAndQuantDTO {
  idAndQuant: { [key: string]: number };
}

export interface IdAndQuantDTO_IdAndQuantEntry {
  key: string;
  value: number;
}

export interface IdsAndQuantsDTO {
  idsAndQuants: IdAndQuantDTO[];
}

/** ####################################################################################### */
export interface CharacterGenInstructionDTO {
  blueprintId: string;
  backgroundBlueprintId: string;
  targetEntity: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  gender?: string | undefined;
  birthEra?: string | undefined;
  birthYear?: number | undefined;
  birthMonth?: string | undefined;
  birthDay?: number | undefined;
  backgroundCustomization?: BackgroundCustomizationDTO | undefined;
  birthSign?: string | undefined;
  id: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
}

export interface CharacterGenInstructions {
  characterGenInstructions: CharacterGenInstructionDTO[];
}

/** ####################################################################################### */
export interface CharacterGroupGenInstructionDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  set: CombinatorDTO | undefined;
  targetEntity: string;
}

export interface CharacterGroupGenInstructionsDTO {
  characterGroupGenInstructions: CharacterGroupGenInstructionDTO[];
}

/** ####################################################################################### */
export interface BackgroundCustomizationDTO {
  race?: GenerationInstructionsDTO | undefined;
  faction?: GenerationInstructionsDTO | undefined;
  disease?: GenerationInstructionsDTO | undefined;
  addiction?: GenerationInstructionsDTO | undefined;
  profession?: GenerationInstructionsDTO | undefined;
  religion?: GenerationInstructionsDTO | undefined;
  itemSets?: GenerationInstructionsDTO | undefined;
  items?: GenerationInstructionsDTO | undefined;
  pastExpChild?: GenerationInstructionsDTO | undefined;
  pastExpAdult?: GenerationInstructionsDTO | undefined;
  skillSets?: GenerationInstructionsDTO | undefined;
  skillAdjustments?: SkillAdjustmentsDTO | undefined;
  personality?: GenerationInstructionsDTO | undefined;
}

/** ####################################################################################### */
export interface SkillAdjustmentsDTO {
  skillAdjustments: { [key: string]: number };
}

export interface SkillAdjustmentsDTO_SkillAdjustmentsEntry {
  key: string;
  value: number;
}

/** ####################################################################################### */
export interface SimpleProbDTO {
  cond: ConditionEnumDTO;
  prob: { [key: string]: number };
  clazz: string;
}

export interface SimpleProbDTO_ProbEntry {
  key: string;
  value: number;
}

/** ####################################################################################### */
export interface GaussianProbDTO {
  blueprintId: string;
  prob: number;
  avgQuan?: number | undefined;
  stDev?: number | undefined;
  skew?: number | undefined;
  clazz: string;
}

/** ####################################################################################### */
export interface CombinatorDTO {
  name?: string | undefined;
  cond: ConditionEnumDTO;
  /** prob must be a float value between 0 and 1 inclusive */
  prob: number;
  instructions: GenerationInstructionDTO[];
  clazz: string;
}

/** ####################################################################################### */
export interface PastExperienceDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  tags?: TagsDTO | undefined;
  type?: string | undefined;
  targetEntity: string;
}

export interface PastExperiencesDTO {
  pastExperiences: PastExperienceDTO[];
}

/** ####################################################################################### */
export interface MemoryDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  tags?: TagsDTO | undefined;
  facts?: FactsDTO | undefined;
  type: MemoryTypeEnumDTO;
  description: string;
  targetEntity: string;
}

export interface MemoriesDTO {
  memories: MemoryDTO[];
}

/** ####################################################################################### */
export interface SkillSetDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  tags?: TagsDTO | undefined;
  skillImprovement: SkillImprovementDTO | undefined;
  targetEntity: string;
}

export interface SkillSetsDTO {
  skillSets: SkillSetDTO[];
}

/** ####################################################################################### */
export interface SkillImprovementDTO {
  skillImprovement: { [key: string]: number };
}

export interface SkillImprovementDTO_SkillImprovementEntry {
  key: string;
  value: number;
}

/** ####################################################################################### */
export interface PersonalityProfileDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  enneagramType: string;
  traits: GenerationInstructionDTO[];
  targetEntity: string;
}

export interface PersonalityProfilesDTO {
  personalityProfiles: PersonalityProfileDTO[];
}

/** ####################################################################################### */
export interface NeedDTO {
  id: string;
  blueprintId: string;
  name: string;
  metadata?: Metadata | undefined;
  user?: UserDTO | undefined;
  campaign?: CampaignDTO | undefined;
  world?: WorldDTO | undefined;
  description: string;
  type: NeedTypeEnumDTO;
  layer: NeedLayerEnumDTO;
  targetEntity: string;
}

export interface NeedsDTO {
  needs: NeedDTO[];
}

/** ####################################################################################### */
export interface UserDTO {
  id: string;
  name: string;
  /** relations */
  worlds?: WorldsDTO | undefined;
  campaigns?: CampaignsDTO | undefined;
  items?: ItemsDTO | undefined;
  pastExperiences?: PastExperiencesDTO | undefined;
  characterMemories?: CharacterMemoriesDTO | undefined;
  memories?: MemoriesDTO | undefined;
  memoryPools?: MemoryPoolsDTO | undefined;
  memoryPoolEntries?: MemoryPoolEntriesDTO | undefined;
  skills?: SkillsDTO | undefined;
  traits?: TraitsDTO | undefined;
  addictions?: AddictionsDTO | undefined;
  birthsigns?: BirthsignsDTO | undefined;
  characters?: CharactersDTO | undefined;
  characterProfessions?: CharacterProfessionsDTO | undefined;
  diseases?: DiseasesDTO | undefined;
  effects?: EffectsDTO | undefined;
  facts?: FactsDTO | undefined;
  factions?: FactionsDTO | undefined;
  storageSlots?: StorageSlotsDTO | undefined;
  equipmentSlots?: EquipmentSlotsDTO | undefined;
  itemSets?: ItemSetsDTO | undefined;
  moods?: MoodsDTO | undefined;
  needs?: NeedsDTO | undefined;
  personalityProfiles?: PersonalityProfilesDTO | undefined;
  races?: RacesDTO | undefined;
  religions?: ReligionsDTO | undefined;
  resistances?: ResistancesDTO | undefined;
  statuses?: StatusesDTO | undefined;
  tags?: TagsDTO | undefined;
  backgrounds?: BackgroundsDTO | undefined;
}

export interface UsersDTO {
  users: UserDTO[];
}

/** ####################################################################################### */
export interface WorldSettings {
  settings: { [key: string]: string };
}

export interface WorldSettings_SettingsEntry {
  key: string;
  value: string;
}

/** ####################################################################################### */
export interface WorldDTO {
  id: string;
  name: string;
  description: string;
  settings?: WorldSettings | undefined;
  frozen: boolean;
  /** relations */
  user?: UserDTO | undefined;
  campaigns?: CampaignsDTO | undefined;
  items?: ItemsDTO | undefined;
  pastExperiences?: PastExperiencesDTO | undefined;
  characterMemories?: CharacterMemoriesDTO | undefined;
  memories?: MemoriesDTO | undefined;
  memoryPools?: MemoryPoolsDTO | undefined;
  memoryPoolEntries?: MemoryPoolEntriesDTO | undefined;
  skills?: SkillsDTO | undefined;
  traits?: TraitsDTO | undefined;
  addictions?: AddictionsDTO | undefined;
  birthsigns?: BirthsignsDTO | undefined;
  characters?: CharactersDTO | undefined;
  characterProfessions?: CharacterProfessionsDTO | undefined;
  diseases?: DiseasesDTO | undefined;
  effects?: EffectsDTO | undefined;
  facts?: FactsDTO | undefined;
  factions?: FactionsDTO | undefined;
  storageSlots?: StorageSlotsDTO | undefined;
  equipmentSlots?: EquipmentSlotsDTO | undefined;
  itemSets?: ItemSetsDTO | undefined;
  moods?: MoodsDTO | undefined;
  needs?: NeedsDTO | undefined;
  personalityProfiles?: PersonalityProfilesDTO | undefined;
  races?: RacesDTO | undefined;
  religions?: ReligionsDTO | undefined;
  resistances?: ResistancesDTO | undefined;
  statuses?: StatusesDTO | undefined;
  tags?: TagsDTO | undefined;
  backgrounds?: BackgroundsDTO | undefined;
}

export interface WorldsDTO {
  worlds: WorldDTO[];
}

/** ####################################################################################### */
export interface CampaignDTO {
  id: string;
  name: string;
  description: string;
  dynamicState: { [key: string]: string };
  createdAt: string;
  world?: WorldDTO | undefined;
  user?:
    | UserDTO
    | undefined;
  /** relations */
  items?: ItemsDTO | undefined;
  pastExperiences?: PastExperiencesDTO | undefined;
  characterMemories?: CharacterMemoriesDTO | undefined;
  memories?: MemoriesDTO | undefined;
  memoryPools?: MemoryPoolsDTO | undefined;
  memoryPoolEntries?: MemoryPoolEntriesDTO | undefined;
  skills?: SkillsDTO | undefined;
  traits?: TraitsDTO | undefined;
  addictions?: AddictionsDTO | undefined;
  birthsigns?: BirthsignsDTO | undefined;
  characters?: CharactersDTO | undefined;
  characterProfessions?: CharacterProfessionsDTO | undefined;
  diseases?: DiseasesDTO | undefined;
  effects?: EffectsDTO | undefined;
  facts?: FactsDTO | undefined;
  factions?: FactionsDTO | undefined;
  storageSlots?: StorageSlotsDTO | undefined;
  equipmentSlots?: EquipmentSlotsDTO | undefined;
  itemSets?: ItemSetsDTO | undefined;
  moods?: MoodsDTO | undefined;
  needs?: NeedsDTO | undefined;
  personalityProfiles?: PersonalityProfilesDTO | undefined;
  races?: RacesDTO | undefined;
  religions?: ReligionsDTO | undefined;
  resistances?: ResistancesDTO | undefined;
  statuses?: StatusesDTO | undefined;
  tags?: TagsDTO | undefined;
  backgrounds?: BackgroundsDTO | undefined;
}

export interface CampaignDTO_DynamicStateEntry {
  key: string;
  value: string;
}

export interface CampaignsDTO {
  campaigns: CampaignDTO[];
}

function createBaseBackgroundDTO(): BackgroundDTO {
  return {
    id: "",
    name: "",
    faction: undefined,
    disease: undefined,
    addiction: undefined,
    profession: undefined,
    race: undefined,
    religion: undefined,
    personality: undefined,
    items: undefined,
    pastExpChild: undefined,
    pastExpAdult: undefined,
    memoryPools: undefined,
    skillSets: [],
    skillAdjustments: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    targetEntity: "",
  };
}

export const BackgroundDTO: MessageFns<BackgroundDTO> = {
  encode(message: BackgroundDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.faction !== undefined) {
      GenerationInstructionsDTO.encode(message.faction, writer.uint32(26).fork()).join();
    }
    if (message.disease !== undefined) {
      GenerationInstructionsDTO.encode(message.disease, writer.uint32(34).fork()).join();
    }
    if (message.addiction !== undefined) {
      GenerationInstructionsDTO.encode(message.addiction, writer.uint32(42).fork()).join();
    }
    if (message.profession !== undefined) {
      GenerationInstructionsDTO.encode(message.profession, writer.uint32(50).fork()).join();
    }
    if (message.race !== undefined) {
      GenerationInstructionsDTO.encode(message.race, writer.uint32(58).fork()).join();
    }
    if (message.religion !== undefined) {
      GenerationInstructionsDTO.encode(message.religion, writer.uint32(66).fork()).join();
    }
    if (message.personality !== undefined) {
      GenerationInstructionsDTO.encode(message.personality, writer.uint32(74).fork()).join();
    }
    if (message.items !== undefined) {
      GenerationInstructionsDTO.encode(message.items, writer.uint32(82).fork()).join();
    }
    if (message.pastExpChild !== undefined) {
      GenerationInstructionsDTO.encode(message.pastExpChild, writer.uint32(90).fork()).join();
    }
    if (message.pastExpAdult !== undefined) {
      GenerationInstructionsDTO.encode(message.pastExpAdult, writer.uint32(98).fork()).join();
    }
    if (message.memoryPools !== undefined) {
      GenerationInstructionsDTO.encode(message.memoryPools, writer.uint32(106).fork()).join();
    }
    for (const v of message.skillSets) {
      writer.uint32(114).string(v!);
    }
    Object.entries(message.skillAdjustments).forEach(([key, value]) => {
      BackgroundDTO_SkillAdjustmentsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(130).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(138).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(146).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(154).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.faction = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.disease = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addiction = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.profession = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.race = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.religion = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.personality = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.items = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.pastExpChild = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.pastExpAdult = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.memoryPools = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.skillSets.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = BackgroundDTO_SkillAdjustmentsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.skillAdjustments[entry15.key] = entry15.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      faction: isSet(object.faction) ? GenerationInstructionsDTO.fromJSON(object.faction) : undefined,
      disease: isSet(object.disease) ? GenerationInstructionsDTO.fromJSON(object.disease) : undefined,
      addiction: isSet(object.addiction) ? GenerationInstructionsDTO.fromJSON(object.addiction) : undefined,
      profession: isSet(object.profession) ? GenerationInstructionsDTO.fromJSON(object.profession) : undefined,
      race: isSet(object.race) ? GenerationInstructionsDTO.fromJSON(object.race) : undefined,
      religion: isSet(object.religion) ? GenerationInstructionsDTO.fromJSON(object.religion) : undefined,
      personality: isSet(object.personality) ? GenerationInstructionsDTO.fromJSON(object.personality) : undefined,
      items: isSet(object.items) ? GenerationInstructionsDTO.fromJSON(object.items) : undefined,
      pastExpChild: isSet(object.pastExpChild) ? GenerationInstructionsDTO.fromJSON(object.pastExpChild) : undefined,
      pastExpAdult: isSet(object.pastExpAdult) ? GenerationInstructionsDTO.fromJSON(object.pastExpAdult) : undefined,
      memoryPools: isSet(object.memoryPools) ? GenerationInstructionsDTO.fromJSON(object.memoryPools) : undefined,
      skillSets: globalThis.Array.isArray(object?.skillSets)
        ? object.skillSets.map((e: any) => globalThis.String(e))
        : [],
      skillAdjustments: isObject(object.skillAdjustments)
        ? Object.entries(object.skillAdjustments).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: BackgroundDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.faction !== undefined) {
      obj.faction = GenerationInstructionsDTO.toJSON(message.faction);
    }
    if (message.disease !== undefined) {
      obj.disease = GenerationInstructionsDTO.toJSON(message.disease);
    }
    if (message.addiction !== undefined) {
      obj.addiction = GenerationInstructionsDTO.toJSON(message.addiction);
    }
    if (message.profession !== undefined) {
      obj.profession = GenerationInstructionsDTO.toJSON(message.profession);
    }
    if (message.race !== undefined) {
      obj.race = GenerationInstructionsDTO.toJSON(message.race);
    }
    if (message.religion !== undefined) {
      obj.religion = GenerationInstructionsDTO.toJSON(message.religion);
    }
    if (message.personality !== undefined) {
      obj.personality = GenerationInstructionsDTO.toJSON(message.personality);
    }
    if (message.items !== undefined) {
      obj.items = GenerationInstructionsDTO.toJSON(message.items);
    }
    if (message.pastExpChild !== undefined) {
      obj.pastExpChild = GenerationInstructionsDTO.toJSON(message.pastExpChild);
    }
    if (message.pastExpAdult !== undefined) {
      obj.pastExpAdult = GenerationInstructionsDTO.toJSON(message.pastExpAdult);
    }
    if (message.memoryPools !== undefined) {
      obj.memoryPools = GenerationInstructionsDTO.toJSON(message.memoryPools);
    }
    if (message.skillSets?.length) {
      obj.skillSets = message.skillSets;
    }
    if (message.skillAdjustments) {
      const entries = Object.entries(message.skillAdjustments);
      if (entries.length > 0) {
        obj.skillAdjustments = {};
        entries.forEach(([k, v]) => {
          obj.skillAdjustments[k] = Math.round(v);
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundDTO>, I>>(base?: I): BackgroundDTO {
    return BackgroundDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundDTO>, I>>(object: I): BackgroundDTO {
    const message = createBaseBackgroundDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.faction = (object.faction !== undefined && object.faction !== null)
      ? GenerationInstructionsDTO.fromPartial(object.faction)
      : undefined;
    message.disease = (object.disease !== undefined && object.disease !== null)
      ? GenerationInstructionsDTO.fromPartial(object.disease)
      : undefined;
    message.addiction = (object.addiction !== undefined && object.addiction !== null)
      ? GenerationInstructionsDTO.fromPartial(object.addiction)
      : undefined;
    message.profession = (object.profession !== undefined && object.profession !== null)
      ? GenerationInstructionsDTO.fromPartial(object.profession)
      : undefined;
    message.race = (object.race !== undefined && object.race !== null)
      ? GenerationInstructionsDTO.fromPartial(object.race)
      : undefined;
    message.religion = (object.religion !== undefined && object.religion !== null)
      ? GenerationInstructionsDTO.fromPartial(object.religion)
      : undefined;
    message.personality = (object.personality !== undefined && object.personality !== null)
      ? GenerationInstructionsDTO.fromPartial(object.personality)
      : undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? GenerationInstructionsDTO.fromPartial(object.items)
      : undefined;
    message.pastExpChild = (object.pastExpChild !== undefined && object.pastExpChild !== null)
      ? GenerationInstructionsDTO.fromPartial(object.pastExpChild)
      : undefined;
    message.pastExpAdult = (object.pastExpAdult !== undefined && object.pastExpAdult !== null)
      ? GenerationInstructionsDTO.fromPartial(object.pastExpAdult)
      : undefined;
    message.memoryPools = (object.memoryPools !== undefined && object.memoryPools !== null)
      ? GenerationInstructionsDTO.fromPartial(object.memoryPools)
      : undefined;
    message.skillSets = object.skillSets?.map((e) => e) || [];
    message.skillAdjustments = Object.entries(object.skillAdjustments ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseBackgroundDTO_SkillAdjustmentsEntry(): BackgroundDTO_SkillAdjustmentsEntry {
  return { key: "", value: 0 };
}

export const BackgroundDTO_SkillAdjustmentsEntry: MessageFns<BackgroundDTO_SkillAdjustmentsEntry> = {
  encode(message: BackgroundDTO_SkillAdjustmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundDTO_SkillAdjustmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundDTO_SkillAdjustmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundDTO_SkillAdjustmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: BackgroundDTO_SkillAdjustmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundDTO_SkillAdjustmentsEntry>, I>>(
    base?: I,
  ): BackgroundDTO_SkillAdjustmentsEntry {
    return BackgroundDTO_SkillAdjustmentsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundDTO_SkillAdjustmentsEntry>, I>>(
    object: I,
  ): BackgroundDTO_SkillAdjustmentsEntry {
    const message = createBaseBackgroundDTO_SkillAdjustmentsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseBackgroundsDTO(): BackgroundsDTO {
  return { backgrounds: [] };
}

export const BackgroundsDTO: MessageFns<BackgroundsDTO> = {
  encode(message: BackgroundsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.backgrounds) {
      BackgroundDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.backgrounds.push(BackgroundDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundsDTO {
    return {
      backgrounds: globalThis.Array.isArray(object?.backgrounds)
        ? object.backgrounds.map((e: any) => BackgroundDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BackgroundsDTO): unknown {
    const obj: any = {};
    if (message.backgrounds?.length) {
      obj.backgrounds = message.backgrounds.map((e) => BackgroundDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundsDTO>, I>>(base?: I): BackgroundsDTO {
    return BackgroundsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundsDTO>, I>>(object: I): BackgroundsDTO {
    const message = createBaseBackgroundsDTO();
    message.backgrounds = object.backgrounds?.map((e) => BackgroundDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMetadata(): Metadata {
  return { metadata: {} };
}

export const Metadata: MessageFns<Metadata> = {
  encode(message: Metadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.metadata).forEach(([key, value]) => {
      Metadata_MetadataEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = Metadata_MetadataEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.metadata[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata>, I>>(base?: I): Metadata {
    return Metadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata>, I>>(object: I): Metadata {
    const message = createBaseMetadata();
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMetadata_MetadataEntry(): Metadata_MetadataEntry {
  return { key: "", value: "" };
}

export const Metadata_MetadataEntry: MessageFns<Metadata_MetadataEntry> = {
  encode(message: Metadata_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Metadata_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Metadata_MetadataEntry>, I>>(base?: I): Metadata_MetadataEntry {
    return Metadata_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Metadata_MetadataEntry>, I>>(object: I): Metadata_MetadataEntry {
    const message = createBaseMetadata_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEffectDTO(): EffectDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    type: 0,
    target: 0,
    mode: 0,
    element: undefined,
    targetEntity: "",
  };
}

export const EffectDTO: MessageFns<EffectDTO> = {
  encode(message: EffectDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.target !== 0) {
      writer.uint32(80).int32(message.target);
    }
    if (message.mode !== 0) {
      writer.uint32(88).int32(message.mode);
    }
    if (message.element !== undefined) {
      writer.uint32(96).int32(message.element);
    }
    if (message.targetEntity !== "") {
      writer.uint32(106).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.element = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      type: isSet(object.type) ? effectTypeEnumDTOFromJSON(object.type) : 0,
      target: isSet(object.target) ? effectTargetEnumDTOFromJSON(object.target) : 0,
      mode: isSet(object.mode) ? effectModeEnumDTOFromJSON(object.mode) : 0,
      element: isSet(object.element) ? effectElementEnumDTOFromJSON(object.element) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: EffectDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.type !== 0) {
      obj.type = effectTypeEnumDTOToJSON(message.type);
    }
    if (message.target !== 0) {
      obj.target = effectTargetEnumDTOToJSON(message.target);
    }
    if (message.mode !== 0) {
      obj.mode = effectModeEnumDTOToJSON(message.mode);
    }
    if (message.element !== undefined) {
      obj.element = effectElementEnumDTOToJSON(message.element);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectDTO>, I>>(base?: I): EffectDTO {
    return EffectDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectDTO>, I>>(object: I): EffectDTO {
    const message = createBaseEffectDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.type = object.type ?? 0;
    message.target = object.target ?? 0;
    message.mode = object.mode ?? 0;
    message.element = object.element ?? undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseEffectsDTO(): EffectsDTO {
  return { effects: [] };
}

export const EffectsDTO: MessageFns<EffectsDTO> = {
  encode(message: EffectsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.effects) {
      EffectDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EffectsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffectsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.effects.push(EffectDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EffectsDTO {
    return {
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => EffectDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: EffectsDTO): unknown {
    const obj: any = {};
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => EffectDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EffectsDTO>, I>>(base?: I): EffectsDTO {
    return EffectsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EffectsDTO>, I>>(object: I): EffectsDTO {
    const message = createBaseEffectsDTO();
    message.effects = object.effects?.map((e) => EffectDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResistanceDTO(): ResistanceDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    effectType: 0,
    targetEffect: undefined,
    targetEntity: "",
  };
}

export const ResistanceDTO: MessageFns<ResistanceDTO> = {
  encode(message: ResistanceDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.effectType !== 0) {
      writer.uint32(64).int32(message.effectType);
    }
    if (message.targetEffect !== undefined) {
      writer.uint32(74).string(message.targetEffect);
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResistanceDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResistanceDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.effectType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEffect = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResistanceDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      effectType: isSet(object.effectType) ? effectTypeEnumDTOFromJSON(object.effectType) : 0,
      targetEffect: isSet(object.targetEffect) ? globalThis.String(object.targetEffect) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: ResistanceDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.effectType !== 0) {
      obj.effectType = effectTypeEnumDTOToJSON(message.effectType);
    }
    if (message.targetEffect !== undefined) {
      obj.targetEffect = message.targetEffect;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResistanceDTO>, I>>(base?: I): ResistanceDTO {
    return ResistanceDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResistanceDTO>, I>>(object: I): ResistanceDTO {
    const message = createBaseResistanceDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.effectType = object.effectType ?? 0;
    message.targetEffect = object.targetEffect ?? undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseResistancesDTO(): ResistancesDTO {
  return { resistances: [] };
}

export const ResistancesDTO: MessageFns<ResistancesDTO> = {
  encode(message: ResistancesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.resistances) {
      ResistanceDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResistancesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResistancesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resistances.push(ResistanceDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResistancesDTO {
    return {
      resistances: globalThis.Array.isArray(object?.resistances)
        ? object.resistances.map((e: any) => ResistanceDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ResistancesDTO): unknown {
    const obj: any = {};
    if (message.resistances?.length) {
      obj.resistances = message.resistances.map((e) => ResistanceDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResistancesDTO>, I>>(base?: I): ResistancesDTO {
    return ResistancesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResistancesDTO>, I>>(object: I): ResistancesDTO {
    const message = createBaseResistancesDTO();
    message.resistances = object.resistances?.map((e) => ResistanceDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStatusDTO(): StatusDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    type: 0,
    effects: [],
    duration: 0,
    description: "",
    targetEntity: "",
  };
}

export const StatusDTO: MessageFns<StatusDTO> = {
  encode(message: StatusDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    for (const v of message.effects) {
      writer.uint32(74).string(v!);
    }
    if (message.duration !== 0) {
      writer.uint32(80).int32(message.duration);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.targetEntity !== "") {
      writer.uint32(98).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.effects.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      type: isSet(object.type) ? effectTypeEnumDTOFromJSON(object.type) : 0,
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => globalThis.String(e)) : [],
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: StatusDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.type !== 0) {
      obj.type = effectTypeEnumDTOToJSON(message.type);
    }
    if (message.effects?.length) {
      obj.effects = message.effects;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusDTO>, I>>(base?: I): StatusDTO {
    return StatusDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusDTO>, I>>(object: I): StatusDTO {
    const message = createBaseStatusDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.type = object.type ?? 0;
    message.effects = object.effects?.map((e) => e) || [];
    message.duration = object.duration ?? 0;
    message.description = object.description ?? "";
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseStatusesDTO(): StatusesDTO {
  return { statuses: [] };
}

export const StatusesDTO: MessageFns<StatusesDTO> = {
  encode(message: StatusesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.statuses) {
      StatusDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StatusesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatusesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statuses.push(StatusDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StatusesDTO {
    return {
      statuses: globalThis.Array.isArray(object?.statuses)
        ? object.statuses.map((e: any) => StatusDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StatusesDTO): unknown {
    const obj: any = {};
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => StatusDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StatusesDTO>, I>>(base?: I): StatusesDTO {
    return StatusesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StatusesDTO>, I>>(object: I): StatusesDTO {
    const message = createBaseStatusesDTO();
    message.statuses = object.statuses?.map((e) => StatusDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItemSetDTO(): ItemSetDTO {
  return {
    id: "",
    blueprintId: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    set: undefined,
    targetEntity: "",
  };
}

export const ItemSetDTO: MessageFns<ItemSetDTO> = {
  encode(message: ItemSetDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(34).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(42).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(50).fork()).join();
    }
    if (message.set !== undefined) {
      GenerationInstructionDTO.encode(message.set, writer.uint32(58).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(66).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemSetDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemSetDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.set = GenerationInstructionDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemSetDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      set: isSet(object.set) ? GenerationInstructionDTO.fromJSON(object.set) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: ItemSetDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.set !== undefined) {
      obj.set = GenerationInstructionDTO.toJSON(message.set);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemSetDTO>, I>>(base?: I): ItemSetDTO {
    return ItemSetDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemSetDTO>, I>>(object: I): ItemSetDTO {
    const message = createBaseItemSetDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.set = (object.set !== undefined && object.set !== null)
      ? GenerationInstructionDTO.fromPartial(object.set)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseItemSetsDTO(): ItemSetsDTO {
  return { itemSets: [] };
}

export const ItemSetsDTO: MessageFns<ItemSetsDTO> = {
  encode(message: ItemSetsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.itemSets) {
      ItemSetDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemSetsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemSetsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.itemSets.push(ItemSetDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemSetsDTO {
    return {
      itemSets: globalThis.Array.isArray(object?.itemSets)
        ? object.itemSets.map((e: any) => ItemSetDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ItemSetsDTO): unknown {
    const obj: any = {};
    if (message.itemSets?.length) {
      obj.itemSets = message.itemSets.map((e) => ItemSetDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemSetsDTO>, I>>(base?: I): ItemSetsDTO {
    return ItemSetsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemSetsDTO>, I>>(object: I): ItemSetsDTO {
    const message = createBaseItemSetsDTO();
    message.itemSets = object.itemSets?.map((e) => ItemSetDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItemDTO(): ItemDTO {
  return {
    blueprintId: "",
    metadata: undefined,
    targetEntity: "",
    id: "",
    name: "",
    description: "",
    size: [],
    quantity: undefined,
    maxQuantity: undefined,
    baseValue: undefined,
    actions: undefined,
    requirements: undefined,
    stackable: undefined,
    repairable: undefined,
    drinkable: undefined,
    edible: undefined,
    gridPosition: undefined,
    durability: undefined,
    maxDurability: undefined,
    damagePierce: undefined,
    armorClass: undefined,
    stealthDisadvantage: undefined,
    damageSlash: undefined,
    damageBlunt: undefined,
    range: undefined,
    twoHanded: undefined,
    nutrition: undefined,
    spoilage: undefined,
    thirstQuenched: undefined,
    type: undefined,
    storageSlot: undefined,
    storageSlots: undefined,
    equipmentSlot: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    trainedSkill: undefined,
    storageSlotDefinition: undefined,
    weight: undefined,
  };
}

export const ItemDTO: MessageFns<ItemDTO> = {
  encode(message: ItemDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(18).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(26).string(message.targetEntity);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    writer.uint32(58).fork();
    for (const v of message.size) {
      writer.int32(v);
    }
    writer.join();
    if (message.quantity !== undefined) {
      writer.uint32(64).int32(message.quantity);
    }
    if (message.maxQuantity !== undefined) {
      writer.uint32(72).int32(message.maxQuantity);
    }
    if (message.baseValue !== undefined) {
      writer.uint32(80).int32(message.baseValue);
    }
    if (message.actions !== undefined) {
      ItemActionsDTO.encode(message.actions, writer.uint32(90).fork()).join();
    }
    if (message.requirements !== undefined) {
      ItemRequirementsDTO.encode(message.requirements, writer.uint32(98).fork()).join();
    }
    if (message.stackable !== undefined) {
      writer.uint32(104).bool(message.stackable);
    }
    if (message.repairable !== undefined) {
      writer.uint32(112).bool(message.repairable);
    }
    if (message.drinkable !== undefined) {
      writer.uint32(120).bool(message.drinkable);
    }
    if (message.edible !== undefined) {
      writer.uint32(128).bool(message.edible);
    }
    if (message.gridPosition !== undefined) {
      GridPositionDTO.encode(message.gridPosition, writer.uint32(138).fork()).join();
    }
    if (message.durability !== undefined) {
      writer.uint32(144).int32(message.durability);
    }
    if (message.maxDurability !== undefined) {
      writer.uint32(152).int32(message.maxDurability);
    }
    if (message.damagePierce !== undefined) {
      writer.uint32(162).string(message.damagePierce);
    }
    if (message.armorClass !== undefined) {
      writer.uint32(168).int32(message.armorClass);
    }
    if (message.stealthDisadvantage !== undefined) {
      writer.uint32(176).bool(message.stealthDisadvantage);
    }
    if (message.damageSlash !== undefined) {
      writer.uint32(186).string(message.damageSlash);
    }
    if (message.damageBlunt !== undefined) {
      writer.uint32(194).string(message.damageBlunt);
    }
    if (message.range !== undefined) {
      writer.uint32(200).int32(message.range);
    }
    if (message.twoHanded !== undefined) {
      writer.uint32(208).bool(message.twoHanded);
    }
    if (message.nutrition !== undefined) {
      writer.uint32(216).int32(message.nutrition);
    }
    if (message.spoilage !== undefined) {
      writer.uint32(224).int32(message.spoilage);
    }
    if (message.thirstQuenched !== undefined) {
      writer.uint32(232).int32(message.thirstQuenched);
    }
    if (message.type !== undefined) {
      writer.uint32(242).string(message.type);
    }
    if (message.storageSlot !== undefined) {
      StorageSlotDTO.encode(message.storageSlot, writer.uint32(250).fork()).join();
    }
    if (message.storageSlots !== undefined) {
      StorageSlotsDTO.encode(message.storageSlots, writer.uint32(258).fork()).join();
    }
    if (message.equipmentSlot !== undefined) {
      EquipmentSlotDTO.encode(message.equipmentSlot, writer.uint32(266).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(274).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(282).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(290).fork()).join();
    }
    if (message.trainedSkill !== undefined) {
      writer.uint32(298).string(message.trainedSkill);
    }
    if (message.storageSlotDefinition !== undefined) {
      StorageSlotDefinitionsDTO.encode(message.storageSlotDefinition, writer.uint32(306).fork()).join();
    }
    if (message.weight !== undefined) {
      writer.uint32(317).float(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.size.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.size.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxQuantity = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.baseValue = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.actions = ItemActionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.requirements = ItemRequirementsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.stackable = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.repairable = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.drinkable = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.edible = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.gridPosition = GridPositionDTO.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.durability = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.maxDurability = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.damagePierce = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.armorClass = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.stealthDisadvantage = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.damageSlash = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.damageBlunt = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.range = reader.int32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.twoHanded = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.nutrition = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.spoilage = reader.int32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.thirstQuenched = reader.int32();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.storageSlot = StorageSlotDTO.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.storageSlots = StorageSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.equipmentSlot = EquipmentSlotDTO.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.trainedSkill = reader.string();
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.storageSlotDefinition = StorageSlotDefinitionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 39: {
          if (tag !== 317) {
            break;
          }

          message.weight = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemDTO {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      size: globalThis.Array.isArray(object?.size) ? object.size.map((e: any) => globalThis.Number(e)) : [],
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : undefined,
      maxQuantity: isSet(object.maxQuantity) ? globalThis.Number(object.maxQuantity) : undefined,
      baseValue: isSet(object.baseValue) ? globalThis.Number(object.baseValue) : undefined,
      actions: isSet(object.actions) ? ItemActionsDTO.fromJSON(object.actions) : undefined,
      requirements: isSet(object.requirements) ? ItemRequirementsDTO.fromJSON(object.requirements) : undefined,
      stackable: isSet(object.stackable) ? globalThis.Boolean(object.stackable) : undefined,
      repairable: isSet(object.repairable) ? globalThis.Boolean(object.repairable) : undefined,
      drinkable: isSet(object.drinkable) ? globalThis.Boolean(object.drinkable) : undefined,
      edible: isSet(object.edible) ? globalThis.Boolean(object.edible) : undefined,
      gridPosition: isSet(object.gridPosition) ? GridPositionDTO.fromJSON(object.gridPosition) : undefined,
      durability: isSet(object.durability) ? globalThis.Number(object.durability) : undefined,
      maxDurability: isSet(object.maxDurability) ? globalThis.Number(object.maxDurability) : undefined,
      damagePierce: isSet(object.damagePierce) ? globalThis.String(object.damagePierce) : undefined,
      armorClass: isSet(object.armorClass) ? globalThis.Number(object.armorClass) : undefined,
      stealthDisadvantage: isSet(object.stealthDisadvantage)
        ? globalThis.Boolean(object.stealthDisadvantage)
        : undefined,
      damageSlash: isSet(object.damageSlash) ? globalThis.String(object.damageSlash) : undefined,
      damageBlunt: isSet(object.damageBlunt) ? globalThis.String(object.damageBlunt) : undefined,
      range: isSet(object.range) ? globalThis.Number(object.range) : undefined,
      twoHanded: isSet(object.twoHanded) ? globalThis.Boolean(object.twoHanded) : undefined,
      nutrition: isSet(object.nutrition) ? globalThis.Number(object.nutrition) : undefined,
      spoilage: isSet(object.spoilage) ? globalThis.Number(object.spoilage) : undefined,
      thirstQuenched: isSet(object.thirstQuenched) ? globalThis.Number(object.thirstQuenched) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      storageSlot: isSet(object.storageSlot) ? StorageSlotDTO.fromJSON(object.storageSlot) : undefined,
      storageSlots: isSet(object.storageSlots) ? StorageSlotsDTO.fromJSON(object.storageSlots) : undefined,
      equipmentSlot: isSet(object.equipmentSlot) ? EquipmentSlotDTO.fromJSON(object.equipmentSlot) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      trainedSkill: isSet(object.trainedSkill) ? globalThis.String(object.trainedSkill) : undefined,
      storageSlotDefinition: isSet(object.storageSlotDefinition)
        ? StorageSlotDefinitionsDTO.fromJSON(object.storageSlotDefinition)
        : undefined,
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
    };
  },

  toJSON(message: ItemDTO): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.size?.length) {
      obj.size = message.size.map((e) => Math.round(e));
    }
    if (message.quantity !== undefined) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.maxQuantity !== undefined) {
      obj.maxQuantity = Math.round(message.maxQuantity);
    }
    if (message.baseValue !== undefined) {
      obj.baseValue = Math.round(message.baseValue);
    }
    if (message.actions !== undefined) {
      obj.actions = ItemActionsDTO.toJSON(message.actions);
    }
    if (message.requirements !== undefined) {
      obj.requirements = ItemRequirementsDTO.toJSON(message.requirements);
    }
    if (message.stackable !== undefined) {
      obj.stackable = message.stackable;
    }
    if (message.repairable !== undefined) {
      obj.repairable = message.repairable;
    }
    if (message.drinkable !== undefined) {
      obj.drinkable = message.drinkable;
    }
    if (message.edible !== undefined) {
      obj.edible = message.edible;
    }
    if (message.gridPosition !== undefined) {
      obj.gridPosition = GridPositionDTO.toJSON(message.gridPosition);
    }
    if (message.durability !== undefined) {
      obj.durability = Math.round(message.durability);
    }
    if (message.maxDurability !== undefined) {
      obj.maxDurability = Math.round(message.maxDurability);
    }
    if (message.damagePierce !== undefined) {
      obj.damagePierce = message.damagePierce;
    }
    if (message.armorClass !== undefined) {
      obj.armorClass = Math.round(message.armorClass);
    }
    if (message.stealthDisadvantage !== undefined) {
      obj.stealthDisadvantage = message.stealthDisadvantage;
    }
    if (message.damageSlash !== undefined) {
      obj.damageSlash = message.damageSlash;
    }
    if (message.damageBlunt !== undefined) {
      obj.damageBlunt = message.damageBlunt;
    }
    if (message.range !== undefined) {
      obj.range = Math.round(message.range);
    }
    if (message.twoHanded !== undefined) {
      obj.twoHanded = message.twoHanded;
    }
    if (message.nutrition !== undefined) {
      obj.nutrition = Math.round(message.nutrition);
    }
    if (message.spoilage !== undefined) {
      obj.spoilage = Math.round(message.spoilage);
    }
    if (message.thirstQuenched !== undefined) {
      obj.thirstQuenched = Math.round(message.thirstQuenched);
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.storageSlot !== undefined) {
      obj.storageSlot = StorageSlotDTO.toJSON(message.storageSlot);
    }
    if (message.storageSlots !== undefined) {
      obj.storageSlots = StorageSlotsDTO.toJSON(message.storageSlots);
    }
    if (message.equipmentSlot !== undefined) {
      obj.equipmentSlot = EquipmentSlotDTO.toJSON(message.equipmentSlot);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.trainedSkill !== undefined) {
      obj.trainedSkill = message.trainedSkill;
    }
    if (message.storageSlotDefinition !== undefined) {
      obj.storageSlotDefinition = StorageSlotDefinitionsDTO.toJSON(message.storageSlotDefinition);
    }
    if (message.weight !== undefined) {
      obj.weight = message.weight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemDTO>, I>>(base?: I): ItemDTO {
    return ItemDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemDTO>, I>>(object: I): ItemDTO {
    const message = createBaseItemDTO();
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.size = object.size?.map((e) => e) || [];
    message.quantity = object.quantity ?? undefined;
    message.maxQuantity = object.maxQuantity ?? undefined;
    message.baseValue = object.baseValue ?? undefined;
    message.actions = (object.actions !== undefined && object.actions !== null)
      ? ItemActionsDTO.fromPartial(object.actions)
      : undefined;
    message.requirements = (object.requirements !== undefined && object.requirements !== null)
      ? ItemRequirementsDTO.fromPartial(object.requirements)
      : undefined;
    message.stackable = object.stackable ?? undefined;
    message.repairable = object.repairable ?? undefined;
    message.drinkable = object.drinkable ?? undefined;
    message.edible = object.edible ?? undefined;
    message.gridPosition = (object.gridPosition !== undefined && object.gridPosition !== null)
      ? GridPositionDTO.fromPartial(object.gridPosition)
      : undefined;
    message.durability = object.durability ?? undefined;
    message.maxDurability = object.maxDurability ?? undefined;
    message.damagePierce = object.damagePierce ?? undefined;
    message.armorClass = object.armorClass ?? undefined;
    message.stealthDisadvantage = object.stealthDisadvantage ?? undefined;
    message.damageSlash = object.damageSlash ?? undefined;
    message.damageBlunt = object.damageBlunt ?? undefined;
    message.range = object.range ?? undefined;
    message.twoHanded = object.twoHanded ?? undefined;
    message.nutrition = object.nutrition ?? undefined;
    message.spoilage = object.spoilage ?? undefined;
    message.thirstQuenched = object.thirstQuenched ?? undefined;
    message.type = object.type ?? undefined;
    message.storageSlot = (object.storageSlot !== undefined && object.storageSlot !== null)
      ? StorageSlotDTO.fromPartial(object.storageSlot)
      : undefined;
    message.storageSlots = (object.storageSlots !== undefined && object.storageSlots !== null)
      ? StorageSlotsDTO.fromPartial(object.storageSlots)
      : undefined;
    message.equipmentSlot = (object.equipmentSlot !== undefined && object.equipmentSlot !== null)
      ? EquipmentSlotDTO.fromPartial(object.equipmentSlot)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.trainedSkill = object.trainedSkill ?? undefined;
    message.storageSlotDefinition =
      (object.storageSlotDefinition !== undefined && object.storageSlotDefinition !== null)
        ? StorageSlotDefinitionsDTO.fromPartial(object.storageSlotDefinition)
        : undefined;
    message.weight = object.weight ?? undefined;
    return message;
  },
};

function createBaseItemsDTO(): ItemsDTO {
  return { items: [] };
}

export const ItemsDTO: MessageFns<ItemsDTO> = {
  encode(message: ItemsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      ItemDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(ItemDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemsDTO {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => ItemDTO.fromJSON(e)) : [] };
  },

  toJSON(message: ItemsDTO): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => ItemDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemsDTO>, I>>(base?: I): ItemsDTO {
    return ItemsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemsDTO>, I>>(object: I): ItemsDTO {
    const message = createBaseItemsDTO();
    message.items = object.items?.map((e) => ItemDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseItemActionsDTO(): ItemActionsDTO {
  return { actions: [] };
}

export const ItemActionsDTO: MessageFns<ItemActionsDTO> = {
  encode(message: ItemActionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.actions) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemActionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemActionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemActionsDTO {
    return {
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ItemActionsDTO): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemActionsDTO>, I>>(base?: I): ItemActionsDTO {
    return ItemActionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemActionsDTO>, I>>(object: I): ItemActionsDTO {
    const message = createBaseItemActionsDTO();
    message.actions = object.actions?.map((e) => e) || [];
    return message;
  },
};

function createBaseStorageSlotDTO(): StorageSlotDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    grid: [],
    gridState: undefined,
    maxWeight: 0,
    parentItem: undefined,
    storedItems: undefined,
    targetEntity: "",
  };
}

export const StorageSlotDTO: MessageFns<StorageSlotDTO> = {
  encode(message: StorageSlotDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    writer.uint32(66).fork();
    for (const v of message.grid) {
      writer.int32(v);
    }
    writer.join();
    if (message.gridState !== undefined) {
      StorageGridDTO.encode(message.gridState, writer.uint32(74).fork()).join();
    }
    if (message.maxWeight !== 0) {
      writer.uint32(80).int32(message.maxWeight);
    }
    if (message.parentItem !== undefined) {
      ItemDTO.encode(message.parentItem, writer.uint32(90).fork()).join();
    }
    if (message.storedItems !== undefined) {
      ItemsDTO.encode(message.storedItems, writer.uint32(98).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(106).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlotDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlotDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.grid.push(reader.int32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.grid.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.gridState = StorageGridDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxWeight = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.parentItem = ItemDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.storedItems = ItemsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlotDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      grid: globalThis.Array.isArray(object?.grid) ? object.grid.map((e: any) => globalThis.Number(e)) : [],
      gridState: isSet(object.gridState) ? StorageGridDTO.fromJSON(object.gridState) : undefined,
      maxWeight: isSet(object.maxWeight) ? globalThis.Number(object.maxWeight) : 0,
      parentItem: isSet(object.parentItem) ? ItemDTO.fromJSON(object.parentItem) : undefined,
      storedItems: isSet(object.storedItems) ? ItemsDTO.fromJSON(object.storedItems) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: StorageSlotDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.grid?.length) {
      obj.grid = message.grid.map((e) => Math.round(e));
    }
    if (message.gridState !== undefined) {
      obj.gridState = StorageGridDTO.toJSON(message.gridState);
    }
    if (message.maxWeight !== 0) {
      obj.maxWeight = Math.round(message.maxWeight);
    }
    if (message.parentItem !== undefined) {
      obj.parentItem = ItemDTO.toJSON(message.parentItem);
    }
    if (message.storedItems !== undefined) {
      obj.storedItems = ItemsDTO.toJSON(message.storedItems);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlotDTO>, I>>(base?: I): StorageSlotDTO {
    return StorageSlotDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlotDTO>, I>>(object: I): StorageSlotDTO {
    const message = createBaseStorageSlotDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.grid = object.grid?.map((e) => e) || [];
    message.gridState = (object.gridState !== undefined && object.gridState !== null)
      ? StorageGridDTO.fromPartial(object.gridState)
      : undefined;
    message.maxWeight = object.maxWeight ?? 0;
    message.parentItem = (object.parentItem !== undefined && object.parentItem !== null)
      ? ItemDTO.fromPartial(object.parentItem)
      : undefined;
    message.storedItems = (object.storedItems !== undefined && object.storedItems !== null)
      ? ItemsDTO.fromPartial(object.storedItems)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseStorageSlotsDTO(): StorageSlotsDTO {
  return { storageSlots: [] };
}

export const StorageSlotsDTO: MessageFns<StorageSlotsDTO> = {
  encode(message: StorageSlotsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.storageSlots) {
      StorageSlotDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlotsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlotsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.storageSlots.push(StorageSlotDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlotsDTO {
    return {
      storageSlots: globalThis.Array.isArray(object?.storageSlots)
        ? object.storageSlots.map((e: any) => StorageSlotDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StorageSlotsDTO): unknown {
    const obj: any = {};
    if (message.storageSlots?.length) {
      obj.storageSlots = message.storageSlots.map((e) => StorageSlotDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlotsDTO>, I>>(base?: I): StorageSlotsDTO {
    return StorageSlotsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlotsDTO>, I>>(object: I): StorageSlotsDTO {
    const message = createBaseStorageSlotsDTO();
    message.storageSlots = object.storageSlots?.map((e) => StorageSlotDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorageGridDTO(): StorageGridDTO {
  return { cells: [] };
}

export const StorageGridDTO: MessageFns<StorageGridDTO> = {
  encode(message: StorageGridDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.cells) {
      StorageGridCellDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageGridDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageGridDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cells.push(StorageGridCellDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageGridDTO {
    return {
      cells: globalThis.Array.isArray(object?.cells)
        ? object.cells.map((e: any) => StorageGridCellDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StorageGridDTO): unknown {
    const obj: any = {};
    if (message.cells?.length) {
      obj.cells = message.cells.map((e) => StorageGridCellDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageGridDTO>, I>>(base?: I): StorageGridDTO {
    return StorageGridDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageGridDTO>, I>>(object: I): StorageGridDTO {
    const message = createBaseStorageGridDTO();
    message.cells = object.cells?.map((e) => StorageGridCellDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorageGridCellDTO(): StorageGridCellDTO {
  return { row: 0, column: 0, value: "" };
}

export const StorageGridCellDTO: MessageFns<StorageGridCellDTO> = {
  encode(message: StorageGridCellDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.row !== 0) {
      writer.uint32(8).int32(message.row);
    }
    if (message.column !== 0) {
      writer.uint32(16).int32(message.column);
    }
    if (message.value !== "") {
      writer.uint32(26).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageGridCellDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageGridCellDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.row = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.column = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageGridCellDTO {
    return {
      row: isSet(object.row) ? globalThis.Number(object.row) : 0,
      column: isSet(object.column) ? globalThis.Number(object.column) : 0,
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StorageGridCellDTO): unknown {
    const obj: any = {};
    if (message.row !== 0) {
      obj.row = Math.round(message.row);
    }
    if (message.column !== 0) {
      obj.column = Math.round(message.column);
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageGridCellDTO>, I>>(base?: I): StorageGridCellDTO {
    return StorageGridCellDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageGridCellDTO>, I>>(object: I): StorageGridCellDTO {
    const message = createBaseStorageGridCellDTO();
    message.row = object.row ?? 0;
    message.column = object.column ?? 0;
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseItemRequirementDTO(): ItemRequirementDTO {
  return { type: "", name: "", number: undefined, flag: undefined };
}

export const ItemRequirementDTO: MessageFns<ItemRequirementDTO> = {
  encode(message: ItemRequirementDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.number !== undefined) {
      writer.uint32(24).int32(message.number);
    }
    if (message.flag !== undefined) {
      writer.uint32(32).bool(message.flag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemRequirementDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemRequirementDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.number = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.flag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemRequirementDTO {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      number: isSet(object.number) ? globalThis.Number(object.number) : undefined,
      flag: isSet(object.flag) ? globalThis.Boolean(object.flag) : undefined,
    };
  },

  toJSON(message: ItemRequirementDTO): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.number !== undefined) {
      obj.number = Math.round(message.number);
    }
    if (message.flag !== undefined) {
      obj.flag = message.flag;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemRequirementDTO>, I>>(base?: I): ItemRequirementDTO {
    return ItemRequirementDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemRequirementDTO>, I>>(object: I): ItemRequirementDTO {
    const message = createBaseItemRequirementDTO();
    message.type = object.type ?? "";
    message.name = object.name ?? "";
    message.number = object.number ?? undefined;
    message.flag = object.flag ?? undefined;
    return message;
  },
};

function createBaseItemRequirementsDTO(): ItemRequirementsDTO {
  return { requirements: [] };
}

export const ItemRequirementsDTO: MessageFns<ItemRequirementsDTO> = {
  encode(message: ItemRequirementsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requirements) {
      ItemRequirementDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemRequirementsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemRequirementsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requirements.push(ItemRequirementDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemRequirementsDTO {
    return {
      requirements: globalThis.Array.isArray(object?.requirements)
        ? object.requirements.map((e: any) => ItemRequirementDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ItemRequirementsDTO): unknown {
    const obj: any = {};
    if (message.requirements?.length) {
      obj.requirements = message.requirements.map((e) => ItemRequirementDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemRequirementsDTO>, I>>(base?: I): ItemRequirementsDTO {
    return ItemRequirementsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemRequirementsDTO>, I>>(object: I): ItemRequirementsDTO {
    const message = createBaseItemRequirementsDTO();
    message.requirements = object.requirements?.map((e) => ItemRequirementDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterDTO(): CharacterDTO {
  return {
    id: "",
    blueprintId: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    firstName: "",
    lastName: "",
    race: undefined,
    gender: "",
    birthsign: undefined,
    birthYear: undefined,
    birthMonth: undefined,
    birthDay: undefined,
    skills: {},
    equipmentSlots: undefined,
    professions: undefined,
    memoryPools: undefined,
    characterMemories: undefined,
    enneagramType: "",
    traits: undefined,
    diseases: undefined,
    addictions: undefined,
    factions: undefined,
    tags: undefined,
    targetEntity: "",
  };
}

export const CharacterDTO: MessageFns<CharacterDTO> = {
  encode(message: CharacterDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(34).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(42).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(50).fork()).join();
    }
    if (message.firstName !== "") {
      writer.uint32(58).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(66).string(message.lastName);
    }
    if (message.race !== undefined) {
      RaceDTO.encode(message.race, writer.uint32(74).fork()).join();
    }
    if (message.gender !== "") {
      writer.uint32(82).string(message.gender);
    }
    if (message.birthsign !== undefined) {
      BirthsignDTO.encode(message.birthsign, writer.uint32(90).fork()).join();
    }
    if (message.birthYear !== undefined) {
      writer.uint32(96).int32(message.birthYear);
    }
    if (message.birthMonth !== undefined) {
      writer.uint32(106).string(message.birthMonth);
    }
    if (message.birthDay !== undefined) {
      writer.uint32(112).int32(message.birthDay);
    }
    Object.entries(message.skills).forEach(([key, value]) => {
      CharacterDTO_SkillsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.equipmentSlots !== undefined) {
      EquipmentSlotsDTO.encode(message.equipmentSlots, writer.uint32(130).fork()).join();
    }
    if (message.professions !== undefined) {
      CharacterProfessionsDTO.encode(message.professions, writer.uint32(138).fork()).join();
    }
    if (message.memoryPools !== undefined) {
      MemoryPoolsDTO.encode(message.memoryPools, writer.uint32(146).fork()).join();
    }
    if (message.characterMemories !== undefined) {
      CharacterMemoriesDTO.encode(message.characterMemories, writer.uint32(154).fork()).join();
    }
    if (message.enneagramType !== "") {
      writer.uint32(162).string(message.enneagramType);
    }
    if (message.traits !== undefined) {
      TraitsDTO.encode(message.traits, writer.uint32(170).fork()).join();
    }
    if (message.diseases !== undefined) {
      DiseasesDTO.encode(message.diseases, writer.uint32(178).fork()).join();
    }
    if (message.addictions !== undefined) {
      AddictionsDTO.encode(message.addictions, writer.uint32(186).fork()).join();
    }
    if (message.factions !== undefined) {
      FactionsDTO.encode(message.factions, writer.uint32(194).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(202).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(210).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.race = RaceDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.birthsign = BirthsignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.birthYear = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.birthMonth = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.birthDay = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = CharacterDTO_SkillsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.skills[entry15.key] = entry15.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.equipmentSlots = EquipmentSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.professions = CharacterProfessionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.memoryPools = MemoryPoolsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.characterMemories = CharacterMemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.enneagramType = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.traits = TraitsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.diseases = DiseasesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.addictions = AddictionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.factions = FactionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      race: isSet(object.race) ? RaceDTO.fromJSON(object.race) : undefined,
      gender: isSet(object.gender) ? globalThis.String(object.gender) : "",
      birthsign: isSet(object.birthsign) ? BirthsignDTO.fromJSON(object.birthsign) : undefined,
      birthYear: isSet(object.birthYear) ? globalThis.Number(object.birthYear) : undefined,
      birthMonth: isSet(object.birthMonth) ? globalThis.String(object.birthMonth) : undefined,
      birthDay: isSet(object.birthDay) ? globalThis.Number(object.birthDay) : undefined,
      skills: isObject(object.skills)
        ? Object.entries(object.skills).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      equipmentSlots: isSet(object.equipmentSlots) ? EquipmentSlotsDTO.fromJSON(object.equipmentSlots) : undefined,
      professions: isSet(object.professions) ? CharacterProfessionsDTO.fromJSON(object.professions) : undefined,
      memoryPools: isSet(object.memoryPools) ? MemoryPoolsDTO.fromJSON(object.memoryPools) : undefined,
      characterMemories: isSet(object.characterMemories)
        ? CharacterMemoriesDTO.fromJSON(object.characterMemories)
        : undefined,
      enneagramType: isSet(object.enneagramType) ? globalThis.String(object.enneagramType) : "",
      traits: isSet(object.traits) ? TraitsDTO.fromJSON(object.traits) : undefined,
      diseases: isSet(object.diseases) ? DiseasesDTO.fromJSON(object.diseases) : undefined,
      addictions: isSet(object.addictions) ? AddictionsDTO.fromJSON(object.addictions) : undefined,
      factions: isSet(object.factions) ? FactionsDTO.fromJSON(object.factions) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: CharacterDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.race !== undefined) {
      obj.race = RaceDTO.toJSON(message.race);
    }
    if (message.gender !== "") {
      obj.gender = message.gender;
    }
    if (message.birthsign !== undefined) {
      obj.birthsign = BirthsignDTO.toJSON(message.birthsign);
    }
    if (message.birthYear !== undefined) {
      obj.birthYear = Math.round(message.birthYear);
    }
    if (message.birthMonth !== undefined) {
      obj.birthMonth = message.birthMonth;
    }
    if (message.birthDay !== undefined) {
      obj.birthDay = Math.round(message.birthDay);
    }
    if (message.skills) {
      const entries = Object.entries(message.skills);
      if (entries.length > 0) {
        obj.skills = {};
        entries.forEach(([k, v]) => {
          obj.skills[k] = Math.round(v);
        });
      }
    }
    if (message.equipmentSlots !== undefined) {
      obj.equipmentSlots = EquipmentSlotsDTO.toJSON(message.equipmentSlots);
    }
    if (message.professions !== undefined) {
      obj.professions = CharacterProfessionsDTO.toJSON(message.professions);
    }
    if (message.memoryPools !== undefined) {
      obj.memoryPools = MemoryPoolsDTO.toJSON(message.memoryPools);
    }
    if (message.characterMemories !== undefined) {
      obj.characterMemories = CharacterMemoriesDTO.toJSON(message.characterMemories);
    }
    if (message.enneagramType !== "") {
      obj.enneagramType = message.enneagramType;
    }
    if (message.traits !== undefined) {
      obj.traits = TraitsDTO.toJSON(message.traits);
    }
    if (message.diseases !== undefined) {
      obj.diseases = DiseasesDTO.toJSON(message.diseases);
    }
    if (message.addictions !== undefined) {
      obj.addictions = AddictionsDTO.toJSON(message.addictions);
    }
    if (message.factions !== undefined) {
      obj.factions = FactionsDTO.toJSON(message.factions);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterDTO>, I>>(base?: I): CharacterDTO {
    return CharacterDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterDTO>, I>>(object: I): CharacterDTO {
    const message = createBaseCharacterDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.race = (object.race !== undefined && object.race !== null) ? RaceDTO.fromPartial(object.race) : undefined;
    message.gender = object.gender ?? "";
    message.birthsign = (object.birthsign !== undefined && object.birthsign !== null)
      ? BirthsignDTO.fromPartial(object.birthsign)
      : undefined;
    message.birthYear = object.birthYear ?? undefined;
    message.birthMonth = object.birthMonth ?? undefined;
    message.birthDay = object.birthDay ?? undefined;
    message.skills = Object.entries(object.skills ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.equipmentSlots = (object.equipmentSlots !== undefined && object.equipmentSlots !== null)
      ? EquipmentSlotsDTO.fromPartial(object.equipmentSlots)
      : undefined;
    message.professions = (object.professions !== undefined && object.professions !== null)
      ? CharacterProfessionsDTO.fromPartial(object.professions)
      : undefined;
    message.memoryPools = (object.memoryPools !== undefined && object.memoryPools !== null)
      ? MemoryPoolsDTO.fromPartial(object.memoryPools)
      : undefined;
    message.characterMemories = (object.characterMemories !== undefined && object.characterMemories !== null)
      ? CharacterMemoriesDTO.fromPartial(object.characterMemories)
      : undefined;
    message.enneagramType = object.enneagramType ?? "";
    message.traits = (object.traits !== undefined && object.traits !== null)
      ? TraitsDTO.fromPartial(object.traits)
      : undefined;
    message.diseases = (object.diseases !== undefined && object.diseases !== null)
      ? DiseasesDTO.fromPartial(object.diseases)
      : undefined;
    message.addictions = (object.addictions !== undefined && object.addictions !== null)
      ? AddictionsDTO.fromPartial(object.addictions)
      : undefined;
    message.factions = (object.factions !== undefined && object.factions !== null)
      ? FactionsDTO.fromPartial(object.factions)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseCharacterDTO_SkillsEntry(): CharacterDTO_SkillsEntry {
  return { key: "", value: 0 };
}

export const CharacterDTO_SkillsEntry: MessageFns<CharacterDTO_SkillsEntry> = {
  encode(message: CharacterDTO_SkillsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterDTO_SkillsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterDTO_SkillsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterDTO_SkillsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: CharacterDTO_SkillsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterDTO_SkillsEntry>, I>>(base?: I): CharacterDTO_SkillsEntry {
    return CharacterDTO_SkillsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterDTO_SkillsEntry>, I>>(object: I): CharacterDTO_SkillsEntry {
    const message = createBaseCharacterDTO_SkillsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCharactersDTO(): CharactersDTO {
  return { characters: [] };
}

export const CharactersDTO: MessageFns<CharactersDTO> = {
  encode(message: CharactersDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.characters) {
      CharacterDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharactersDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharactersDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characters.push(CharacterDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharactersDTO {
    return {
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => CharacterDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharactersDTO): unknown {
    const obj: any = {};
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => CharacterDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharactersDTO>, I>>(base?: I): CharactersDTO {
    return CharactersDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharactersDTO>, I>>(object: I): CharactersDTO {
    const message = createBaseCharactersDTO();
    message.characters = object.characters?.map((e) => CharacterDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddictionDTO(): AddictionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    character: undefined,
    characters: undefined,
    targetEntity: "",
  };
}

export const AddictionDTO: MessageFns<AddictionDTO> = {
  encode(message: AddictionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.character !== undefined) {
      CharacterDTO.encode(message.character, writer.uint32(66).fork()).join();
    }
    if (message.characters !== undefined) {
      CharactersDTO.encode(message.characters, writer.uint32(74).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddictionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddictionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.character = CharacterDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.characters = CharactersDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddictionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      character: isSet(object.character) ? CharacterDTO.fromJSON(object.character) : undefined,
      characters: isSet(object.characters) ? CharactersDTO.fromJSON(object.characters) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: AddictionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.character !== undefined) {
      obj.character = CharacterDTO.toJSON(message.character);
    }
    if (message.characters !== undefined) {
      obj.characters = CharactersDTO.toJSON(message.characters);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddictionDTO>, I>>(base?: I): AddictionDTO {
    return AddictionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddictionDTO>, I>>(object: I): AddictionDTO {
    const message = createBaseAddictionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.character = (object.character !== undefined && object.character !== null)
      ? CharacterDTO.fromPartial(object.character)
      : undefined;
    message.characters = (object.characters !== undefined && object.characters !== null)
      ? CharactersDTO.fromPartial(object.characters)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseAddictionsDTO(): AddictionsDTO {
  return { addictions: [] };
}

export const AddictionsDTO: MessageFns<AddictionsDTO> = {
  encode(message: AddictionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.addictions) {
      AddictionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddictionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddictionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.addictions.push(AddictionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddictionsDTO {
    return {
      addictions: globalThis.Array.isArray(object?.addictions)
        ? object.addictions.map((e: any) => AddictionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AddictionsDTO): unknown {
    const obj: any = {};
    if (message.addictions?.length) {
      obj.addictions = message.addictions.map((e) => AddictionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddictionsDTO>, I>>(base?: I): AddictionsDTO {
    return AddictionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddictionsDTO>, I>>(object: I): AddictionsDTO {
    const message = createBaseAddictionsDTO();
    message.addictions = object.addictions?.map((e) => AddictionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterMemoryDTO(): CharacterMemoryDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    character: undefined,
    factStatus: [],
    importance: 0,
    resistance: 0,
    accumulator: 0,
    acquiredAt: undefined,
    lastUpdatedAt: undefined,
    tags: undefined,
    memory: undefined,
    targetEntity: "",
  };
}

export const CharacterMemoryDTO: MessageFns<CharacterMemoryDTO> = {
  encode(message: CharacterMemoryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.character !== undefined) {
      CharacterDTO.encode(message.character, writer.uint32(66).fork()).join();
    }
    for (const v of message.factStatus) {
      FactStatusDTO.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.importance !== 0) {
      writer.uint32(80).int32(message.importance);
    }
    if (message.resistance !== 0) {
      writer.uint32(88).int32(message.resistance);
    }
    if (message.accumulator !== 0) {
      writer.uint32(96).int32(message.accumulator);
    }
    if (message.acquiredAt !== undefined) {
      writer.uint32(104).int32(message.acquiredAt);
    }
    if (message.lastUpdatedAt !== undefined) {
      writer.uint32(112).int32(message.lastUpdatedAt);
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(122).fork()).join();
    }
    if (message.memory !== undefined) {
      MemoryDTO.encode(message.memory, writer.uint32(130).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(138).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterMemoryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterMemoryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.character = CharacterDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.factStatus.push(FactStatusDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.importance = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.resistance = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.accumulator = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.acquiredAt = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.lastUpdatedAt = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.memory = MemoryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterMemoryDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      character: isSet(object.character) ? CharacterDTO.fromJSON(object.character) : undefined,
      factStatus: globalThis.Array.isArray(object?.factStatus)
        ? object.factStatus.map((e: any) => FactStatusDTO.fromJSON(e))
        : [],
      importance: isSet(object.importance) ? globalThis.Number(object.importance) : 0,
      resistance: isSet(object.resistance) ? globalThis.Number(object.resistance) : 0,
      accumulator: isSet(object.accumulator) ? globalThis.Number(object.accumulator) : 0,
      acquiredAt: isSet(object.acquiredAt) ? globalThis.Number(object.acquiredAt) : undefined,
      lastUpdatedAt: isSet(object.lastUpdatedAt) ? globalThis.Number(object.lastUpdatedAt) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      memory: isSet(object.memory) ? MemoryDTO.fromJSON(object.memory) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: CharacterMemoryDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.character !== undefined) {
      obj.character = CharacterDTO.toJSON(message.character);
    }
    if (message.factStatus?.length) {
      obj.factStatus = message.factStatus.map((e) => FactStatusDTO.toJSON(e));
    }
    if (message.importance !== 0) {
      obj.importance = Math.round(message.importance);
    }
    if (message.resistance !== 0) {
      obj.resistance = Math.round(message.resistance);
    }
    if (message.accumulator !== 0) {
      obj.accumulator = Math.round(message.accumulator);
    }
    if (message.acquiredAt !== undefined) {
      obj.acquiredAt = Math.round(message.acquiredAt);
    }
    if (message.lastUpdatedAt !== undefined) {
      obj.lastUpdatedAt = Math.round(message.lastUpdatedAt);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.memory !== undefined) {
      obj.memory = MemoryDTO.toJSON(message.memory);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterMemoryDTO>, I>>(base?: I): CharacterMemoryDTO {
    return CharacterMemoryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterMemoryDTO>, I>>(object: I): CharacterMemoryDTO {
    const message = createBaseCharacterMemoryDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.character = (object.character !== undefined && object.character !== null)
      ? CharacterDTO.fromPartial(object.character)
      : undefined;
    message.factStatus = object.factStatus?.map((e) => FactStatusDTO.fromPartial(e)) || [];
    message.importance = object.importance ?? 0;
    message.resistance = object.resistance ?? 0;
    message.accumulator = object.accumulator ?? 0;
    message.acquiredAt = object.acquiredAt ?? undefined;
    message.lastUpdatedAt = object.lastUpdatedAt ?? undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.memory = (object.memory !== undefined && object.memory !== null)
      ? MemoryDTO.fromPartial(object.memory)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseCharacterMemoriesDTO(): CharacterMemoriesDTO {
  return { characterMemories: [] };
}

export const CharacterMemoriesDTO: MessageFns<CharacterMemoriesDTO> = {
  encode(message: CharacterMemoriesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.characterMemories) {
      CharacterMemoryDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterMemoriesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterMemoriesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterMemories.push(CharacterMemoryDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterMemoriesDTO {
    return {
      characterMemories: globalThis.Array.isArray(object?.characterMemories)
        ? object.characterMemories.map((e: any) => CharacterMemoryDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterMemoriesDTO): unknown {
    const obj: any = {};
    if (message.characterMemories?.length) {
      obj.characterMemories = message.characterMemories.map((e) => CharacterMemoryDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterMemoriesDTO>, I>>(base?: I): CharacterMemoriesDTO {
    return CharacterMemoriesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterMemoriesDTO>, I>>(object: I): CharacterMemoriesDTO {
    const message = createBaseCharacterMemoriesDTO();
    message.characterMemories = object.characterMemories?.map((e) => CharacterMemoryDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFactStatusDTO(): FactStatusDTO {
  return { factId: "", status: 0 };
}

export const FactStatusDTO: MessageFns<FactStatusDTO> = {
  encode(message: FactStatusDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.factId !== "") {
      writer.uint32(10).string(message.factId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactStatusDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactStatusDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.factId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactStatusDTO {
    return {
      factId: isSet(object.factId) ? globalThis.String(object.factId) : "",
      status: isSet(object.status) ? factStatusEnumDTOFromJSON(object.status) : 0,
    };
  },

  toJSON(message: FactStatusDTO): unknown {
    const obj: any = {};
    if (message.factId !== "") {
      obj.factId = message.factId;
    }
    if (message.status !== 0) {
      obj.status = factStatusEnumDTOToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactStatusDTO>, I>>(base?: I): FactStatusDTO {
    return FactStatusDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactStatusDTO>, I>>(object: I): FactStatusDTO {
    const message = createBaseFactStatusDTO();
    message.factId = object.factId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseFactStatusesDTO(): FactStatusesDTO {
  return { factStatuses: [] };
}

export const FactStatusesDTO: MessageFns<FactStatusesDTO> = {
  encode(message: FactStatusesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.factStatuses) {
      FactStatusDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactStatusesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactStatusesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.factStatuses.push(FactStatusDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactStatusesDTO {
    return {
      factStatuses: globalThis.Array.isArray(object?.factStatuses)
        ? object.factStatuses.map((e: any) => FactStatusDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FactStatusesDTO): unknown {
    const obj: any = {};
    if (message.factStatuses?.length) {
      obj.factStatuses = message.factStatuses.map((e) => FactStatusDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactStatusesDTO>, I>>(base?: I): FactStatusesDTO {
    return FactStatusesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactStatusesDTO>, I>>(object: I): FactStatusesDTO {
    const message = createBaseFactStatusesDTO();
    message.factStatuses = object.factStatuses?.map((e) => FactStatusDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTagDTO(): TagDTO {
  return {
    id: "",
    blueprintId: "",
    metadata: undefined,
    label: "",
    subtype: 0,
    items: undefined,
    pastExperiences: undefined,
    characterMemories: undefined,
    memories: undefined,
    memoryPools: undefined,
    skills: undefined,
    traits: undefined,
    characters: undefined,
    characterProfessions: undefined,
    diseases: undefined,
    effects: undefined,
    facts: undefined,
    factions: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    targetEntity: "",
  };
}

export const TagDTO: MessageFns<TagDTO> = {
  encode(message: TagDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(26).fork()).join();
    }
    if (message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    if (message.subtype !== 0) {
      writer.uint32(40).int32(message.subtype);
    }
    if (message.items !== undefined) {
      ItemsDTO.encode(message.items, writer.uint32(50).fork()).join();
    }
    if (message.pastExperiences !== undefined) {
      PastExperiencesDTO.encode(message.pastExperiences, writer.uint32(58).fork()).join();
    }
    if (message.characterMemories !== undefined) {
      CharacterMemoriesDTO.encode(message.characterMemories, writer.uint32(66).fork()).join();
    }
    if (message.memories !== undefined) {
      MemoriesDTO.encode(message.memories, writer.uint32(74).fork()).join();
    }
    if (message.memoryPools !== undefined) {
      MemoryPoolsDTO.encode(message.memoryPools, writer.uint32(82).fork()).join();
    }
    if (message.skills !== undefined) {
      SkillsDTO.encode(message.skills, writer.uint32(90).fork()).join();
    }
    if (message.traits !== undefined) {
      TraitsDTO.encode(message.traits, writer.uint32(98).fork()).join();
    }
    if (message.characters !== undefined) {
      CharactersDTO.encode(message.characters, writer.uint32(106).fork()).join();
    }
    if (message.characterProfessions !== undefined) {
      CharacterProfessionsDTO.encode(message.characterProfessions, writer.uint32(114).fork()).join();
    }
    if (message.diseases !== undefined) {
      DiseasesDTO.encode(message.diseases, writer.uint32(122).fork()).join();
    }
    if (message.effects !== undefined) {
      EffectsDTO.encode(message.effects, writer.uint32(130).fork()).join();
    }
    if (message.facts !== undefined) {
      FactsDTO.encode(message.facts, writer.uint32(138).fork()).join();
    }
    if (message.factions !== undefined) {
      FactionsDTO.encode(message.factions, writer.uint32(146).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(154).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(162).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(170).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(178).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subtype = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.items = ItemsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pastExperiences = PastExperiencesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.characterMemories = CharacterMemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memories = MemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.memoryPools = MemoryPoolsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.skills = SkillsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.traits = TraitsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.characters = CharactersDTO.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.characterProfessions = CharacterProfessionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.diseases = DiseasesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.effects = EffectsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.facts = FactsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.factions = FactionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      subtype: isSet(object.subtype) ? tagSubtypeEnumDTOFromJSON(object.subtype) : 0,
      items: isSet(object.items) ? ItemsDTO.fromJSON(object.items) : undefined,
      pastExperiences: isSet(object.pastExperiences) ? PastExperiencesDTO.fromJSON(object.pastExperiences) : undefined,
      characterMemories: isSet(object.characterMemories)
        ? CharacterMemoriesDTO.fromJSON(object.characterMemories)
        : undefined,
      memories: isSet(object.memories) ? MemoriesDTO.fromJSON(object.memories) : undefined,
      memoryPools: isSet(object.memoryPools) ? MemoryPoolsDTO.fromJSON(object.memoryPools) : undefined,
      skills: isSet(object.skills) ? SkillsDTO.fromJSON(object.skills) : undefined,
      traits: isSet(object.traits) ? TraitsDTO.fromJSON(object.traits) : undefined,
      characters: isSet(object.characters) ? CharactersDTO.fromJSON(object.characters) : undefined,
      characterProfessions: isSet(object.characterProfessions)
        ? CharacterProfessionsDTO.fromJSON(object.characterProfessions)
        : undefined,
      diseases: isSet(object.diseases) ? DiseasesDTO.fromJSON(object.diseases) : undefined,
      effects: isSet(object.effects) ? EffectsDTO.fromJSON(object.effects) : undefined,
      facts: isSet(object.facts) ? FactsDTO.fromJSON(object.facts) : undefined,
      factions: isSet(object.factions) ? FactionsDTO.fromJSON(object.factions) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: TagDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.subtype !== 0) {
      obj.subtype = tagSubtypeEnumDTOToJSON(message.subtype);
    }
    if (message.items !== undefined) {
      obj.items = ItemsDTO.toJSON(message.items);
    }
    if (message.pastExperiences !== undefined) {
      obj.pastExperiences = PastExperiencesDTO.toJSON(message.pastExperiences);
    }
    if (message.characterMemories !== undefined) {
      obj.characterMemories = CharacterMemoriesDTO.toJSON(message.characterMemories);
    }
    if (message.memories !== undefined) {
      obj.memories = MemoriesDTO.toJSON(message.memories);
    }
    if (message.memoryPools !== undefined) {
      obj.memoryPools = MemoryPoolsDTO.toJSON(message.memoryPools);
    }
    if (message.skills !== undefined) {
      obj.skills = SkillsDTO.toJSON(message.skills);
    }
    if (message.traits !== undefined) {
      obj.traits = TraitsDTO.toJSON(message.traits);
    }
    if (message.characters !== undefined) {
      obj.characters = CharactersDTO.toJSON(message.characters);
    }
    if (message.characterProfessions !== undefined) {
      obj.characterProfessions = CharacterProfessionsDTO.toJSON(message.characterProfessions);
    }
    if (message.diseases !== undefined) {
      obj.diseases = DiseasesDTO.toJSON(message.diseases);
    }
    if (message.effects !== undefined) {
      obj.effects = EffectsDTO.toJSON(message.effects);
    }
    if (message.facts !== undefined) {
      obj.facts = FactsDTO.toJSON(message.facts);
    }
    if (message.factions !== undefined) {
      obj.factions = FactionsDTO.toJSON(message.factions);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagDTO>, I>>(base?: I): TagDTO {
    return TagDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagDTO>, I>>(object: I): TagDTO {
    const message = createBaseTagDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.label = object.label ?? "";
    message.subtype = object.subtype ?? 0;
    message.items = (object.items !== undefined && object.items !== null)
      ? ItemsDTO.fromPartial(object.items)
      : undefined;
    message.pastExperiences = (object.pastExperiences !== undefined && object.pastExperiences !== null)
      ? PastExperiencesDTO.fromPartial(object.pastExperiences)
      : undefined;
    message.characterMemories = (object.characterMemories !== undefined && object.characterMemories !== null)
      ? CharacterMemoriesDTO.fromPartial(object.characterMemories)
      : undefined;
    message.memories = (object.memories !== undefined && object.memories !== null)
      ? MemoriesDTO.fromPartial(object.memories)
      : undefined;
    message.memoryPools = (object.memoryPools !== undefined && object.memoryPools !== null)
      ? MemoryPoolsDTO.fromPartial(object.memoryPools)
      : undefined;
    message.skills = (object.skills !== undefined && object.skills !== null)
      ? SkillsDTO.fromPartial(object.skills)
      : undefined;
    message.traits = (object.traits !== undefined && object.traits !== null)
      ? TraitsDTO.fromPartial(object.traits)
      : undefined;
    message.characters = (object.characters !== undefined && object.characters !== null)
      ? CharactersDTO.fromPartial(object.characters)
      : undefined;
    message.characterProfessions = (object.characterProfessions !== undefined && object.characterProfessions !== null)
      ? CharacterProfessionsDTO.fromPartial(object.characterProfessions)
      : undefined;
    message.diseases = (object.diseases !== undefined && object.diseases !== null)
      ? DiseasesDTO.fromPartial(object.diseases)
      : undefined;
    message.effects = (object.effects !== undefined && object.effects !== null)
      ? EffectsDTO.fromPartial(object.effects)
      : undefined;
    message.facts = (object.facts !== undefined && object.facts !== null)
      ? FactsDTO.fromPartial(object.facts)
      : undefined;
    message.factions = (object.factions !== undefined && object.factions !== null)
      ? FactionsDTO.fromPartial(object.factions)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseTagsDTO(): TagsDTO {
  return { tags: [] };
}

export const TagsDTO: MessageFns<TagsDTO> = {
  encode(message: TagsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tags) {
      TagDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TagsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTagsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tags.push(TagDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TagsDTO {
    return { tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => TagDTO.fromJSON(e)) : [] };
  },

  toJSON(message: TagsDTO): unknown {
    const obj: any = {};
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => TagDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TagsDTO>, I>>(base?: I): TagsDTO {
    return TagsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TagsDTO>, I>>(object: I): TagsDTO {
    const message = createBaseTagsDTO();
    message.tags = object.tags?.map((e) => TagDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkillDTO(): SkillDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    description: "",
    category: 0,
    targetEntity: "",
  };
}

export const SkillDTO: MessageFns<SkillDTO> = {
  encode(message: SkillDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.category !== 0) {
      writer.uint32(80).int32(message.category);
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? skillCategoryEnumDTOFromJSON(object.category) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: SkillDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== 0) {
      obj.category = skillCategoryEnumDTOToJSON(message.category);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillDTO>, I>>(base?: I): SkillDTO {
    return SkillDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillDTO>, I>>(object: I): SkillDTO {
    const message = createBaseSkillDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.description = object.description ?? "";
    message.category = object.category ?? 0;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseSkillsDTO(): SkillsDTO {
  return { skills: [] };
}

export const SkillsDTO: MessageFns<SkillsDTO> = {
  encode(message: SkillsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skills) {
      SkillDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skills.push(SkillDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillsDTO {
    return {
      skills: globalThis.Array.isArray(object?.skills) ? object.skills.map((e: any) => SkillDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: SkillsDTO): unknown {
    const obj: any = {};
    if (message.skills?.length) {
      obj.skills = message.skills.map((e) => SkillDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillsDTO>, I>>(base?: I): SkillsDTO {
    return SkillsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillsDTO>, I>>(object: I): SkillsDTO {
    const message = createBaseSkillsDTO();
    message.skills = object.skills?.map((e) => SkillDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTraitDTO(): TraitDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    targetEntity: "",
  };
}

export const TraitDTO: MessageFns<TraitDTO> = {
  encode(message: TraitDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraitDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraitDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraitDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: TraitDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraitDTO>, I>>(base?: I): TraitDTO {
    return TraitDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraitDTO>, I>>(object: I): TraitDTO {
    const message = createBaseTraitDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseTraitsDTO(): TraitsDTO {
  return { traits: [] };
}

export const TraitsDTO: MessageFns<TraitsDTO> = {
  encode(message: TraitsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.traits) {
      TraitDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TraitsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTraitsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.traits.push(TraitDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TraitsDTO {
    return {
      traits: globalThis.Array.isArray(object?.traits) ? object.traits.map((e: any) => TraitDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: TraitsDTO): unknown {
    const obj: any = {};
    if (message.traits?.length) {
      obj.traits = message.traits.map((e) => TraitDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TraitsDTO>, I>>(base?: I): TraitsDTO {
    return TraitsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TraitsDTO>, I>>(object: I): TraitsDTO {
    const message = createBaseTraitsDTO();
    message.traits = object.traits?.map((e) => TraitDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDiseaseDTO(): DiseaseDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    description: "",
    severity: "",
    characters: undefined,
    targetEntity: "",
  };
}

export const DiseaseDTO: MessageFns<DiseaseDTO> = {
  encode(message: DiseaseDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.severity !== "") {
      writer.uint32(82).string(message.severity);
    }
    if (message.characters !== undefined) {
      CharactersDTO.encode(message.characters, writer.uint32(90).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(98).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiseaseDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiseaseDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.characters = CharactersDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiseaseDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      characters: isSet(object.characters) ? CharactersDTO.fromJSON(object.characters) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: DiseaseDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.characters !== undefined) {
      obj.characters = CharactersDTO.toJSON(message.characters);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiseaseDTO>, I>>(base?: I): DiseaseDTO {
    return DiseaseDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiseaseDTO>, I>>(object: I): DiseaseDTO {
    const message = createBaseDiseaseDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.description = object.description ?? "";
    message.severity = object.severity ?? "";
    message.characters = (object.characters !== undefined && object.characters !== null)
      ? CharactersDTO.fromPartial(object.characters)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseDiseasesDTO(): DiseasesDTO {
  return { diseases: [] };
}

export const DiseasesDTO: MessageFns<DiseasesDTO> = {
  encode(message: DiseasesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.diseases) {
      DiseaseDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiseasesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiseasesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.diseases.push(DiseaseDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiseasesDTO {
    return {
      diseases: globalThis.Array.isArray(object?.diseases)
        ? object.diseases.map((e: any) => DiseaseDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DiseasesDTO): unknown {
    const obj: any = {};
    if (message.diseases?.length) {
      obj.diseases = message.diseases.map((e) => DiseaseDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiseasesDTO>, I>>(base?: I): DiseasesDTO {
    return DiseasesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiseasesDTO>, I>>(object: I): DiseasesDTO {
    const message = createBaseDiseasesDTO();
    message.diseases = object.diseases?.map((e) => DiseaseDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFactDTO(): FactDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    description: "",
    weight: 0,
    memories: undefined,
    characters: undefined,
    targetEntity: "",
  };
}

export const FactDTO: MessageFns<FactDTO> = {
  encode(message: FactDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.weight !== 0) {
      writer.uint32(80).int32(message.weight);
    }
    if (message.memories !== undefined) {
      MemoriesDTO.encode(message.memories, writer.uint32(90).fork()).join();
    }
    if (message.characters !== undefined) {
      CharactersDTO.encode(message.characters, writer.uint32(98).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(106).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.memories = MemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.characters = CharactersDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      memories: isSet(object.memories) ? MemoriesDTO.fromJSON(object.memories) : undefined,
      characters: isSet(object.characters) ? CharactersDTO.fromJSON(object.characters) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: FactDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.memories !== undefined) {
      obj.memories = MemoriesDTO.toJSON(message.memories);
    }
    if (message.characters !== undefined) {
      obj.characters = CharactersDTO.toJSON(message.characters);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactDTO>, I>>(base?: I): FactDTO {
    return FactDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactDTO>, I>>(object: I): FactDTO {
    const message = createBaseFactDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.description = object.description ?? "";
    message.weight = object.weight ?? 0;
    message.memories = (object.memories !== undefined && object.memories !== null)
      ? MemoriesDTO.fromPartial(object.memories)
      : undefined;
    message.characters = (object.characters !== undefined && object.characters !== null)
      ? CharactersDTO.fromPartial(object.characters)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseFactsDTO(): FactsDTO {
  return { facts: [] };
}

export const FactsDTO: MessageFns<FactsDTO> = {
  encode(message: FactsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.facts) {
      FactDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.facts.push(FactDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactsDTO {
    return { facts: globalThis.Array.isArray(object?.facts) ? object.facts.map((e: any) => FactDTO.fromJSON(e)) : [] };
  },

  toJSON(message: FactsDTO): unknown {
    const obj: any = {};
    if (message.facts?.length) {
      obj.facts = message.facts.map((e) => FactDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactsDTO>, I>>(base?: I): FactsDTO {
    return FactsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactsDTO>, I>>(object: I): FactsDTO {
    const message = createBaseFactsDTO();
    message.facts = object.facts?.map((e) => FactDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFactionDTO(): FactionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    characters: undefined,
    targetEntity: "",
  };
}

export const FactionDTO: MessageFns<FactionDTO> = {
  encode(message: FactionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.characters !== undefined) {
      CharactersDTO.encode(message.characters, writer.uint32(74).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.characters = CharactersDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      characters: isSet(object.characters) ? CharactersDTO.fromJSON(object.characters) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: FactionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.characters !== undefined) {
      obj.characters = CharactersDTO.toJSON(message.characters);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactionDTO>, I>>(base?: I): FactionDTO {
    return FactionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactionDTO>, I>>(object: I): FactionDTO {
    const message = createBaseFactionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.characters = (object.characters !== undefined && object.characters !== null)
      ? CharactersDTO.fromPartial(object.characters)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseFactionsDTO(): FactionsDTO {
  return { factions: [] };
}

export const FactionsDTO: MessageFns<FactionsDTO> = {
  encode(message: FactionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.factions) {
      FactionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.factions.push(FactionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactionsDTO {
    return {
      factions: globalThis.Array.isArray(object?.factions)
        ? object.factions.map((e: any) => FactionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FactionsDTO): unknown {
    const obj: any = {};
    if (message.factions?.length) {
      obj.factions = message.factions.map((e) => FactionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactionsDTO>, I>>(base?: I): FactionsDTO {
    return FactionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactionsDTO>, I>>(object: I): FactionsDTO {
    const message = createBaseFactionsDTO();
    message.factions = object.factions?.map((e) => FactionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemoryPoolDTO(): MemoryPoolDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: undefined,
    memoryPoolEntries: undefined,
    characterProfessions: undefined,
    tags: undefined,
    targetEntity: "",
  };
}

export const MemoryPoolDTO: MessageFns<MemoryPoolDTO> = {
  encode(message: MemoryPoolDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.description !== undefined) {
      writer.uint32(66).string(message.description);
    }
    if (message.memoryPoolEntries !== undefined) {
      MemoryPoolEntriesDTO.encode(message.memoryPoolEntries, writer.uint32(74).fork()).join();
    }
    if (message.characterProfessions !== undefined) {
      CharacterProfessionsDTO.encode(message.characterProfessions, writer.uint32(82).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(90).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(98).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memoryPoolEntries = MemoryPoolEntriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.characterProfessions = CharacterProfessionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : undefined,
      memoryPoolEntries: isSet(object.memoryPoolEntries)
        ? MemoryPoolEntriesDTO.fromJSON(object.memoryPoolEntries)
        : undefined,
      characterProfessions: isSet(object.characterProfessions)
        ? CharacterProfessionsDTO.fromJSON(object.characterProfessions)
        : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: MemoryPoolDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.description !== undefined) {
      obj.description = message.description;
    }
    if (message.memoryPoolEntries !== undefined) {
      obj.memoryPoolEntries = MemoryPoolEntriesDTO.toJSON(message.memoryPoolEntries);
    }
    if (message.characterProfessions !== undefined) {
      obj.characterProfessions = CharacterProfessionsDTO.toJSON(message.characterProfessions);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolDTO>, I>>(base?: I): MemoryPoolDTO {
    return MemoryPoolDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolDTO>, I>>(object: I): MemoryPoolDTO {
    const message = createBaseMemoryPoolDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.description = object.description ?? undefined;
    message.memoryPoolEntries = (object.memoryPoolEntries !== undefined && object.memoryPoolEntries !== null)
      ? MemoryPoolEntriesDTO.fromPartial(object.memoryPoolEntries)
      : undefined;
    message.characterProfessions = (object.characterProfessions !== undefined && object.characterProfessions !== null)
      ? CharacterProfessionsDTO.fromPartial(object.characterProfessions)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseMemoryPoolsDTO(): MemoryPoolsDTO {
  return { memoryPools: [] };
}

export const MemoryPoolsDTO: MessageFns<MemoryPoolsDTO> = {
  encode(message: MemoryPoolsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.memoryPools) {
      MemoryPoolDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.memoryPools.push(MemoryPoolDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolsDTO {
    return {
      memoryPools: globalThis.Array.isArray(object?.memoryPools)
        ? object.memoryPools.map((e: any) => MemoryPoolDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MemoryPoolsDTO): unknown {
    const obj: any = {};
    if (message.memoryPools?.length) {
      obj.memoryPools = message.memoryPools.map((e) => MemoryPoolDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolsDTO>, I>>(base?: I): MemoryPoolsDTO {
    return MemoryPoolsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolsDTO>, I>>(object: I): MemoryPoolsDTO {
    const message = createBaseMemoryPoolsDTO();
    message.memoryPools = object.memoryPools?.map((e) => MemoryPoolDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemoryPoolEntryDTO(): MemoryPoolEntryDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    memoryPool: undefined,
    memory: undefined,
    probability: 0,
    defaultClarity: 0,
    defaultImportance: 0,
    targetEntity: "",
  };
}

export const MemoryPoolEntryDTO: MessageFns<MemoryPoolEntryDTO> = {
  encode(message: MemoryPoolEntryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.memoryPool !== undefined) {
      MemoryPoolDTO.encode(message.memoryPool, writer.uint32(66).fork()).join();
    }
    if (message.memory !== undefined) {
      MemoryDTO.encode(message.memory, writer.uint32(74).fork()).join();
    }
    if (message.probability !== 0) {
      writer.uint32(80).int32(message.probability);
    }
    if (message.defaultClarity !== 0) {
      writer.uint32(88).int32(message.defaultClarity);
    }
    if (message.defaultImportance !== 0) {
      writer.uint32(96).int32(message.defaultImportance);
    }
    if (message.targetEntity !== "") {
      writer.uint32(106).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolEntryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolEntryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.memoryPool = MemoryPoolDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memory = MemoryDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.probability = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.defaultClarity = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.defaultImportance = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolEntryDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      memoryPool: isSet(object.memoryPool) ? MemoryPoolDTO.fromJSON(object.memoryPool) : undefined,
      memory: isSet(object.memory) ? MemoryDTO.fromJSON(object.memory) : undefined,
      probability: isSet(object.probability) ? globalThis.Number(object.probability) : 0,
      defaultClarity: isSet(object.defaultClarity) ? globalThis.Number(object.defaultClarity) : 0,
      defaultImportance: isSet(object.defaultImportance) ? globalThis.Number(object.defaultImportance) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: MemoryPoolEntryDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.memoryPool !== undefined) {
      obj.memoryPool = MemoryPoolDTO.toJSON(message.memoryPool);
    }
    if (message.memory !== undefined) {
      obj.memory = MemoryDTO.toJSON(message.memory);
    }
    if (message.probability !== 0) {
      obj.probability = Math.round(message.probability);
    }
    if (message.defaultClarity !== 0) {
      obj.defaultClarity = Math.round(message.defaultClarity);
    }
    if (message.defaultImportance !== 0) {
      obj.defaultImportance = Math.round(message.defaultImportance);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolEntryDTO>, I>>(base?: I): MemoryPoolEntryDTO {
    return MemoryPoolEntryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolEntryDTO>, I>>(object: I): MemoryPoolEntryDTO {
    const message = createBaseMemoryPoolEntryDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.memoryPool = (object.memoryPool !== undefined && object.memoryPool !== null)
      ? MemoryPoolDTO.fromPartial(object.memoryPool)
      : undefined;
    message.memory = (object.memory !== undefined && object.memory !== null)
      ? MemoryDTO.fromPartial(object.memory)
      : undefined;
    message.probability = object.probability ?? 0;
    message.defaultClarity = object.defaultClarity ?? 0;
    message.defaultImportance = object.defaultImportance ?? 0;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseMemoryPoolEntriesDTO(): MemoryPoolEntriesDTO {
  return { memoryPoolEntries: [] };
}

export const MemoryPoolEntriesDTO: MessageFns<MemoryPoolEntriesDTO> = {
  encode(message: MemoryPoolEntriesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.memoryPoolEntries) {
      MemoryPoolEntriesDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolEntriesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolEntriesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.memoryPoolEntries.push(MemoryPoolEntriesDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolEntriesDTO {
    return {
      memoryPoolEntries: globalThis.Array.isArray(object?.memoryPoolEntries)
        ? object.memoryPoolEntries.map((e: any) => MemoryPoolEntriesDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MemoryPoolEntriesDTO): unknown {
    const obj: any = {};
    if (message.memoryPoolEntries?.length) {
      obj.memoryPoolEntries = message.memoryPoolEntries.map((e) => MemoryPoolEntriesDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolEntriesDTO>, I>>(base?: I): MemoryPoolEntriesDTO {
    return MemoryPoolEntriesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolEntriesDTO>, I>>(object: I): MemoryPoolEntriesDTO {
    const message = createBaseMemoryPoolEntriesDTO();
    message.memoryPoolEntries = object.memoryPoolEntries?.map((e) => MemoryPoolEntriesDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterProfessionDTO(): CharacterProfessionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    characters: undefined,
    tags: undefined,
    memoryPools: undefined,
    targetEntity: "",
  };
}

export const CharacterProfessionDTO: MessageFns<CharacterProfessionDTO> = {
  encode(message: CharacterProfessionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.characters !== undefined) {
      CharactersDTO.encode(message.characters, writer.uint32(66).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(74).fork()).join();
    }
    if (message.memoryPools !== undefined) {
      MemoryPoolsDTO.encode(message.memoryPools, writer.uint32(82).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfessionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfessionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.characters = CharactersDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.memoryPools = MemoryPoolsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfessionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      characters: isSet(object.characters) ? CharactersDTO.fromJSON(object.characters) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      memoryPools: isSet(object.memoryPools) ? MemoryPoolsDTO.fromJSON(object.memoryPools) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: CharacterProfessionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.characters !== undefined) {
      obj.characters = CharactersDTO.toJSON(message.characters);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.memoryPools !== undefined) {
      obj.memoryPools = MemoryPoolsDTO.toJSON(message.memoryPools);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfessionDTO>, I>>(base?: I): CharacterProfessionDTO {
    return CharacterProfessionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfessionDTO>, I>>(object: I): CharacterProfessionDTO {
    const message = createBaseCharacterProfessionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.characters = (object.characters !== undefined && object.characters !== null)
      ? CharactersDTO.fromPartial(object.characters)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.memoryPools = (object.memoryPools !== undefined && object.memoryPools !== null)
      ? MemoryPoolsDTO.fromPartial(object.memoryPools)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseCharacterProfessionsDTO(): CharacterProfessionsDTO {
  return { professions: [] };
}

export const CharacterProfessionsDTO: MessageFns<CharacterProfessionsDTO> = {
  encode(message: CharacterProfessionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.professions) {
      CharacterProfessionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfessionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfessionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.professions.push(CharacterProfessionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfessionsDTO {
    return {
      professions: globalThis.Array.isArray(object?.professions)
        ? object.professions.map((e: any) => CharacterProfessionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterProfessionsDTO): unknown {
    const obj: any = {};
    if (message.professions?.length) {
      obj.professions = message.professions.map((e) => CharacterProfessionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfessionsDTO>, I>>(base?: I): CharacterProfessionsDTO {
    return CharacterProfessionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfessionsDTO>, I>>(object: I): CharacterProfessionsDTO {
    const message = createBaseCharacterProfessionsDTO();
    message.professions = object.professions?.map((e) => CharacterProfessionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEquipmentSlotDTO(): EquipmentSlotDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    allowedEntities: [],
    equippedItem: undefined,
    character: undefined,
    targetEntity: "",
  };
}

export const EquipmentSlotDTO: MessageFns<EquipmentSlotDTO> = {
  encode(message: EquipmentSlotDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    for (const v of message.allowedEntities) {
      writer.uint32(66).string(v!);
    }
    if (message.equippedItem !== undefined) {
      ItemDTO.encode(message.equippedItem, writer.uint32(74).fork()).join();
    }
    if (message.character !== undefined) {
      CharacterDTO.encode(message.character, writer.uint32(82).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlotDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlotDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.allowedEntities.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.equippedItem = ItemDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.character = CharacterDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlotDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      allowedEntities: globalThis.Array.isArray(object?.allowedEntities)
        ? object.allowedEntities.map((e: any) => globalThis.String(e))
        : [],
      equippedItem: isSet(object.equippedItem) ? ItemDTO.fromJSON(object.equippedItem) : undefined,
      character: isSet(object.character) ? CharacterDTO.fromJSON(object.character) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: EquipmentSlotDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.allowedEntities?.length) {
      obj.allowedEntities = message.allowedEntities;
    }
    if (message.equippedItem !== undefined) {
      obj.equippedItem = ItemDTO.toJSON(message.equippedItem);
    }
    if (message.character !== undefined) {
      obj.character = CharacterDTO.toJSON(message.character);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlotDTO>, I>>(base?: I): EquipmentSlotDTO {
    return EquipmentSlotDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlotDTO>, I>>(object: I): EquipmentSlotDTO {
    const message = createBaseEquipmentSlotDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.allowedEntities = object.allowedEntities?.map((e) => e) || [];
    message.equippedItem = (object.equippedItem !== undefined && object.equippedItem !== null)
      ? ItemDTO.fromPartial(object.equippedItem)
      : undefined;
    message.character = (object.character !== undefined && object.character !== null)
      ? CharacterDTO.fromPartial(object.character)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseEquipmentSlotsDTO(): EquipmentSlotsDTO {
  return { equipmentSlots: [] };
}

export const EquipmentSlotsDTO: MessageFns<EquipmentSlotsDTO> = {
  encode(message: EquipmentSlotsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.equipmentSlots) {
      EquipmentSlotDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlotsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlotsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.equipmentSlots.push(EquipmentSlotDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlotsDTO {
    return {
      equipmentSlots: globalThis.Array.isArray(object?.equipmentSlots)
        ? object.equipmentSlots.map((e: any) => EquipmentSlotDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EquipmentSlotsDTO): unknown {
    const obj: any = {};
    if (message.equipmentSlots?.length) {
      obj.equipmentSlots = message.equipmentSlots.map((e) => EquipmentSlotDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlotsDTO>, I>>(base?: I): EquipmentSlotsDTO {
    return EquipmentSlotsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlotsDTO>, I>>(object: I): EquipmentSlotsDTO {
    const message = createBaseEquipmentSlotsDTO();
    message.equipmentSlots = object.equipmentSlots?.map((e) => EquipmentSlotDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBirthsignDTO(): BirthsignDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    targetEntity: "",
  };
}

export const BirthsignDTO: MessageFns<BirthsignDTO> = {
  encode(message: BirthsignDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(66).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BirthsignDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBirthsignDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BirthsignDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: BirthsignDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BirthsignDTO>, I>>(base?: I): BirthsignDTO {
    return BirthsignDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BirthsignDTO>, I>>(object: I): BirthsignDTO {
    const message = createBaseBirthsignDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseBirthsignsDTO(): BirthsignsDTO {
  return { birthSigns: [] };
}

export const BirthsignsDTO: MessageFns<BirthsignsDTO> = {
  encode(message: BirthsignsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.birthSigns) {
      BirthsignDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BirthsignsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBirthsignsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.birthSigns.push(BirthsignDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BirthsignsDTO {
    return {
      birthSigns: globalThis.Array.isArray(object?.birthSigns)
        ? object.birthSigns.map((e: any) => BirthsignDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BirthsignsDTO): unknown {
    const obj: any = {};
    if (message.birthSigns?.length) {
      obj.birthSigns = message.birthSigns.map((e) => BirthsignDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BirthsignsDTO>, I>>(base?: I): BirthsignsDTO {
    return BirthsignsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BirthsignsDTO>, I>>(object: I): BirthsignsDTO {
    const message = createBaseBirthsignsDTO();
    message.birthSigns = object.birthSigns?.map((e) => BirthsignDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRaceDTO(): RaceDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    equipmentSlotDefinitions: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    metadata: undefined,
    targetEntity: "",
  };
}

export const RaceDTO: MessageFns<RaceDTO> = {
  encode(message: RaceDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.equipmentSlotDefinitions !== undefined) {
      EquipmentSlotDefinitionsDTO.encode(message.equipmentSlotDefinitions, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(66).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RaceDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRaceDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.equipmentSlotDefinitions = EquipmentSlotDefinitionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RaceDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      equipmentSlotDefinitions: isSet(object.equipmentSlotDefinitions)
        ? EquipmentSlotDefinitionsDTO.fromJSON(object.equipmentSlotDefinitions)
        : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: RaceDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.equipmentSlotDefinitions !== undefined) {
      obj.equipmentSlotDefinitions = EquipmentSlotDefinitionsDTO.toJSON(message.equipmentSlotDefinitions);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RaceDTO>, I>>(base?: I): RaceDTO {
    return RaceDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RaceDTO>, I>>(object: I): RaceDTO {
    const message = createBaseRaceDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.equipmentSlotDefinitions =
      (object.equipmentSlotDefinitions !== undefined && object.equipmentSlotDefinitions !== null)
        ? EquipmentSlotDefinitionsDTO.fromPartial(object.equipmentSlotDefinitions)
        : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseRacesDTO(): RacesDTO {
  return { races: [] };
}

export const RacesDTO: MessageFns<RacesDTO> = {
  encode(message: RacesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.races) {
      RaceDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RacesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRacesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.races.push(RaceDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RacesDTO {
    return { races: globalThis.Array.isArray(object?.races) ? object.races.map((e: any) => RaceDTO.fromJSON(e)) : [] };
  },

  toJSON(message: RacesDTO): unknown {
    const obj: any = {};
    if (message.races?.length) {
      obj.races = message.races.map((e) => RaceDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RacesDTO>, I>>(base?: I): RacesDTO {
    return RacesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RacesDTO>, I>>(object: I): RacesDTO {
    const message = createBaseRacesDTO();
    message.races = object.races?.map((e) => RaceDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEquipmentSlotDefinitionDTO(): EquipmentSlotDefinitionDTO {
  return { name: "", allowedEntities: [] };
}

export const EquipmentSlotDefinitionDTO: MessageFns<EquipmentSlotDefinitionDTO> = {
  encode(message: EquipmentSlotDefinitionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.allowedEntities) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlotDefinitionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlotDefinitionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowedEntities.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlotDefinitionDTO {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      allowedEntities: globalThis.Array.isArray(object?.allowedEntities)
        ? object.allowedEntities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EquipmentSlotDefinitionDTO): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.allowedEntities?.length) {
      obj.allowedEntities = message.allowedEntities;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlotDefinitionDTO>, I>>(base?: I): EquipmentSlotDefinitionDTO {
    return EquipmentSlotDefinitionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlotDefinitionDTO>, I>>(object: I): EquipmentSlotDefinitionDTO {
    const message = createBaseEquipmentSlotDefinitionDTO();
    message.name = object.name ?? "";
    message.allowedEntities = object.allowedEntities?.map((e) => e) || [];
    return message;
  },
};

function createBaseEquipmentSlotDefinitionsDTO(): EquipmentSlotDefinitionsDTO {
  return { equipmentSlotDefinition: [] };
}

export const EquipmentSlotDefinitionsDTO: MessageFns<EquipmentSlotDefinitionsDTO> = {
  encode(message: EquipmentSlotDefinitionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.equipmentSlotDefinition) {
      EquipmentSlotDefinitionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlotDefinitionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlotDefinitionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.equipmentSlotDefinition.push(EquipmentSlotDefinitionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlotDefinitionsDTO {
    return {
      equipmentSlotDefinition: globalThis.Array.isArray(object?.equipmentSlotDefinition)
        ? object.equipmentSlotDefinition.map((e: any) => EquipmentSlotDefinitionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EquipmentSlotDefinitionsDTO): unknown {
    const obj: any = {};
    if (message.equipmentSlotDefinition?.length) {
      obj.equipmentSlotDefinition = message.equipmentSlotDefinition.map((e) => EquipmentSlotDefinitionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlotDefinitionsDTO>, I>>(base?: I): EquipmentSlotDefinitionsDTO {
    return EquipmentSlotDefinitionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlotDefinitionsDTO>, I>>(object: I): EquipmentSlotDefinitionsDTO {
    const message = createBaseEquipmentSlotDefinitionsDTO();
    message.equipmentSlotDefinition =
      object.equipmentSlotDefinition?.map((e) => EquipmentSlotDefinitionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorageSlotDefinitionDTO(): StorageSlotDefinitionDTO {
  return { grid: [], name: "", maxWeight: 0 };
}

export const StorageSlotDefinitionDTO: MessageFns<StorageSlotDefinitionDTO> = {
  encode(message: StorageSlotDefinitionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.grid) {
      writer.int32(v);
    }
    writer.join();
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.maxWeight !== 0) {
      writer.uint32(24).int32(message.maxWeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlotDefinitionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlotDefinitionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.grid.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.grid.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxWeight = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlotDefinitionDTO {
    return {
      grid: globalThis.Array.isArray(object?.grid) ? object.grid.map((e: any) => globalThis.Number(e)) : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      maxWeight: isSet(object.maxWeight) ? globalThis.Number(object.maxWeight) : 0,
    };
  },

  toJSON(message: StorageSlotDefinitionDTO): unknown {
    const obj: any = {};
    if (message.grid?.length) {
      obj.grid = message.grid.map((e) => Math.round(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.maxWeight !== 0) {
      obj.maxWeight = Math.round(message.maxWeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlotDefinitionDTO>, I>>(base?: I): StorageSlotDefinitionDTO {
    return StorageSlotDefinitionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlotDefinitionDTO>, I>>(object: I): StorageSlotDefinitionDTO {
    const message = createBaseStorageSlotDefinitionDTO();
    message.grid = object.grid?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.maxWeight = object.maxWeight ?? 0;
    return message;
  },
};

function createBaseStorageSlotDefinitionsDTO(): StorageSlotDefinitionsDTO {
  return { definitions: [] };
}

export const StorageSlotDefinitionsDTO: MessageFns<StorageSlotDefinitionsDTO> = {
  encode(message: StorageSlotDefinitionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.definitions) {
      StorageSlotDefinitionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlotDefinitionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlotDefinitionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.definitions.push(StorageSlotDefinitionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlotDefinitionsDTO {
    return {
      definitions: globalThis.Array.isArray(object?.definitions)
        ? object.definitions.map((e: any) => StorageSlotDefinitionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StorageSlotDefinitionsDTO): unknown {
    const obj: any = {};
    if (message.definitions?.length) {
      obj.definitions = message.definitions.map((e) => StorageSlotDefinitionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlotDefinitionsDTO>, I>>(base?: I): StorageSlotDefinitionsDTO {
    return StorageSlotDefinitionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlotDefinitionsDTO>, I>>(object: I): StorageSlotDefinitionsDTO {
    const message = createBaseStorageSlotDefinitionsDTO();
    message.definitions = object.definitions?.map((e) => StorageSlotDefinitionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMoodDTO(): MoodDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
    targetEntity: "",
  };
}

export const MoodDTO: MessageFns<MoodDTO> = {
  encode(message: MoodDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoodDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoodDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoodDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: MoodDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoodDTO>, I>>(base?: I): MoodDTO {
    return MoodDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoodDTO>, I>>(object: I): MoodDTO {
    const message = createBaseMoodDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.description = object.description ?? "";
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseMoodsDTO(): MoodsDTO {
  return { moods: [] };
}

export const MoodsDTO: MessageFns<MoodsDTO> = {
  encode(message: MoodsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.moods) {
      MoodDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoodsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoodsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.moods.push(MoodDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoodsDTO {
    return { moods: globalThis.Array.isArray(object?.moods) ? object.moods.map((e: any) => MoodDTO.fromJSON(e)) : [] };
  },

  toJSON(message: MoodsDTO): unknown {
    const obj: any = {};
    if (message.moods?.length) {
      obj.moods = message.moods.map((e) => MoodDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MoodsDTO>, I>>(base?: I): MoodsDTO {
    return MoodsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MoodsDTO>, I>>(object: I): MoodsDTO {
    const message = createBaseMoodsDTO();
    message.moods = object.moods?.map((e) => MoodDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReligionDTO(): ReligionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
    rituals: undefined,
    tenets: undefined,
    targetEntity: "",
  };
}

export const ReligionDTO: MessageFns<ReligionDTO> = {
  encode(message: ReligionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.rituals !== undefined) {
      ReligionRitualsDTO.encode(message.rituals, writer.uint32(74).fork()).join();
    }
    if (message.tenets !== undefined) {
      ReligionTenetsDTO.encode(message.tenets, writer.uint32(82).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rituals = ReligionRitualsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tenets = ReligionTenetsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      rituals: isSet(object.rituals) ? ReligionRitualsDTO.fromJSON(object.rituals) : undefined,
      tenets: isSet(object.tenets) ? ReligionTenetsDTO.fromJSON(object.tenets) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: ReligionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.rituals !== undefined) {
      obj.rituals = ReligionRitualsDTO.toJSON(message.rituals);
    }
    if (message.tenets !== undefined) {
      obj.tenets = ReligionTenetsDTO.toJSON(message.tenets);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionDTO>, I>>(base?: I): ReligionDTO {
    return ReligionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionDTO>, I>>(object: I): ReligionDTO {
    const message = createBaseReligionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.description = object.description ?? "";
    message.rituals = (object.rituals !== undefined && object.rituals !== null)
      ? ReligionRitualsDTO.fromPartial(object.rituals)
      : undefined;
    message.tenets = (object.tenets !== undefined && object.tenets !== null)
      ? ReligionTenetsDTO.fromPartial(object.tenets)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseReligionsDTO(): ReligionsDTO {
  return { moods: [] };
}

export const ReligionsDTO: MessageFns<ReligionsDTO> = {
  encode(message: ReligionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.moods) {
      ReligionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.moods.push(ReligionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionsDTO {
    return {
      moods: globalThis.Array.isArray(object?.moods) ? object.moods.map((e: any) => ReligionDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReligionsDTO): unknown {
    const obj: any = {};
    if (message.moods?.length) {
      obj.moods = message.moods.map((e) => ReligionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionsDTO>, I>>(base?: I): ReligionsDTO {
    return ReligionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionsDTO>, I>>(object: I): ReligionsDTO {
    const message = createBaseReligionsDTO();
    message.moods = object.moods?.map((e) => ReligionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReligionRitualDTO(): ReligionRitualDTO {
  return { name: "", description: "" };
}

export const ReligionRitualDTO: MessageFns<ReligionRitualDTO> = {
  encode(message: ReligionRitualDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionRitualDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionRitualDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionRitualDTO {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ReligionRitualDTO): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionRitualDTO>, I>>(base?: I): ReligionRitualDTO {
    return ReligionRitualDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionRitualDTO>, I>>(object: I): ReligionRitualDTO {
    const message = createBaseReligionRitualDTO();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseReligionRitualsDTO(): ReligionRitualsDTO {
  return { religionRituals: [] };
}

export const ReligionRitualsDTO: MessageFns<ReligionRitualsDTO> = {
  encode(message: ReligionRitualsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.religionRituals) {
      ReligionRitualDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionRitualsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionRitualsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.religionRituals.push(ReligionRitualDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionRitualsDTO {
    return {
      religionRituals: globalThis.Array.isArray(object?.religionRituals)
        ? object.religionRituals.map((e: any) => ReligionRitualDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReligionRitualsDTO): unknown {
    const obj: any = {};
    if (message.religionRituals?.length) {
      obj.religionRituals = message.religionRituals.map((e) => ReligionRitualDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionRitualsDTO>, I>>(base?: I): ReligionRitualsDTO {
    return ReligionRitualsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionRitualsDTO>, I>>(object: I): ReligionRitualsDTO {
    const message = createBaseReligionRitualsDTO();
    message.religionRituals = object.religionRituals?.map((e) => ReligionRitualDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReligionTenetDTO(): ReligionTenetDTO {
  return { name: "", description: "" };
}

export const ReligionTenetDTO: MessageFns<ReligionTenetDTO> = {
  encode(message: ReligionTenetDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionTenetDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionTenetDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionTenetDTO {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ReligionTenetDTO): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionTenetDTO>, I>>(base?: I): ReligionTenetDTO {
    return ReligionTenetDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionTenetDTO>, I>>(object: I): ReligionTenetDTO {
    const message = createBaseReligionTenetDTO();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseReligionTenetsDTO(): ReligionTenetsDTO {
  return { religionTenets: [] };
}

export const ReligionTenetsDTO: MessageFns<ReligionTenetsDTO> = {
  encode(message: ReligionTenetsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.religionTenets) {
      ReligionTenetDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionTenetsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionTenetsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.religionTenets.push(ReligionTenetDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionTenetsDTO {
    return {
      religionTenets: globalThis.Array.isArray(object?.religionTenets)
        ? object.religionTenets.map((e: any) => ReligionTenetDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReligionTenetsDTO): unknown {
    const obj: any = {};
    if (message.religionTenets?.length) {
      obj.religionTenets = message.religionTenets.map((e) => ReligionTenetDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionTenetsDTO>, I>>(base?: I): ReligionTenetsDTO {
    return ReligionTenetsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionTenetsDTO>, I>>(object: I): ReligionTenetsDTO {
    const message = createBaseReligionTenetsDTO();
    message.religionTenets = object.religionTenets?.map((e) => ReligionTenetDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGridPositionDTO(): GridPositionDTO {
  return { x: 0, y: 0 };
}

export const GridPositionDTO: MessageFns<GridPositionDTO> = {
  encode(message: GridPositionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GridPositionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGridPositionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GridPositionDTO {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: GridPositionDTO): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GridPositionDTO>, I>>(base?: I): GridPositionDTO {
    return GridPositionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GridPositionDTO>, I>>(object: I): GridPositionDTO {
    const message = createBaseGridPositionDTO();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseGenerationInstructionDTO(): GenerationInstructionDTO {
  return {
    blueprintId: undefined,
    idsAndQuant: undefined,
    simpleProb: undefined,
    gaussianProb: undefined,
    combinator: undefined,
  };
}

export const GenerationInstructionDTO: MessageFns<GenerationInstructionDTO> = {
  encode(message: GenerationInstructionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== undefined) {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.idsAndQuant !== undefined) {
      IdAndQuantDTO.encode(message.idsAndQuant, writer.uint32(18).fork()).join();
    }
    if (message.simpleProb !== undefined) {
      SimpleProbDTO.encode(message.simpleProb, writer.uint32(26).fork()).join();
    }
    if (message.gaussianProb !== undefined) {
      GaussianProbDTO.encode(message.gaussianProb, writer.uint32(34).fork()).join();
    }
    if (message.combinator !== undefined) {
      CombinatorDTO.encode(message.combinator, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationInstructionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationInstructionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idsAndQuant = IdAndQuantDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.simpleProb = SimpleProbDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gaussianProb = GaussianProbDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.combinator = CombinatorDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationInstructionDTO {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : undefined,
      idsAndQuant: isSet(object.idsAndQuant) ? IdAndQuantDTO.fromJSON(object.idsAndQuant) : undefined,
      simpleProb: isSet(object.simpleProb) ? SimpleProbDTO.fromJSON(object.simpleProb) : undefined,
      gaussianProb: isSet(object.gaussianProb) ? GaussianProbDTO.fromJSON(object.gaussianProb) : undefined,
      combinator: isSet(object.combinator) ? CombinatorDTO.fromJSON(object.combinator) : undefined,
    };
  },

  toJSON(message: GenerationInstructionDTO): unknown {
    const obj: any = {};
    if (message.blueprintId !== undefined) {
      obj.blueprintId = message.blueprintId;
    }
    if (message.idsAndQuant !== undefined) {
      obj.idsAndQuant = IdAndQuantDTO.toJSON(message.idsAndQuant);
    }
    if (message.simpleProb !== undefined) {
      obj.simpleProb = SimpleProbDTO.toJSON(message.simpleProb);
    }
    if (message.gaussianProb !== undefined) {
      obj.gaussianProb = GaussianProbDTO.toJSON(message.gaussianProb);
    }
    if (message.combinator !== undefined) {
      obj.combinator = CombinatorDTO.toJSON(message.combinator);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerationInstructionDTO>, I>>(base?: I): GenerationInstructionDTO {
    return GenerationInstructionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerationInstructionDTO>, I>>(object: I): GenerationInstructionDTO {
    const message = createBaseGenerationInstructionDTO();
    message.blueprintId = object.blueprintId ?? undefined;
    message.idsAndQuant = (object.idsAndQuant !== undefined && object.idsAndQuant !== null)
      ? IdAndQuantDTO.fromPartial(object.idsAndQuant)
      : undefined;
    message.simpleProb = (object.simpleProb !== undefined && object.simpleProb !== null)
      ? SimpleProbDTO.fromPartial(object.simpleProb)
      : undefined;
    message.gaussianProb = (object.gaussianProb !== undefined && object.gaussianProb !== null)
      ? GaussianProbDTO.fromPartial(object.gaussianProb)
      : undefined;
    message.combinator = (object.combinator !== undefined && object.combinator !== null)
      ? CombinatorDTO.fromPartial(object.combinator)
      : undefined;
    return message;
  },
};

function createBaseGenerationInstructionsDTO(): GenerationInstructionsDTO {
  return { instructions: [] };
}

export const GenerationInstructionsDTO: MessageFns<GenerationInstructionsDTO> = {
  encode(message: GenerationInstructionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instructions) {
      GenerationInstructionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationInstructionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationInstructionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instructions.push(GenerationInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationInstructionsDTO {
    return {
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => GenerationInstructionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenerationInstructionsDTO): unknown {
    const obj: any = {};
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => GenerationInstructionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerationInstructionsDTO>, I>>(base?: I): GenerationInstructionsDTO {
    return GenerationInstructionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerationInstructionsDTO>, I>>(object: I): GenerationInstructionsDTO {
    const message = createBaseGenerationInstructionsDTO();
    message.instructions = object.instructions?.map((e) => GenerationInstructionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseIdAndQuantDTO(): IdAndQuantDTO {
  return { idAndQuant: {} };
}

export const IdAndQuantDTO: MessageFns<IdAndQuantDTO> = {
  encode(message: IdAndQuantDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.idAndQuant).forEach(([key, value]) => {
      IdAndQuantDTO_IdAndQuantEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdAndQuantDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdAndQuantDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = IdAndQuantDTO_IdAndQuantEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.idAndQuant[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdAndQuantDTO {
    return {
      idAndQuant: isObject(object.idAndQuant)
        ? Object.entries(object.idAndQuant).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: IdAndQuantDTO): unknown {
    const obj: any = {};
    if (message.idAndQuant) {
      const entries = Object.entries(message.idAndQuant);
      if (entries.length > 0) {
        obj.idAndQuant = {};
        entries.forEach(([k, v]) => {
          obj.idAndQuant[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdAndQuantDTO>, I>>(base?: I): IdAndQuantDTO {
    return IdAndQuantDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdAndQuantDTO>, I>>(object: I): IdAndQuantDTO {
    const message = createBaseIdAndQuantDTO();
    message.idAndQuant = Object.entries(object.idAndQuant ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseIdAndQuantDTO_IdAndQuantEntry(): IdAndQuantDTO_IdAndQuantEntry {
  return { key: "", value: 0 };
}

export const IdAndQuantDTO_IdAndQuantEntry: MessageFns<IdAndQuantDTO_IdAndQuantEntry> = {
  encode(message: IdAndQuantDTO_IdAndQuantEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdAndQuantDTO_IdAndQuantEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdAndQuantDTO_IdAndQuantEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdAndQuantDTO_IdAndQuantEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: IdAndQuantDTO_IdAndQuantEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdAndQuantDTO_IdAndQuantEntry>, I>>(base?: I): IdAndQuantDTO_IdAndQuantEntry {
    return IdAndQuantDTO_IdAndQuantEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdAndQuantDTO_IdAndQuantEntry>, I>>(
    object: I,
  ): IdAndQuantDTO_IdAndQuantEntry {
    const message = createBaseIdAndQuantDTO_IdAndQuantEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseIdsAndQuantsDTO(): IdsAndQuantsDTO {
  return { idsAndQuants: [] };
}

export const IdsAndQuantsDTO: MessageFns<IdsAndQuantsDTO> = {
  encode(message: IdsAndQuantsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.idsAndQuants) {
      IdAndQuantDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdsAndQuantsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdsAndQuantsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.idsAndQuants.push(IdAndQuantDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdsAndQuantsDTO {
    return {
      idsAndQuants: globalThis.Array.isArray(object?.idsAndQuants)
        ? object.idsAndQuants.map((e: any) => IdAndQuantDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: IdsAndQuantsDTO): unknown {
    const obj: any = {};
    if (message.idsAndQuants?.length) {
      obj.idsAndQuants = message.idsAndQuants.map((e) => IdAndQuantDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdsAndQuantsDTO>, I>>(base?: I): IdsAndQuantsDTO {
    return IdsAndQuantsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdsAndQuantsDTO>, I>>(object: I): IdsAndQuantsDTO {
    const message = createBaseIdsAndQuantsDTO();
    message.idsAndQuants = object.idsAndQuants?.map((e) => IdAndQuantDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterGenInstructionDTO(): CharacterGenInstructionDTO {
  return {
    blueprintId: "",
    backgroundBlueprintId: "",
    targetEntity: "",
    firstName: undefined,
    lastName: undefined,
    gender: undefined,
    birthEra: undefined,
    birthYear: undefined,
    birthMonth: undefined,
    birthDay: undefined,
    backgroundCustomization: undefined,
    birthSign: undefined,
    id: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
  };
}

export const CharacterGenInstructionDTO: MessageFns<CharacterGenInstructionDTO> = {
  encode(message: CharacterGenInstructionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.backgroundBlueprintId !== "") {
      writer.uint32(18).string(message.backgroundBlueprintId);
    }
    if (message.targetEntity !== "") {
      writer.uint32(26).string(message.targetEntity);
    }
    if (message.firstName !== undefined) {
      writer.uint32(34).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(42).string(message.lastName);
    }
    if (message.gender !== undefined) {
      writer.uint32(50).string(message.gender);
    }
    if (message.birthEra !== undefined) {
      writer.uint32(58).string(message.birthEra);
    }
    if (message.birthYear !== undefined) {
      writer.uint32(64).int32(message.birthYear);
    }
    if (message.birthMonth !== undefined) {
      writer.uint32(74).string(message.birthMonth);
    }
    if (message.birthDay !== undefined) {
      writer.uint32(80).int32(message.birthDay);
    }
    if (message.backgroundCustomization !== undefined) {
      BackgroundCustomizationDTO.encode(message.backgroundCustomization, writer.uint32(90).fork()).join();
    }
    if (message.birthSign !== undefined) {
      writer.uint32(98).string(message.birthSign);
    }
    if (message.id !== "") {
      writer.uint32(106).string(message.id);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(114).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(122).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(130).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGenInstructionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGenInstructionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.backgroundBlueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.birthEra = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.birthYear = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.birthMonth = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.birthDay = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.backgroundCustomization = BackgroundCustomizationDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.birthSign = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGenInstructionDTO {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      backgroundBlueprintId: isSet(object.backgroundBlueprintId) ? globalThis.String(object.backgroundBlueprintId) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
      gender: isSet(object.gender) ? globalThis.String(object.gender) : undefined,
      birthEra: isSet(object.birthEra) ? globalThis.String(object.birthEra) : undefined,
      birthYear: isSet(object.birthYear) ? globalThis.Number(object.birthYear) : undefined,
      birthMonth: isSet(object.birthMonth) ? globalThis.String(object.birthMonth) : undefined,
      birthDay: isSet(object.birthDay) ? globalThis.Number(object.birthDay) : undefined,
      backgroundCustomization: isSet(object.backgroundCustomization)
        ? BackgroundCustomizationDTO.fromJSON(object.backgroundCustomization)
        : undefined,
      birthSign: isSet(object.birthSign) ? globalThis.String(object.birthSign) : undefined,
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
    };
  },

  toJSON(message: CharacterGenInstructionDTO): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.backgroundBlueprintId !== "") {
      obj.backgroundBlueprintId = message.backgroundBlueprintId;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    if (message.gender !== undefined) {
      obj.gender = message.gender;
    }
    if (message.birthEra !== undefined) {
      obj.birthEra = message.birthEra;
    }
    if (message.birthYear !== undefined) {
      obj.birthYear = Math.round(message.birthYear);
    }
    if (message.birthMonth !== undefined) {
      obj.birthMonth = message.birthMonth;
    }
    if (message.birthDay !== undefined) {
      obj.birthDay = Math.round(message.birthDay);
    }
    if (message.backgroundCustomization !== undefined) {
      obj.backgroundCustomization = BackgroundCustomizationDTO.toJSON(message.backgroundCustomization);
    }
    if (message.birthSign !== undefined) {
      obj.birthSign = message.birthSign;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGenInstructionDTO>, I>>(base?: I): CharacterGenInstructionDTO {
    return CharacterGenInstructionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGenInstructionDTO>, I>>(object: I): CharacterGenInstructionDTO {
    const message = createBaseCharacterGenInstructionDTO();
    message.blueprintId = object.blueprintId ?? "";
    message.backgroundBlueprintId = object.backgroundBlueprintId ?? "";
    message.targetEntity = object.targetEntity ?? "";
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    message.gender = object.gender ?? undefined;
    message.birthEra = object.birthEra ?? undefined;
    message.birthYear = object.birthYear ?? undefined;
    message.birthMonth = object.birthMonth ?? undefined;
    message.birthDay = object.birthDay ?? undefined;
    message.backgroundCustomization =
      (object.backgroundCustomization !== undefined && object.backgroundCustomization !== null)
        ? BackgroundCustomizationDTO.fromPartial(object.backgroundCustomization)
        : undefined;
    message.birthSign = object.birthSign ?? undefined;
    message.id = object.id ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    return message;
  },
};

function createBaseCharacterGenInstructions(): CharacterGenInstructions {
  return { characterGenInstructions: [] };
}

export const CharacterGenInstructions: MessageFns<CharacterGenInstructions> = {
  encode(message: CharacterGenInstructions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.characterGenInstructions) {
      CharacterGenInstructionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGenInstructions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGenInstructions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterGenInstructions.push(CharacterGenInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGenInstructions {
    return {
      characterGenInstructions: globalThis.Array.isArray(object?.characterGenInstructions)
        ? object.characterGenInstructions.map((e: any) => CharacterGenInstructionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterGenInstructions): unknown {
    const obj: any = {};
    if (message.characterGenInstructions?.length) {
      obj.characterGenInstructions = message.characterGenInstructions.map((e) => CharacterGenInstructionDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGenInstructions>, I>>(base?: I): CharacterGenInstructions {
    return CharacterGenInstructions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGenInstructions>, I>>(object: I): CharacterGenInstructions {
    const message = createBaseCharacterGenInstructions();
    message.characterGenInstructions =
      object.characterGenInstructions?.map((e) => CharacterGenInstructionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacterGroupGenInstructionDTO(): CharacterGroupGenInstructionDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    set: undefined,
    targetEntity: "",
  };
}

export const CharacterGroupGenInstructionDTO: MessageFns<CharacterGroupGenInstructionDTO> = {
  encode(message: CharacterGroupGenInstructionDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.set !== undefined) {
      CombinatorDTO.encode(message.set, writer.uint32(66).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(74).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGroupGenInstructionDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGroupGenInstructionDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.set = CombinatorDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGroupGenInstructionDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      set: isSet(object.set) ? CombinatorDTO.fromJSON(object.set) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: CharacterGroupGenInstructionDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.set !== undefined) {
      obj.set = CombinatorDTO.toJSON(message.set);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGroupGenInstructionDTO>, I>>(base?: I): CharacterGroupGenInstructionDTO {
    return CharacterGroupGenInstructionDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGroupGenInstructionDTO>, I>>(
    object: I,
  ): CharacterGroupGenInstructionDTO {
    const message = createBaseCharacterGroupGenInstructionDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.set = (object.set !== undefined && object.set !== null) ? CombinatorDTO.fromPartial(object.set) : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseCharacterGroupGenInstructionsDTO(): CharacterGroupGenInstructionsDTO {
  return { characterGroupGenInstructions: [] };
}

export const CharacterGroupGenInstructionsDTO: MessageFns<CharacterGroupGenInstructionsDTO> = {
  encode(message: CharacterGroupGenInstructionsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.characterGroupGenInstructions) {
      CharacterGroupGenInstructionDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGroupGenInstructionsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGroupGenInstructionsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.characterGroupGenInstructions.push(CharacterGroupGenInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGroupGenInstructionsDTO {
    return {
      characterGroupGenInstructions: globalThis.Array.isArray(object?.characterGroupGenInstructions)
        ? object.characterGroupGenInstructions.map((e: any) => CharacterGroupGenInstructionDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CharacterGroupGenInstructionsDTO): unknown {
    const obj: any = {};
    if (message.characterGroupGenInstructions?.length) {
      obj.characterGroupGenInstructions = message.characterGroupGenInstructions.map((e) =>
        CharacterGroupGenInstructionDTO.toJSON(e)
      );
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGroupGenInstructionsDTO>, I>>(
    base?: I,
  ): CharacterGroupGenInstructionsDTO {
    return CharacterGroupGenInstructionsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGroupGenInstructionsDTO>, I>>(
    object: I,
  ): CharacterGroupGenInstructionsDTO {
    const message = createBaseCharacterGroupGenInstructionsDTO();
    message.characterGroupGenInstructions =
      object.characterGroupGenInstructions?.map((e) => CharacterGroupGenInstructionDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBackgroundCustomizationDTO(): BackgroundCustomizationDTO {
  return {
    race: undefined,
    faction: undefined,
    disease: undefined,
    addiction: undefined,
    profession: undefined,
    religion: undefined,
    itemSets: undefined,
    items: undefined,
    pastExpChild: undefined,
    pastExpAdult: undefined,
    skillSets: undefined,
    skillAdjustments: undefined,
    personality: undefined,
  };
}

export const BackgroundCustomizationDTO: MessageFns<BackgroundCustomizationDTO> = {
  encode(message: BackgroundCustomizationDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.race !== undefined) {
      GenerationInstructionsDTO.encode(message.race, writer.uint32(10).fork()).join();
    }
    if (message.faction !== undefined) {
      GenerationInstructionsDTO.encode(message.faction, writer.uint32(18).fork()).join();
    }
    if (message.disease !== undefined) {
      GenerationInstructionsDTO.encode(message.disease, writer.uint32(26).fork()).join();
    }
    if (message.addiction !== undefined) {
      GenerationInstructionsDTO.encode(message.addiction, writer.uint32(34).fork()).join();
    }
    if (message.profession !== undefined) {
      GenerationInstructionsDTO.encode(message.profession, writer.uint32(42).fork()).join();
    }
    if (message.religion !== undefined) {
      GenerationInstructionsDTO.encode(message.religion, writer.uint32(50).fork()).join();
    }
    if (message.itemSets !== undefined) {
      GenerationInstructionsDTO.encode(message.itemSets, writer.uint32(58).fork()).join();
    }
    if (message.items !== undefined) {
      GenerationInstructionsDTO.encode(message.items, writer.uint32(66).fork()).join();
    }
    if (message.pastExpChild !== undefined) {
      GenerationInstructionsDTO.encode(message.pastExpChild, writer.uint32(74).fork()).join();
    }
    if (message.pastExpAdult !== undefined) {
      GenerationInstructionsDTO.encode(message.pastExpAdult, writer.uint32(82).fork()).join();
    }
    if (message.skillSets !== undefined) {
      GenerationInstructionsDTO.encode(message.skillSets, writer.uint32(90).fork()).join();
    }
    if (message.skillAdjustments !== undefined) {
      SkillAdjustmentsDTO.encode(message.skillAdjustments, writer.uint32(98).fork()).join();
    }
    if (message.personality !== undefined) {
      GenerationInstructionsDTO.encode(message.personality, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundCustomizationDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundCustomizationDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.race = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.faction = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.disease = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.addiction = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.profession = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.religion = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.itemSets = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.items = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pastExpChild = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.pastExpAdult = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.skillSets = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.skillAdjustments = SkillAdjustmentsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.personality = GenerationInstructionsDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundCustomizationDTO {
    return {
      race: isSet(object.race) ? GenerationInstructionsDTO.fromJSON(object.race) : undefined,
      faction: isSet(object.faction) ? GenerationInstructionsDTO.fromJSON(object.faction) : undefined,
      disease: isSet(object.disease) ? GenerationInstructionsDTO.fromJSON(object.disease) : undefined,
      addiction: isSet(object.addiction) ? GenerationInstructionsDTO.fromJSON(object.addiction) : undefined,
      profession: isSet(object.profession) ? GenerationInstructionsDTO.fromJSON(object.profession) : undefined,
      religion: isSet(object.religion) ? GenerationInstructionsDTO.fromJSON(object.religion) : undefined,
      itemSets: isSet(object.itemSets) ? GenerationInstructionsDTO.fromJSON(object.itemSets) : undefined,
      items: isSet(object.items) ? GenerationInstructionsDTO.fromJSON(object.items) : undefined,
      pastExpChild: isSet(object.pastExpChild) ? GenerationInstructionsDTO.fromJSON(object.pastExpChild) : undefined,
      pastExpAdult: isSet(object.pastExpAdult) ? GenerationInstructionsDTO.fromJSON(object.pastExpAdult) : undefined,
      skillSets: isSet(object.skillSets) ? GenerationInstructionsDTO.fromJSON(object.skillSets) : undefined,
      skillAdjustments: isSet(object.skillAdjustments)
        ? SkillAdjustmentsDTO.fromJSON(object.skillAdjustments)
        : undefined,
      personality: isSet(object.personality) ? GenerationInstructionsDTO.fromJSON(object.personality) : undefined,
    };
  },

  toJSON(message: BackgroundCustomizationDTO): unknown {
    const obj: any = {};
    if (message.race !== undefined) {
      obj.race = GenerationInstructionsDTO.toJSON(message.race);
    }
    if (message.faction !== undefined) {
      obj.faction = GenerationInstructionsDTO.toJSON(message.faction);
    }
    if (message.disease !== undefined) {
      obj.disease = GenerationInstructionsDTO.toJSON(message.disease);
    }
    if (message.addiction !== undefined) {
      obj.addiction = GenerationInstructionsDTO.toJSON(message.addiction);
    }
    if (message.profession !== undefined) {
      obj.profession = GenerationInstructionsDTO.toJSON(message.profession);
    }
    if (message.religion !== undefined) {
      obj.religion = GenerationInstructionsDTO.toJSON(message.religion);
    }
    if (message.itemSets !== undefined) {
      obj.itemSets = GenerationInstructionsDTO.toJSON(message.itemSets);
    }
    if (message.items !== undefined) {
      obj.items = GenerationInstructionsDTO.toJSON(message.items);
    }
    if (message.pastExpChild !== undefined) {
      obj.pastExpChild = GenerationInstructionsDTO.toJSON(message.pastExpChild);
    }
    if (message.pastExpAdult !== undefined) {
      obj.pastExpAdult = GenerationInstructionsDTO.toJSON(message.pastExpAdult);
    }
    if (message.skillSets !== undefined) {
      obj.skillSets = GenerationInstructionsDTO.toJSON(message.skillSets);
    }
    if (message.skillAdjustments !== undefined) {
      obj.skillAdjustments = SkillAdjustmentsDTO.toJSON(message.skillAdjustments);
    }
    if (message.personality !== undefined) {
      obj.personality = GenerationInstructionsDTO.toJSON(message.personality);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundCustomizationDTO>, I>>(base?: I): BackgroundCustomizationDTO {
    return BackgroundCustomizationDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundCustomizationDTO>, I>>(object: I): BackgroundCustomizationDTO {
    const message = createBaseBackgroundCustomizationDTO();
    message.race = (object.race !== undefined && object.race !== null)
      ? GenerationInstructionsDTO.fromPartial(object.race)
      : undefined;
    message.faction = (object.faction !== undefined && object.faction !== null)
      ? GenerationInstructionsDTO.fromPartial(object.faction)
      : undefined;
    message.disease = (object.disease !== undefined && object.disease !== null)
      ? GenerationInstructionsDTO.fromPartial(object.disease)
      : undefined;
    message.addiction = (object.addiction !== undefined && object.addiction !== null)
      ? GenerationInstructionsDTO.fromPartial(object.addiction)
      : undefined;
    message.profession = (object.profession !== undefined && object.profession !== null)
      ? GenerationInstructionsDTO.fromPartial(object.profession)
      : undefined;
    message.religion = (object.religion !== undefined && object.religion !== null)
      ? GenerationInstructionsDTO.fromPartial(object.religion)
      : undefined;
    message.itemSets = (object.itemSets !== undefined && object.itemSets !== null)
      ? GenerationInstructionsDTO.fromPartial(object.itemSets)
      : undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? GenerationInstructionsDTO.fromPartial(object.items)
      : undefined;
    message.pastExpChild = (object.pastExpChild !== undefined && object.pastExpChild !== null)
      ? GenerationInstructionsDTO.fromPartial(object.pastExpChild)
      : undefined;
    message.pastExpAdult = (object.pastExpAdult !== undefined && object.pastExpAdult !== null)
      ? GenerationInstructionsDTO.fromPartial(object.pastExpAdult)
      : undefined;
    message.skillSets = (object.skillSets !== undefined && object.skillSets !== null)
      ? GenerationInstructionsDTO.fromPartial(object.skillSets)
      : undefined;
    message.skillAdjustments = (object.skillAdjustments !== undefined && object.skillAdjustments !== null)
      ? SkillAdjustmentsDTO.fromPartial(object.skillAdjustments)
      : undefined;
    message.personality = (object.personality !== undefined && object.personality !== null)
      ? GenerationInstructionsDTO.fromPartial(object.personality)
      : undefined;
    return message;
  },
};

function createBaseSkillAdjustmentsDTO(): SkillAdjustmentsDTO {
  return { skillAdjustments: {} };
}

export const SkillAdjustmentsDTO: MessageFns<SkillAdjustmentsDTO> = {
  encode(message: SkillAdjustmentsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.skillAdjustments).forEach(([key, value]) => {
      SkillAdjustmentsDTO_SkillAdjustmentsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillAdjustmentsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillAdjustmentsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SkillAdjustmentsDTO_SkillAdjustmentsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.skillAdjustments[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillAdjustmentsDTO {
    return {
      skillAdjustments: isObject(object.skillAdjustments)
        ? Object.entries(object.skillAdjustments).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SkillAdjustmentsDTO): unknown {
    const obj: any = {};
    if (message.skillAdjustments) {
      const entries = Object.entries(message.skillAdjustments);
      if (entries.length > 0) {
        obj.skillAdjustments = {};
        entries.forEach(([k, v]) => {
          obj.skillAdjustments[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillAdjustmentsDTO>, I>>(base?: I): SkillAdjustmentsDTO {
    return SkillAdjustmentsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillAdjustmentsDTO>, I>>(object: I): SkillAdjustmentsDTO {
    const message = createBaseSkillAdjustmentsDTO();
    message.skillAdjustments = Object.entries(object.skillAdjustments ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSkillAdjustmentsDTO_SkillAdjustmentsEntry(): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
  return { key: "", value: 0 };
}

export const SkillAdjustmentsDTO_SkillAdjustmentsEntry: MessageFns<SkillAdjustmentsDTO_SkillAdjustmentsEntry> = {
  encode(message: SkillAdjustmentsDTO_SkillAdjustmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillAdjustmentsDTO_SkillAdjustmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: SkillAdjustmentsDTO_SkillAdjustmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillAdjustmentsDTO_SkillAdjustmentsEntry>, I>>(
    base?: I,
  ): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
    return SkillAdjustmentsDTO_SkillAdjustmentsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillAdjustmentsDTO_SkillAdjustmentsEntry>, I>>(
    object: I,
  ): SkillAdjustmentsDTO_SkillAdjustmentsEntry {
    const message = createBaseSkillAdjustmentsDTO_SkillAdjustmentsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseSimpleProbDTO(): SimpleProbDTO {
  return { cond: 0, prob: {}, clazz: "" };
}

export const SimpleProbDTO: MessageFns<SimpleProbDTO> = {
  encode(message: SimpleProbDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cond !== 0) {
      writer.uint32(8).int32(message.cond);
    }
    Object.entries(message.prob).forEach(([key, value]) => {
      SimpleProbDTO_ProbEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.clazz !== "") {
      writer.uint32(26).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleProbDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleProbDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cond = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SimpleProbDTO_ProbEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.prob[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleProbDTO {
    return {
      cond: isSet(object.cond) ? conditionEnumDTOFromJSON(object.cond) : 0,
      prob: isObject(object.prob)
        ? Object.entries(object.prob).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: SimpleProbDTO): unknown {
    const obj: any = {};
    if (message.cond !== 0) {
      obj.cond = conditionEnumDTOToJSON(message.cond);
    }
    if (message.prob) {
      const entries = Object.entries(message.prob);
      if (entries.length > 0) {
        obj.prob = {};
        entries.forEach(([k, v]) => {
          obj.prob[k] = v;
        });
      }
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleProbDTO>, I>>(base?: I): SimpleProbDTO {
    return SimpleProbDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleProbDTO>, I>>(object: I): SimpleProbDTO {
    const message = createBaseSimpleProbDTO();
    message.cond = object.cond ?? 0;
    message.prob = Object.entries(object.prob ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseSimpleProbDTO_ProbEntry(): SimpleProbDTO_ProbEntry {
  return { key: "", value: 0 };
}

export const SimpleProbDTO_ProbEntry: MessageFns<SimpleProbDTO_ProbEntry> = {
  encode(message: SimpleProbDTO_ProbEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleProbDTO_ProbEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleProbDTO_ProbEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleProbDTO_ProbEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: SimpleProbDTO_ProbEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleProbDTO_ProbEntry>, I>>(base?: I): SimpleProbDTO_ProbEntry {
    return SimpleProbDTO_ProbEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleProbDTO_ProbEntry>, I>>(object: I): SimpleProbDTO_ProbEntry {
    const message = createBaseSimpleProbDTO_ProbEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGaussianProbDTO(): GaussianProbDTO {
  return { blueprintId: "", prob: 0, avgQuan: undefined, stDev: undefined, skew: undefined, clazz: "" };
}

export const GaussianProbDTO: MessageFns<GaussianProbDTO> = {
  encode(message: GaussianProbDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.prob !== 0) {
      writer.uint32(21).float(message.prob);
    }
    if (message.avgQuan !== undefined) {
      writer.uint32(24).int32(message.avgQuan);
    }
    if (message.stDev !== undefined) {
      writer.uint32(37).float(message.stDev);
    }
    if (message.skew !== undefined) {
      writer.uint32(45).float(message.skew);
    }
    if (message.clazz !== "") {
      writer.uint32(50).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GaussianProbDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGaussianProbDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.prob = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.avgQuan = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.stDev = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.skew = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GaussianProbDTO {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      prob: isSet(object.prob) ? globalThis.Number(object.prob) : 0,
      avgQuan: isSet(object.avgQuan) ? globalThis.Number(object.avgQuan) : undefined,
      stDev: isSet(object.stDev) ? globalThis.Number(object.stDev) : undefined,
      skew: isSet(object.skew) ? globalThis.Number(object.skew) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: GaussianProbDTO): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.prob !== 0) {
      obj.prob = message.prob;
    }
    if (message.avgQuan !== undefined) {
      obj.avgQuan = Math.round(message.avgQuan);
    }
    if (message.stDev !== undefined) {
      obj.stDev = message.stDev;
    }
    if (message.skew !== undefined) {
      obj.skew = message.skew;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GaussianProbDTO>, I>>(base?: I): GaussianProbDTO {
    return GaussianProbDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GaussianProbDTO>, I>>(object: I): GaussianProbDTO {
    const message = createBaseGaussianProbDTO();
    message.blueprintId = object.blueprintId ?? "";
    message.prob = object.prob ?? 0;
    message.avgQuan = object.avgQuan ?? undefined;
    message.stDev = object.stDev ?? undefined;
    message.skew = object.skew ?? undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseCombinatorDTO(): CombinatorDTO {
  return { name: undefined, cond: 0, prob: 0, instructions: [], clazz: "" };
}

export const CombinatorDTO: MessageFns<CombinatorDTO> = {
  encode(message: CombinatorDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.cond !== 0) {
      writer.uint32(16).int32(message.cond);
    }
    if (message.prob !== 0) {
      writer.uint32(29).float(message.prob);
    }
    for (const v of message.instructions) {
      GenerationInstructionDTO.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(42).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CombinatorDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCombinatorDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cond = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.prob = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instructions.push(GenerationInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CombinatorDTO {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      cond: isSet(object.cond) ? conditionEnumDTOFromJSON(object.cond) : 0,
      prob: isSet(object.prob) ? globalThis.Number(object.prob) : 0,
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => GenerationInstructionDTO.fromJSON(e))
        : [],
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: CombinatorDTO): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.cond !== 0) {
      obj.cond = conditionEnumDTOToJSON(message.cond);
    }
    if (message.prob !== 0) {
      obj.prob = message.prob;
    }
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => GenerationInstructionDTO.toJSON(e));
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CombinatorDTO>, I>>(base?: I): CombinatorDTO {
    return CombinatorDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CombinatorDTO>, I>>(object: I): CombinatorDTO {
    const message = createBaseCombinatorDTO();
    message.name = object.name ?? undefined;
    message.cond = object.cond ?? 0;
    message.prob = object.prob ?? 0;
    message.instructions = object.instructions?.map((e) => GenerationInstructionDTO.fromPartial(e)) || [];
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBasePastExperienceDTO(): PastExperienceDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    type: undefined,
    targetEntity: "",
  };
}

export const PastExperienceDTO: MessageFns<PastExperienceDTO> = {
  encode(message: PastExperienceDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.type !== undefined) {
      writer.uint32(74).string(message.type);
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PastExperienceDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePastExperienceDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PastExperienceDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: PastExperienceDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PastExperienceDTO>, I>>(base?: I): PastExperienceDTO {
    return PastExperienceDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PastExperienceDTO>, I>>(object: I): PastExperienceDTO {
    const message = createBasePastExperienceDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.type = object.type ?? undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBasePastExperiencesDTO(): PastExperiencesDTO {
  return { pastExperiences: [] };
}

export const PastExperiencesDTO: MessageFns<PastExperiencesDTO> = {
  encode(message: PastExperiencesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.pastExperiences) {
      PastExperienceDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PastExperiencesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePastExperiencesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pastExperiences.push(PastExperienceDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PastExperiencesDTO {
    return {
      pastExperiences: globalThis.Array.isArray(object?.pastExperiences)
        ? object.pastExperiences.map((e: any) => PastExperienceDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PastExperiencesDTO): unknown {
    const obj: any = {};
    if (message.pastExperiences?.length) {
      obj.pastExperiences = message.pastExperiences.map((e) => PastExperienceDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PastExperiencesDTO>, I>>(base?: I): PastExperiencesDTO {
    return PastExperiencesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PastExperiencesDTO>, I>>(object: I): PastExperiencesDTO {
    const message = createBasePastExperiencesDTO();
    message.pastExperiences = object.pastExperiences?.map((e) => PastExperienceDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemoryDTO(): MemoryDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    facts: undefined,
    type: 0,
    description: "",
    targetEntity: "",
  };
}

export const MemoryDTO: MessageFns<MemoryDTO> = {
  encode(message: MemoryDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.facts !== undefined) {
      FactsDTO.encode(message.facts, writer.uint32(74).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    if (message.targetEntity !== "") {
      writer.uint32(98).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.facts = FactsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      facts: isSet(object.facts) ? FactsDTO.fromJSON(object.facts) : undefined,
      type: isSet(object.type) ? memoryTypeEnumDTOFromJSON(object.type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: MemoryDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.facts !== undefined) {
      obj.facts = FactsDTO.toJSON(message.facts);
    }
    if (message.type !== 0) {
      obj.type = memoryTypeEnumDTOToJSON(message.type);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryDTO>, I>>(base?: I): MemoryDTO {
    return MemoryDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryDTO>, I>>(object: I): MemoryDTO {
    const message = createBaseMemoryDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.facts = (object.facts !== undefined && object.facts !== null)
      ? FactsDTO.fromPartial(object.facts)
      : undefined;
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseMemoriesDTO(): MemoriesDTO {
  return { memories: [] };
}

export const MemoriesDTO: MessageFns<MemoriesDTO> = {
  encode(message: MemoriesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.memories) {
      MemoryDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoriesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoriesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.memories.push(MemoryDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoriesDTO {
    return {
      memories: globalThis.Array.isArray(object?.memories)
        ? object.memories.map((e: any) => MemoryDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: MemoriesDTO): unknown {
    const obj: any = {};
    if (message.memories?.length) {
      obj.memories = message.memories.map((e) => MemoryDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoriesDTO>, I>>(base?: I): MemoriesDTO {
    return MemoriesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoriesDTO>, I>>(object: I): MemoriesDTO {
    const message = createBaseMemoriesDTO();
    message.memories = object.memories?.map((e) => MemoryDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkillSetDTO(): SkillSetDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    skillImprovement: undefined,
    targetEntity: "",
  };
}

export const SkillSetDTO: MessageFns<SkillSetDTO> = {
  encode(message: SkillSetDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.skillImprovement !== undefined) {
      SkillImprovementDTO.encode(message.skillImprovement, writer.uint32(74).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillSetDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillSetDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.skillImprovement = SkillImprovementDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillSetDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      skillImprovement: isSet(object.skillImprovement)
        ? SkillImprovementDTO.fromJSON(object.skillImprovement)
        : undefined,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: SkillSetDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.skillImprovement !== undefined) {
      obj.skillImprovement = SkillImprovementDTO.toJSON(message.skillImprovement);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillSetDTO>, I>>(base?: I): SkillSetDTO {
    return SkillSetDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillSetDTO>, I>>(object: I): SkillSetDTO {
    const message = createBaseSkillSetDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.skillImprovement = (object.skillImprovement !== undefined && object.skillImprovement !== null)
      ? SkillImprovementDTO.fromPartial(object.skillImprovement)
      : undefined;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseSkillSetsDTO(): SkillSetsDTO {
  return { skillSets: [] };
}

export const SkillSetsDTO: MessageFns<SkillSetsDTO> = {
  encode(message: SkillSetsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skillSets) {
      SkillSetDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillSetsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillSetsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skillSets.push(SkillSetDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillSetsDTO {
    return {
      skillSets: globalThis.Array.isArray(object?.skillSets)
        ? object.skillSets.map((e: any) => SkillSetDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SkillSetsDTO): unknown {
    const obj: any = {};
    if (message.skillSets?.length) {
      obj.skillSets = message.skillSets.map((e) => SkillSetDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillSetsDTO>, I>>(base?: I): SkillSetsDTO {
    return SkillSetsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillSetsDTO>, I>>(object: I): SkillSetsDTO {
    const message = createBaseSkillSetsDTO();
    message.skillSets = object.skillSets?.map((e) => SkillSetDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSkillImprovementDTO(): SkillImprovementDTO {
  return { skillImprovement: {} };
}

export const SkillImprovementDTO: MessageFns<SkillImprovementDTO> = {
  encode(message: SkillImprovementDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.skillImprovement).forEach(([key, value]) => {
      SkillImprovementDTO_SkillImprovementEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillImprovementDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillImprovementDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SkillImprovementDTO_SkillImprovementEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.skillImprovement[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillImprovementDTO {
    return {
      skillImprovement: isObject(object.skillImprovement)
        ? Object.entries(object.skillImprovement).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SkillImprovementDTO): unknown {
    const obj: any = {};
    if (message.skillImprovement) {
      const entries = Object.entries(message.skillImprovement);
      if (entries.length > 0) {
        obj.skillImprovement = {};
        entries.forEach(([k, v]) => {
          obj.skillImprovement[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillImprovementDTO>, I>>(base?: I): SkillImprovementDTO {
    return SkillImprovementDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillImprovementDTO>, I>>(object: I): SkillImprovementDTO {
    const message = createBaseSkillImprovementDTO();
    message.skillImprovement = Object.entries(object.skillImprovement ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSkillImprovementDTO_SkillImprovementEntry(): SkillImprovementDTO_SkillImprovementEntry {
  return { key: "", value: 0 };
}

export const SkillImprovementDTO_SkillImprovementEntry: MessageFns<SkillImprovementDTO_SkillImprovementEntry> = {
  encode(message: SkillImprovementDTO_SkillImprovementEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SkillImprovementDTO_SkillImprovementEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkillImprovementDTO_SkillImprovementEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SkillImprovementDTO_SkillImprovementEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: SkillImprovementDTO_SkillImprovementEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SkillImprovementDTO_SkillImprovementEntry>, I>>(
    base?: I,
  ): SkillImprovementDTO_SkillImprovementEntry {
    return SkillImprovementDTO_SkillImprovementEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SkillImprovementDTO_SkillImprovementEntry>, I>>(
    object: I,
  ): SkillImprovementDTO_SkillImprovementEntry {
    const message = createBaseSkillImprovementDTO_SkillImprovementEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBasePersonalityProfileDTO(): PersonalityProfileDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    enneagramType: "",
    traits: [],
    targetEntity: "",
  };
}

export const PersonalityProfileDTO: MessageFns<PersonalityProfileDTO> = {
  encode(message: PersonalityProfileDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.enneagramType !== "") {
      writer.uint32(66).string(message.enneagramType);
    }
    for (const v of message.traits) {
      GenerationInstructionDTO.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.targetEntity !== "") {
      writer.uint32(82).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalityProfileDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalityProfileDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.enneagramType = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.traits.push(GenerationInstructionDTO.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalityProfileDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      enneagramType: isSet(object.enneagramType) ? globalThis.String(object.enneagramType) : "",
      traits: globalThis.Array.isArray(object?.traits)
        ? object.traits.map((e: any) => GenerationInstructionDTO.fromJSON(e))
        : [],
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: PersonalityProfileDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.enneagramType !== "") {
      obj.enneagramType = message.enneagramType;
    }
    if (message.traits?.length) {
      obj.traits = message.traits.map((e) => GenerationInstructionDTO.toJSON(e));
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonalityProfileDTO>, I>>(base?: I): PersonalityProfileDTO {
    return PersonalityProfileDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonalityProfileDTO>, I>>(object: I): PersonalityProfileDTO {
    const message = createBasePersonalityProfileDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.enneagramType = object.enneagramType ?? "";
    message.traits = object.traits?.map((e) => GenerationInstructionDTO.fromPartial(e)) || [];
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBasePersonalityProfilesDTO(): PersonalityProfilesDTO {
  return { personalityProfiles: [] };
}

export const PersonalityProfilesDTO: MessageFns<PersonalityProfilesDTO> = {
  encode(message: PersonalityProfilesDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.personalityProfiles) {
      PersonalityProfileDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalityProfilesDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalityProfilesDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.personalityProfiles.push(PersonalityProfileDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalityProfilesDTO {
    return {
      personalityProfiles: globalThis.Array.isArray(object?.personalityProfiles)
        ? object.personalityProfiles.map((e: any) => PersonalityProfileDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PersonalityProfilesDTO): unknown {
    const obj: any = {};
    if (message.personalityProfiles?.length) {
      obj.personalityProfiles = message.personalityProfiles.map((e) => PersonalityProfileDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonalityProfilesDTO>, I>>(base?: I): PersonalityProfilesDTO {
    return PersonalityProfilesDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonalityProfilesDTO>, I>>(object: I): PersonalityProfilesDTO {
    const message = createBasePersonalityProfilesDTO();
    message.personalityProfiles = object.personalityProfiles?.map((e) => PersonalityProfileDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNeedDTO(): NeedDTO {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
    type: 0,
    layer: 0,
    targetEntity: "",
  };
}

export const NeedDTO: MessageFns<NeedDTO> = {
  encode(message: NeedDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      CampaignDTO.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.layer !== 0) {
      writer.uint32(80).int32(message.layer);
    }
    if (message.targetEntity !== "") {
      writer.uint32(90).string(message.targetEntity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NeedDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNeedDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = CampaignDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.layer = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NeedDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? CampaignDTO.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? needTypeEnumDTOFromJSON(object.type) : 0,
      layer: isSet(object.layer) ? needLayerEnumDTOFromJSON(object.layer) : 0,
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
    };
  },

  toJSON(message: NeedDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = CampaignDTO.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = needTypeEnumDTOToJSON(message.type);
    }
    if (message.layer !== 0) {
      obj.layer = needLayerEnumDTOToJSON(message.layer);
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NeedDTO>, I>>(base?: I): NeedDTO {
    return NeedDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NeedDTO>, I>>(object: I): NeedDTO {
    const message = createBaseNeedDTO();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? CampaignDTO.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.layer = object.layer ?? 0;
    message.targetEntity = object.targetEntity ?? "";
    return message;
  },
};

function createBaseNeedsDTO(): NeedsDTO {
  return { needs: [] };
}

export const NeedsDTO: MessageFns<NeedsDTO> = {
  encode(message: NeedsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.needs) {
      NeedDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NeedsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNeedsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.needs.push(NeedDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NeedsDTO {
    return { needs: globalThis.Array.isArray(object?.needs) ? object.needs.map((e: any) => NeedDTO.fromJSON(e)) : [] };
  },

  toJSON(message: NeedsDTO): unknown {
    const obj: any = {};
    if (message.needs?.length) {
      obj.needs = message.needs.map((e) => NeedDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<NeedsDTO>, I>>(base?: I): NeedsDTO {
    return NeedsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NeedsDTO>, I>>(object: I): NeedsDTO {
    const message = createBaseNeedsDTO();
    message.needs = object.needs?.map((e) => NeedDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserDTO(): UserDTO {
  return {
    id: "",
    name: "",
    worlds: undefined,
    campaigns: undefined,
    items: undefined,
    pastExperiences: undefined,
    characterMemories: undefined,
    memories: undefined,
    memoryPools: undefined,
    memoryPoolEntries: undefined,
    skills: undefined,
    traits: undefined,
    addictions: undefined,
    birthsigns: undefined,
    characters: undefined,
    characterProfessions: undefined,
    diseases: undefined,
    effects: undefined,
    facts: undefined,
    factions: undefined,
    storageSlots: undefined,
    equipmentSlots: undefined,
    itemSets: undefined,
    moods: undefined,
    needs: undefined,
    personalityProfiles: undefined,
    races: undefined,
    religions: undefined,
    resistances: undefined,
    statuses: undefined,
    tags: undefined,
    backgrounds: undefined,
  };
}

export const UserDTO: MessageFns<UserDTO> = {
  encode(message: UserDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.worlds !== undefined) {
      WorldsDTO.encode(message.worlds, writer.uint32(26).fork()).join();
    }
    if (message.campaigns !== undefined) {
      CampaignsDTO.encode(message.campaigns, writer.uint32(34).fork()).join();
    }
    if (message.items !== undefined) {
      ItemsDTO.encode(message.items, writer.uint32(42).fork()).join();
    }
    if (message.pastExperiences !== undefined) {
      PastExperiencesDTO.encode(message.pastExperiences, writer.uint32(50).fork()).join();
    }
    if (message.characterMemories !== undefined) {
      CharacterMemoriesDTO.encode(message.characterMemories, writer.uint32(58).fork()).join();
    }
    if (message.memories !== undefined) {
      MemoriesDTO.encode(message.memories, writer.uint32(66).fork()).join();
    }
    if (message.memoryPools !== undefined) {
      MemoryPoolsDTO.encode(message.memoryPools, writer.uint32(74).fork()).join();
    }
    if (message.memoryPoolEntries !== undefined) {
      MemoryPoolEntriesDTO.encode(message.memoryPoolEntries, writer.uint32(82).fork()).join();
    }
    if (message.skills !== undefined) {
      SkillsDTO.encode(message.skills, writer.uint32(90).fork()).join();
    }
    if (message.traits !== undefined) {
      TraitsDTO.encode(message.traits, writer.uint32(98).fork()).join();
    }
    if (message.addictions !== undefined) {
      AddictionsDTO.encode(message.addictions, writer.uint32(106).fork()).join();
    }
    if (message.birthsigns !== undefined) {
      BirthsignsDTO.encode(message.birthsigns, writer.uint32(114).fork()).join();
    }
    if (message.characters !== undefined) {
      CharactersDTO.encode(message.characters, writer.uint32(122).fork()).join();
    }
    if (message.characterProfessions !== undefined) {
      CharacterProfessionsDTO.encode(message.characterProfessions, writer.uint32(130).fork()).join();
    }
    if (message.diseases !== undefined) {
      DiseasesDTO.encode(message.diseases, writer.uint32(138).fork()).join();
    }
    if (message.effects !== undefined) {
      EffectsDTO.encode(message.effects, writer.uint32(146).fork()).join();
    }
    if (message.facts !== undefined) {
      FactsDTO.encode(message.facts, writer.uint32(154).fork()).join();
    }
    if (message.factions !== undefined) {
      FactionsDTO.encode(message.factions, writer.uint32(162).fork()).join();
    }
    if (message.storageSlots !== undefined) {
      StorageSlotsDTO.encode(message.storageSlots, writer.uint32(170).fork()).join();
    }
    if (message.equipmentSlots !== undefined) {
      EquipmentSlotsDTO.encode(message.equipmentSlots, writer.uint32(178).fork()).join();
    }
    if (message.itemSets !== undefined) {
      ItemSetsDTO.encode(message.itemSets, writer.uint32(186).fork()).join();
    }
    if (message.moods !== undefined) {
      MoodsDTO.encode(message.moods, writer.uint32(194).fork()).join();
    }
    if (message.needs !== undefined) {
      NeedsDTO.encode(message.needs, writer.uint32(202).fork()).join();
    }
    if (message.personalityProfiles !== undefined) {
      PersonalityProfilesDTO.encode(message.personalityProfiles, writer.uint32(210).fork()).join();
    }
    if (message.races !== undefined) {
      RacesDTO.encode(message.races, writer.uint32(218).fork()).join();
    }
    if (message.religions !== undefined) {
      ReligionsDTO.encode(message.religions, writer.uint32(226).fork()).join();
    }
    if (message.resistances !== undefined) {
      ResistancesDTO.encode(message.resistances, writer.uint32(234).fork()).join();
    }
    if (message.statuses !== undefined) {
      StatusesDTO.encode(message.statuses, writer.uint32(242).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(250).fork()).join();
    }
    if (message.backgrounds !== undefined) {
      BackgroundsDTO.encode(message.backgrounds, writer.uint32(258).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.worlds = WorldsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.campaigns = CampaignsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.items = ItemsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pastExperiences = PastExperiencesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.characterMemories = CharacterMemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.memories = MemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memoryPools = MemoryPoolsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.memoryPoolEntries = MemoryPoolEntriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.skills = SkillsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.traits = TraitsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.addictions = AddictionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.birthsigns = BirthsignsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.characters = CharactersDTO.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.characterProfessions = CharacterProfessionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.diseases = DiseasesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.effects = EffectsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.facts = FactsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.factions = FactionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.storageSlots = StorageSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.equipmentSlots = EquipmentSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.itemSets = ItemSetsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.moods = MoodsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.needs = NeedsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.personalityProfiles = PersonalityProfilesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.races = RacesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.religions = ReligionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.resistances = ResistancesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.statuses = StatusesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.backgrounds = BackgroundsDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      worlds: isSet(object.worlds) ? WorldsDTO.fromJSON(object.worlds) : undefined,
      campaigns: isSet(object.campaigns) ? CampaignsDTO.fromJSON(object.campaigns) : undefined,
      items: isSet(object.items) ? ItemsDTO.fromJSON(object.items) : undefined,
      pastExperiences: isSet(object.pastExperiences) ? PastExperiencesDTO.fromJSON(object.pastExperiences) : undefined,
      characterMemories: isSet(object.characterMemories)
        ? CharacterMemoriesDTO.fromJSON(object.characterMemories)
        : undefined,
      memories: isSet(object.memories) ? MemoriesDTO.fromJSON(object.memories) : undefined,
      memoryPools: isSet(object.memoryPools) ? MemoryPoolsDTO.fromJSON(object.memoryPools) : undefined,
      memoryPoolEntries: isSet(object.memoryPoolEntries)
        ? MemoryPoolEntriesDTO.fromJSON(object.memoryPoolEntries)
        : undefined,
      skills: isSet(object.skills) ? SkillsDTO.fromJSON(object.skills) : undefined,
      traits: isSet(object.traits) ? TraitsDTO.fromJSON(object.traits) : undefined,
      addictions: isSet(object.addictions) ? AddictionsDTO.fromJSON(object.addictions) : undefined,
      birthsigns: isSet(object.birthsigns) ? BirthsignsDTO.fromJSON(object.birthsigns) : undefined,
      characters: isSet(object.characters) ? CharactersDTO.fromJSON(object.characters) : undefined,
      characterProfessions: isSet(object.characterProfessions)
        ? CharacterProfessionsDTO.fromJSON(object.characterProfessions)
        : undefined,
      diseases: isSet(object.diseases) ? DiseasesDTO.fromJSON(object.diseases) : undefined,
      effects: isSet(object.effects) ? EffectsDTO.fromJSON(object.effects) : undefined,
      facts: isSet(object.facts) ? FactsDTO.fromJSON(object.facts) : undefined,
      factions: isSet(object.factions) ? FactionsDTO.fromJSON(object.factions) : undefined,
      storageSlots: isSet(object.storageSlots) ? StorageSlotsDTO.fromJSON(object.storageSlots) : undefined,
      equipmentSlots: isSet(object.equipmentSlots) ? EquipmentSlotsDTO.fromJSON(object.equipmentSlots) : undefined,
      itemSets: isSet(object.itemSets) ? ItemSetsDTO.fromJSON(object.itemSets) : undefined,
      moods: isSet(object.moods) ? MoodsDTO.fromJSON(object.moods) : undefined,
      needs: isSet(object.needs) ? NeedsDTO.fromJSON(object.needs) : undefined,
      personalityProfiles: isSet(object.personalityProfiles)
        ? PersonalityProfilesDTO.fromJSON(object.personalityProfiles)
        : undefined,
      races: isSet(object.races) ? RacesDTO.fromJSON(object.races) : undefined,
      religions: isSet(object.religions) ? ReligionsDTO.fromJSON(object.religions) : undefined,
      resistances: isSet(object.resistances) ? ResistancesDTO.fromJSON(object.resistances) : undefined,
      statuses: isSet(object.statuses) ? StatusesDTO.fromJSON(object.statuses) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      backgrounds: isSet(object.backgrounds) ? BackgroundsDTO.fromJSON(object.backgrounds) : undefined,
    };
  },

  toJSON(message: UserDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.worlds !== undefined) {
      obj.worlds = WorldsDTO.toJSON(message.worlds);
    }
    if (message.campaigns !== undefined) {
      obj.campaigns = CampaignsDTO.toJSON(message.campaigns);
    }
    if (message.items !== undefined) {
      obj.items = ItemsDTO.toJSON(message.items);
    }
    if (message.pastExperiences !== undefined) {
      obj.pastExperiences = PastExperiencesDTO.toJSON(message.pastExperiences);
    }
    if (message.characterMemories !== undefined) {
      obj.characterMemories = CharacterMemoriesDTO.toJSON(message.characterMemories);
    }
    if (message.memories !== undefined) {
      obj.memories = MemoriesDTO.toJSON(message.memories);
    }
    if (message.memoryPools !== undefined) {
      obj.memoryPools = MemoryPoolsDTO.toJSON(message.memoryPools);
    }
    if (message.memoryPoolEntries !== undefined) {
      obj.memoryPoolEntries = MemoryPoolEntriesDTO.toJSON(message.memoryPoolEntries);
    }
    if (message.skills !== undefined) {
      obj.skills = SkillsDTO.toJSON(message.skills);
    }
    if (message.traits !== undefined) {
      obj.traits = TraitsDTO.toJSON(message.traits);
    }
    if (message.addictions !== undefined) {
      obj.addictions = AddictionsDTO.toJSON(message.addictions);
    }
    if (message.birthsigns !== undefined) {
      obj.birthsigns = BirthsignsDTO.toJSON(message.birthsigns);
    }
    if (message.characters !== undefined) {
      obj.characters = CharactersDTO.toJSON(message.characters);
    }
    if (message.characterProfessions !== undefined) {
      obj.characterProfessions = CharacterProfessionsDTO.toJSON(message.characterProfessions);
    }
    if (message.diseases !== undefined) {
      obj.diseases = DiseasesDTO.toJSON(message.diseases);
    }
    if (message.effects !== undefined) {
      obj.effects = EffectsDTO.toJSON(message.effects);
    }
    if (message.facts !== undefined) {
      obj.facts = FactsDTO.toJSON(message.facts);
    }
    if (message.factions !== undefined) {
      obj.factions = FactionsDTO.toJSON(message.factions);
    }
    if (message.storageSlots !== undefined) {
      obj.storageSlots = StorageSlotsDTO.toJSON(message.storageSlots);
    }
    if (message.equipmentSlots !== undefined) {
      obj.equipmentSlots = EquipmentSlotsDTO.toJSON(message.equipmentSlots);
    }
    if (message.itemSets !== undefined) {
      obj.itemSets = ItemSetsDTO.toJSON(message.itemSets);
    }
    if (message.moods !== undefined) {
      obj.moods = MoodsDTO.toJSON(message.moods);
    }
    if (message.needs !== undefined) {
      obj.needs = NeedsDTO.toJSON(message.needs);
    }
    if (message.personalityProfiles !== undefined) {
      obj.personalityProfiles = PersonalityProfilesDTO.toJSON(message.personalityProfiles);
    }
    if (message.races !== undefined) {
      obj.races = RacesDTO.toJSON(message.races);
    }
    if (message.religions !== undefined) {
      obj.religions = ReligionsDTO.toJSON(message.religions);
    }
    if (message.resistances !== undefined) {
      obj.resistances = ResistancesDTO.toJSON(message.resistances);
    }
    if (message.statuses !== undefined) {
      obj.statuses = StatusesDTO.toJSON(message.statuses);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.backgrounds !== undefined) {
      obj.backgrounds = BackgroundsDTO.toJSON(message.backgrounds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserDTO>, I>>(base?: I): UserDTO {
    return UserDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserDTO>, I>>(object: I): UserDTO {
    const message = createBaseUserDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.worlds = (object.worlds !== undefined && object.worlds !== null)
      ? WorldsDTO.fromPartial(object.worlds)
      : undefined;
    message.campaigns = (object.campaigns !== undefined && object.campaigns !== null)
      ? CampaignsDTO.fromPartial(object.campaigns)
      : undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? ItemsDTO.fromPartial(object.items)
      : undefined;
    message.pastExperiences = (object.pastExperiences !== undefined && object.pastExperiences !== null)
      ? PastExperiencesDTO.fromPartial(object.pastExperiences)
      : undefined;
    message.characterMemories = (object.characterMemories !== undefined && object.characterMemories !== null)
      ? CharacterMemoriesDTO.fromPartial(object.characterMemories)
      : undefined;
    message.memories = (object.memories !== undefined && object.memories !== null)
      ? MemoriesDTO.fromPartial(object.memories)
      : undefined;
    message.memoryPools = (object.memoryPools !== undefined && object.memoryPools !== null)
      ? MemoryPoolsDTO.fromPartial(object.memoryPools)
      : undefined;
    message.memoryPoolEntries = (object.memoryPoolEntries !== undefined && object.memoryPoolEntries !== null)
      ? MemoryPoolEntriesDTO.fromPartial(object.memoryPoolEntries)
      : undefined;
    message.skills = (object.skills !== undefined && object.skills !== null)
      ? SkillsDTO.fromPartial(object.skills)
      : undefined;
    message.traits = (object.traits !== undefined && object.traits !== null)
      ? TraitsDTO.fromPartial(object.traits)
      : undefined;
    message.addictions = (object.addictions !== undefined && object.addictions !== null)
      ? AddictionsDTO.fromPartial(object.addictions)
      : undefined;
    message.birthsigns = (object.birthsigns !== undefined && object.birthsigns !== null)
      ? BirthsignsDTO.fromPartial(object.birthsigns)
      : undefined;
    message.characters = (object.characters !== undefined && object.characters !== null)
      ? CharactersDTO.fromPartial(object.characters)
      : undefined;
    message.characterProfessions = (object.characterProfessions !== undefined && object.characterProfessions !== null)
      ? CharacterProfessionsDTO.fromPartial(object.characterProfessions)
      : undefined;
    message.diseases = (object.diseases !== undefined && object.diseases !== null)
      ? DiseasesDTO.fromPartial(object.diseases)
      : undefined;
    message.effects = (object.effects !== undefined && object.effects !== null)
      ? EffectsDTO.fromPartial(object.effects)
      : undefined;
    message.facts = (object.facts !== undefined && object.facts !== null)
      ? FactsDTO.fromPartial(object.facts)
      : undefined;
    message.factions = (object.factions !== undefined && object.factions !== null)
      ? FactionsDTO.fromPartial(object.factions)
      : undefined;
    message.storageSlots = (object.storageSlots !== undefined && object.storageSlots !== null)
      ? StorageSlotsDTO.fromPartial(object.storageSlots)
      : undefined;
    message.equipmentSlots = (object.equipmentSlots !== undefined && object.equipmentSlots !== null)
      ? EquipmentSlotsDTO.fromPartial(object.equipmentSlots)
      : undefined;
    message.itemSets = (object.itemSets !== undefined && object.itemSets !== null)
      ? ItemSetsDTO.fromPartial(object.itemSets)
      : undefined;
    message.moods = (object.moods !== undefined && object.moods !== null)
      ? MoodsDTO.fromPartial(object.moods)
      : undefined;
    message.needs = (object.needs !== undefined && object.needs !== null)
      ? NeedsDTO.fromPartial(object.needs)
      : undefined;
    message.personalityProfiles = (object.personalityProfiles !== undefined && object.personalityProfiles !== null)
      ? PersonalityProfilesDTO.fromPartial(object.personalityProfiles)
      : undefined;
    message.races = (object.races !== undefined && object.races !== null)
      ? RacesDTO.fromPartial(object.races)
      : undefined;
    message.religions = (object.religions !== undefined && object.religions !== null)
      ? ReligionsDTO.fromPartial(object.religions)
      : undefined;
    message.resistances = (object.resistances !== undefined && object.resistances !== null)
      ? ResistancesDTO.fromPartial(object.resistances)
      : undefined;
    message.statuses = (object.statuses !== undefined && object.statuses !== null)
      ? StatusesDTO.fromPartial(object.statuses)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.backgrounds = (object.backgrounds !== undefined && object.backgrounds !== null)
      ? BackgroundsDTO.fromPartial(object.backgrounds)
      : undefined;
    return message;
  },
};

function createBaseUsersDTO(): UsersDTO {
  return { users: [] };
}

export const UsersDTO: MessageFns<UsersDTO> = {
  encode(message: UsersDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.users) {
      UserDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsersDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsersDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.users.push(UserDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsersDTO {
    return { users: globalThis.Array.isArray(object?.users) ? object.users.map((e: any) => UserDTO.fromJSON(e)) : [] };
  },

  toJSON(message: UsersDTO): unknown {
    const obj: any = {};
    if (message.users?.length) {
      obj.users = message.users.map((e) => UserDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsersDTO>, I>>(base?: I): UsersDTO {
    return UsersDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsersDTO>, I>>(object: I): UsersDTO {
    const message = createBaseUsersDTO();
    message.users = object.users?.map((e) => UserDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorldSettings(): WorldSettings {
  return { settings: {} };
}

export const WorldSettings: MessageFns<WorldSettings> = {
  encode(message: WorldSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.settings).forEach(([key, value]) => {
      WorldSettings_SettingsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = WorldSettings_SettingsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.settings[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldSettings {
    return {
      settings: isObject(object.settings)
        ? Object.entries(object.settings).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: WorldSettings): unknown {
    const obj: any = {};
    if (message.settings) {
      const entries = Object.entries(message.settings);
      if (entries.length > 0) {
        obj.settings = {};
        entries.forEach(([k, v]) => {
          obj.settings[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldSettings>, I>>(base?: I): WorldSettings {
    return WorldSettings.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldSettings>, I>>(object: I): WorldSettings {
    const message = createBaseWorldSettings();
    message.settings = Object.entries(object.settings ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseWorldSettings_SettingsEntry(): WorldSettings_SettingsEntry {
  return { key: "", value: "" };
}

export const WorldSettings_SettingsEntry: MessageFns<WorldSettings_SettingsEntry> = {
  encode(message: WorldSettings_SettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldSettings_SettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldSettings_SettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldSettings_SettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: WorldSettings_SettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldSettings_SettingsEntry>, I>>(base?: I): WorldSettings_SettingsEntry {
    return WorldSettings_SettingsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldSettings_SettingsEntry>, I>>(object: I): WorldSettings_SettingsEntry {
    const message = createBaseWorldSettings_SettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseWorldDTO(): WorldDTO {
  return {
    id: "",
    name: "",
    description: "",
    settings: undefined,
    frozen: false,
    user: undefined,
    campaigns: undefined,
    items: undefined,
    pastExperiences: undefined,
    characterMemories: undefined,
    memories: undefined,
    memoryPools: undefined,
    memoryPoolEntries: undefined,
    skills: undefined,
    traits: undefined,
    addictions: undefined,
    birthsigns: undefined,
    characters: undefined,
    characterProfessions: undefined,
    diseases: undefined,
    effects: undefined,
    facts: undefined,
    factions: undefined,
    storageSlots: undefined,
    equipmentSlots: undefined,
    itemSets: undefined,
    moods: undefined,
    needs: undefined,
    personalityProfiles: undefined,
    races: undefined,
    religions: undefined,
    resistances: undefined,
    statuses: undefined,
    tags: undefined,
    backgrounds: undefined,
  };
}

export const WorldDTO: MessageFns<WorldDTO> = {
  encode(message: WorldDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.settings !== undefined) {
      WorldSettings.encode(message.settings, writer.uint32(34).fork()).join();
    }
    if (message.frozen !== false) {
      writer.uint32(40).bool(message.frozen);
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(50).fork()).join();
    }
    if (message.campaigns !== undefined) {
      CampaignsDTO.encode(message.campaigns, writer.uint32(58).fork()).join();
    }
    if (message.items !== undefined) {
      ItemsDTO.encode(message.items, writer.uint32(66).fork()).join();
    }
    if (message.pastExperiences !== undefined) {
      PastExperiencesDTO.encode(message.pastExperiences, writer.uint32(74).fork()).join();
    }
    if (message.characterMemories !== undefined) {
      CharacterMemoriesDTO.encode(message.characterMemories, writer.uint32(82).fork()).join();
    }
    if (message.memories !== undefined) {
      MemoriesDTO.encode(message.memories, writer.uint32(90).fork()).join();
    }
    if (message.memoryPools !== undefined) {
      MemoryPoolsDTO.encode(message.memoryPools, writer.uint32(98).fork()).join();
    }
    if (message.memoryPoolEntries !== undefined) {
      MemoryPoolEntriesDTO.encode(message.memoryPoolEntries, writer.uint32(106).fork()).join();
    }
    if (message.skills !== undefined) {
      SkillsDTO.encode(message.skills, writer.uint32(114).fork()).join();
    }
    if (message.traits !== undefined) {
      TraitsDTO.encode(message.traits, writer.uint32(122).fork()).join();
    }
    if (message.addictions !== undefined) {
      AddictionsDTO.encode(message.addictions, writer.uint32(130).fork()).join();
    }
    if (message.birthsigns !== undefined) {
      BirthsignsDTO.encode(message.birthsigns, writer.uint32(138).fork()).join();
    }
    if (message.characters !== undefined) {
      CharactersDTO.encode(message.characters, writer.uint32(146).fork()).join();
    }
    if (message.characterProfessions !== undefined) {
      CharacterProfessionsDTO.encode(message.characterProfessions, writer.uint32(154).fork()).join();
    }
    if (message.diseases !== undefined) {
      DiseasesDTO.encode(message.diseases, writer.uint32(162).fork()).join();
    }
    if (message.effects !== undefined) {
      EffectsDTO.encode(message.effects, writer.uint32(170).fork()).join();
    }
    if (message.facts !== undefined) {
      FactsDTO.encode(message.facts, writer.uint32(178).fork()).join();
    }
    if (message.factions !== undefined) {
      FactionsDTO.encode(message.factions, writer.uint32(186).fork()).join();
    }
    if (message.storageSlots !== undefined) {
      StorageSlotsDTO.encode(message.storageSlots, writer.uint32(194).fork()).join();
    }
    if (message.equipmentSlots !== undefined) {
      EquipmentSlotsDTO.encode(message.equipmentSlots, writer.uint32(202).fork()).join();
    }
    if (message.itemSets !== undefined) {
      ItemSetsDTO.encode(message.itemSets, writer.uint32(210).fork()).join();
    }
    if (message.moods !== undefined) {
      MoodsDTO.encode(message.moods, writer.uint32(218).fork()).join();
    }
    if (message.needs !== undefined) {
      NeedsDTO.encode(message.needs, writer.uint32(226).fork()).join();
    }
    if (message.personalityProfiles !== undefined) {
      PersonalityProfilesDTO.encode(message.personalityProfiles, writer.uint32(234).fork()).join();
    }
    if (message.races !== undefined) {
      RacesDTO.encode(message.races, writer.uint32(242).fork()).join();
    }
    if (message.religions !== undefined) {
      ReligionsDTO.encode(message.religions, writer.uint32(250).fork()).join();
    }
    if (message.resistances !== undefined) {
      ResistancesDTO.encode(message.resistances, writer.uint32(258).fork()).join();
    }
    if (message.statuses !== undefined) {
      StatusesDTO.encode(message.statuses, writer.uint32(266).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(274).fork()).join();
    }
    if (message.backgrounds !== undefined) {
      BackgroundsDTO.encode(message.backgrounds, writer.uint32(282).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.settings = WorldSettings.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.frozen = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.campaigns = CampaignsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.items = ItemsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pastExperiences = PastExperiencesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.characterMemories = CharacterMemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.memories = MemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.memoryPools = MemoryPoolsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.memoryPoolEntries = MemoryPoolEntriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.skills = SkillsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.traits = TraitsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.addictions = AddictionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.birthsigns = BirthsignsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.characters = CharactersDTO.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.characterProfessions = CharacterProfessionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.diseases = DiseasesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.effects = EffectsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.facts = FactsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.factions = FactionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.storageSlots = StorageSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.equipmentSlots = EquipmentSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.itemSets = ItemSetsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.moods = MoodsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.needs = NeedsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.personalityProfiles = PersonalityProfilesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.races = RacesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.religions = ReligionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.resistances = ResistancesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.statuses = StatusesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.backgrounds = BackgroundsDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      settings: isSet(object.settings) ? WorldSettings.fromJSON(object.settings) : undefined,
      frozen: isSet(object.frozen) ? globalThis.Boolean(object.frozen) : false,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      campaigns: isSet(object.campaigns) ? CampaignsDTO.fromJSON(object.campaigns) : undefined,
      items: isSet(object.items) ? ItemsDTO.fromJSON(object.items) : undefined,
      pastExperiences: isSet(object.pastExperiences) ? PastExperiencesDTO.fromJSON(object.pastExperiences) : undefined,
      characterMemories: isSet(object.characterMemories)
        ? CharacterMemoriesDTO.fromJSON(object.characterMemories)
        : undefined,
      memories: isSet(object.memories) ? MemoriesDTO.fromJSON(object.memories) : undefined,
      memoryPools: isSet(object.memoryPools) ? MemoryPoolsDTO.fromJSON(object.memoryPools) : undefined,
      memoryPoolEntries: isSet(object.memoryPoolEntries)
        ? MemoryPoolEntriesDTO.fromJSON(object.memoryPoolEntries)
        : undefined,
      skills: isSet(object.skills) ? SkillsDTO.fromJSON(object.skills) : undefined,
      traits: isSet(object.traits) ? TraitsDTO.fromJSON(object.traits) : undefined,
      addictions: isSet(object.addictions) ? AddictionsDTO.fromJSON(object.addictions) : undefined,
      birthsigns: isSet(object.birthsigns) ? BirthsignsDTO.fromJSON(object.birthsigns) : undefined,
      characters: isSet(object.characters) ? CharactersDTO.fromJSON(object.characters) : undefined,
      characterProfessions: isSet(object.characterProfessions)
        ? CharacterProfessionsDTO.fromJSON(object.characterProfessions)
        : undefined,
      diseases: isSet(object.diseases) ? DiseasesDTO.fromJSON(object.diseases) : undefined,
      effects: isSet(object.effects) ? EffectsDTO.fromJSON(object.effects) : undefined,
      facts: isSet(object.facts) ? FactsDTO.fromJSON(object.facts) : undefined,
      factions: isSet(object.factions) ? FactionsDTO.fromJSON(object.factions) : undefined,
      storageSlots: isSet(object.storageSlots) ? StorageSlotsDTO.fromJSON(object.storageSlots) : undefined,
      equipmentSlots: isSet(object.equipmentSlots) ? EquipmentSlotsDTO.fromJSON(object.equipmentSlots) : undefined,
      itemSets: isSet(object.itemSets) ? ItemSetsDTO.fromJSON(object.itemSets) : undefined,
      moods: isSet(object.moods) ? MoodsDTO.fromJSON(object.moods) : undefined,
      needs: isSet(object.needs) ? NeedsDTO.fromJSON(object.needs) : undefined,
      personalityProfiles: isSet(object.personalityProfiles)
        ? PersonalityProfilesDTO.fromJSON(object.personalityProfiles)
        : undefined,
      races: isSet(object.races) ? RacesDTO.fromJSON(object.races) : undefined,
      religions: isSet(object.religions) ? ReligionsDTO.fromJSON(object.religions) : undefined,
      resistances: isSet(object.resistances) ? ResistancesDTO.fromJSON(object.resistances) : undefined,
      statuses: isSet(object.statuses) ? StatusesDTO.fromJSON(object.statuses) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      backgrounds: isSet(object.backgrounds) ? BackgroundsDTO.fromJSON(object.backgrounds) : undefined,
    };
  },

  toJSON(message: WorldDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.settings !== undefined) {
      obj.settings = WorldSettings.toJSON(message.settings);
    }
    if (message.frozen !== false) {
      obj.frozen = message.frozen;
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.campaigns !== undefined) {
      obj.campaigns = CampaignsDTO.toJSON(message.campaigns);
    }
    if (message.items !== undefined) {
      obj.items = ItemsDTO.toJSON(message.items);
    }
    if (message.pastExperiences !== undefined) {
      obj.pastExperiences = PastExperiencesDTO.toJSON(message.pastExperiences);
    }
    if (message.characterMemories !== undefined) {
      obj.characterMemories = CharacterMemoriesDTO.toJSON(message.characterMemories);
    }
    if (message.memories !== undefined) {
      obj.memories = MemoriesDTO.toJSON(message.memories);
    }
    if (message.memoryPools !== undefined) {
      obj.memoryPools = MemoryPoolsDTO.toJSON(message.memoryPools);
    }
    if (message.memoryPoolEntries !== undefined) {
      obj.memoryPoolEntries = MemoryPoolEntriesDTO.toJSON(message.memoryPoolEntries);
    }
    if (message.skills !== undefined) {
      obj.skills = SkillsDTO.toJSON(message.skills);
    }
    if (message.traits !== undefined) {
      obj.traits = TraitsDTO.toJSON(message.traits);
    }
    if (message.addictions !== undefined) {
      obj.addictions = AddictionsDTO.toJSON(message.addictions);
    }
    if (message.birthsigns !== undefined) {
      obj.birthsigns = BirthsignsDTO.toJSON(message.birthsigns);
    }
    if (message.characters !== undefined) {
      obj.characters = CharactersDTO.toJSON(message.characters);
    }
    if (message.characterProfessions !== undefined) {
      obj.characterProfessions = CharacterProfessionsDTO.toJSON(message.characterProfessions);
    }
    if (message.diseases !== undefined) {
      obj.diseases = DiseasesDTO.toJSON(message.diseases);
    }
    if (message.effects !== undefined) {
      obj.effects = EffectsDTO.toJSON(message.effects);
    }
    if (message.facts !== undefined) {
      obj.facts = FactsDTO.toJSON(message.facts);
    }
    if (message.factions !== undefined) {
      obj.factions = FactionsDTO.toJSON(message.factions);
    }
    if (message.storageSlots !== undefined) {
      obj.storageSlots = StorageSlotsDTO.toJSON(message.storageSlots);
    }
    if (message.equipmentSlots !== undefined) {
      obj.equipmentSlots = EquipmentSlotsDTO.toJSON(message.equipmentSlots);
    }
    if (message.itemSets !== undefined) {
      obj.itemSets = ItemSetsDTO.toJSON(message.itemSets);
    }
    if (message.moods !== undefined) {
      obj.moods = MoodsDTO.toJSON(message.moods);
    }
    if (message.needs !== undefined) {
      obj.needs = NeedsDTO.toJSON(message.needs);
    }
    if (message.personalityProfiles !== undefined) {
      obj.personalityProfiles = PersonalityProfilesDTO.toJSON(message.personalityProfiles);
    }
    if (message.races !== undefined) {
      obj.races = RacesDTO.toJSON(message.races);
    }
    if (message.religions !== undefined) {
      obj.religions = ReligionsDTO.toJSON(message.religions);
    }
    if (message.resistances !== undefined) {
      obj.resistances = ResistancesDTO.toJSON(message.resistances);
    }
    if (message.statuses !== undefined) {
      obj.statuses = StatusesDTO.toJSON(message.statuses);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.backgrounds !== undefined) {
      obj.backgrounds = BackgroundsDTO.toJSON(message.backgrounds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldDTO>, I>>(base?: I): WorldDTO {
    return WorldDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldDTO>, I>>(object: I): WorldDTO {
    const message = createBaseWorldDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.settings = (object.settings !== undefined && object.settings !== null)
      ? WorldSettings.fromPartial(object.settings)
      : undefined;
    message.frozen = object.frozen ?? false;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.campaigns = (object.campaigns !== undefined && object.campaigns !== null)
      ? CampaignsDTO.fromPartial(object.campaigns)
      : undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? ItemsDTO.fromPartial(object.items)
      : undefined;
    message.pastExperiences = (object.pastExperiences !== undefined && object.pastExperiences !== null)
      ? PastExperiencesDTO.fromPartial(object.pastExperiences)
      : undefined;
    message.characterMemories = (object.characterMemories !== undefined && object.characterMemories !== null)
      ? CharacterMemoriesDTO.fromPartial(object.characterMemories)
      : undefined;
    message.memories = (object.memories !== undefined && object.memories !== null)
      ? MemoriesDTO.fromPartial(object.memories)
      : undefined;
    message.memoryPools = (object.memoryPools !== undefined && object.memoryPools !== null)
      ? MemoryPoolsDTO.fromPartial(object.memoryPools)
      : undefined;
    message.memoryPoolEntries = (object.memoryPoolEntries !== undefined && object.memoryPoolEntries !== null)
      ? MemoryPoolEntriesDTO.fromPartial(object.memoryPoolEntries)
      : undefined;
    message.skills = (object.skills !== undefined && object.skills !== null)
      ? SkillsDTO.fromPartial(object.skills)
      : undefined;
    message.traits = (object.traits !== undefined && object.traits !== null)
      ? TraitsDTO.fromPartial(object.traits)
      : undefined;
    message.addictions = (object.addictions !== undefined && object.addictions !== null)
      ? AddictionsDTO.fromPartial(object.addictions)
      : undefined;
    message.birthsigns = (object.birthsigns !== undefined && object.birthsigns !== null)
      ? BirthsignsDTO.fromPartial(object.birthsigns)
      : undefined;
    message.characters = (object.characters !== undefined && object.characters !== null)
      ? CharactersDTO.fromPartial(object.characters)
      : undefined;
    message.characterProfessions = (object.characterProfessions !== undefined && object.characterProfessions !== null)
      ? CharacterProfessionsDTO.fromPartial(object.characterProfessions)
      : undefined;
    message.diseases = (object.diseases !== undefined && object.diseases !== null)
      ? DiseasesDTO.fromPartial(object.diseases)
      : undefined;
    message.effects = (object.effects !== undefined && object.effects !== null)
      ? EffectsDTO.fromPartial(object.effects)
      : undefined;
    message.facts = (object.facts !== undefined && object.facts !== null)
      ? FactsDTO.fromPartial(object.facts)
      : undefined;
    message.factions = (object.factions !== undefined && object.factions !== null)
      ? FactionsDTO.fromPartial(object.factions)
      : undefined;
    message.storageSlots = (object.storageSlots !== undefined && object.storageSlots !== null)
      ? StorageSlotsDTO.fromPartial(object.storageSlots)
      : undefined;
    message.equipmentSlots = (object.equipmentSlots !== undefined && object.equipmentSlots !== null)
      ? EquipmentSlotsDTO.fromPartial(object.equipmentSlots)
      : undefined;
    message.itemSets = (object.itemSets !== undefined && object.itemSets !== null)
      ? ItemSetsDTO.fromPartial(object.itemSets)
      : undefined;
    message.moods = (object.moods !== undefined && object.moods !== null)
      ? MoodsDTO.fromPartial(object.moods)
      : undefined;
    message.needs = (object.needs !== undefined && object.needs !== null)
      ? NeedsDTO.fromPartial(object.needs)
      : undefined;
    message.personalityProfiles = (object.personalityProfiles !== undefined && object.personalityProfiles !== null)
      ? PersonalityProfilesDTO.fromPartial(object.personalityProfiles)
      : undefined;
    message.races = (object.races !== undefined && object.races !== null)
      ? RacesDTO.fromPartial(object.races)
      : undefined;
    message.religions = (object.religions !== undefined && object.religions !== null)
      ? ReligionsDTO.fromPartial(object.religions)
      : undefined;
    message.resistances = (object.resistances !== undefined && object.resistances !== null)
      ? ResistancesDTO.fromPartial(object.resistances)
      : undefined;
    message.statuses = (object.statuses !== undefined && object.statuses !== null)
      ? StatusesDTO.fromPartial(object.statuses)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.backgrounds = (object.backgrounds !== undefined && object.backgrounds !== null)
      ? BackgroundsDTO.fromPartial(object.backgrounds)
      : undefined;
    return message;
  },
};

function createBaseWorldsDTO(): WorldsDTO {
  return { worlds: [] };
}

export const WorldsDTO: MessageFns<WorldsDTO> = {
  encode(message: WorldsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.worlds) {
      WorldDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorldsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorldsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.worlds.push(WorldDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorldsDTO {
    return {
      worlds: globalThis.Array.isArray(object?.worlds) ? object.worlds.map((e: any) => WorldDTO.fromJSON(e)) : [],
    };
  },

  toJSON(message: WorldsDTO): unknown {
    const obj: any = {};
    if (message.worlds?.length) {
      obj.worlds = message.worlds.map((e) => WorldDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorldsDTO>, I>>(base?: I): WorldsDTO {
    return WorldsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorldsDTO>, I>>(object: I): WorldsDTO {
    const message = createBaseWorldsDTO();
    message.worlds = object.worlds?.map((e) => WorldDTO.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCampaignDTO(): CampaignDTO {
  return {
    id: "",
    name: "",
    description: "",
    dynamicState: {},
    createdAt: "",
    world: undefined,
    user: undefined,
    items: undefined,
    pastExperiences: undefined,
    characterMemories: undefined,
    memories: undefined,
    memoryPools: undefined,
    memoryPoolEntries: undefined,
    skills: undefined,
    traits: undefined,
    addictions: undefined,
    birthsigns: undefined,
    characters: undefined,
    characterProfessions: undefined,
    diseases: undefined,
    effects: undefined,
    facts: undefined,
    factions: undefined,
    storageSlots: undefined,
    equipmentSlots: undefined,
    itemSets: undefined,
    moods: undefined,
    needs: undefined,
    personalityProfiles: undefined,
    races: undefined,
    religions: undefined,
    resistances: undefined,
    statuses: undefined,
    tags: undefined,
    backgrounds: undefined,
  };
}

export const CampaignDTO: MessageFns<CampaignDTO> = {
  encode(message: CampaignDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.dynamicState).forEach(([key, value]) => {
      CampaignDTO_DynamicStateEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.world !== undefined) {
      WorldDTO.encode(message.world, writer.uint32(50).fork()).join();
    }
    if (message.user !== undefined) {
      UserDTO.encode(message.user, writer.uint32(58).fork()).join();
    }
    if (message.items !== undefined) {
      ItemsDTO.encode(message.items, writer.uint32(66).fork()).join();
    }
    if (message.pastExperiences !== undefined) {
      PastExperiencesDTO.encode(message.pastExperiences, writer.uint32(74).fork()).join();
    }
    if (message.characterMemories !== undefined) {
      CharacterMemoriesDTO.encode(message.characterMemories, writer.uint32(82).fork()).join();
    }
    if (message.memories !== undefined) {
      MemoriesDTO.encode(message.memories, writer.uint32(90).fork()).join();
    }
    if (message.memoryPools !== undefined) {
      MemoryPoolsDTO.encode(message.memoryPools, writer.uint32(98).fork()).join();
    }
    if (message.memoryPoolEntries !== undefined) {
      MemoryPoolEntriesDTO.encode(message.memoryPoolEntries, writer.uint32(106).fork()).join();
    }
    if (message.skills !== undefined) {
      SkillsDTO.encode(message.skills, writer.uint32(114).fork()).join();
    }
    if (message.traits !== undefined) {
      TraitsDTO.encode(message.traits, writer.uint32(122).fork()).join();
    }
    if (message.addictions !== undefined) {
      AddictionsDTO.encode(message.addictions, writer.uint32(130).fork()).join();
    }
    if (message.birthsigns !== undefined) {
      BirthsignsDTO.encode(message.birthsigns, writer.uint32(138).fork()).join();
    }
    if (message.characters !== undefined) {
      CharactersDTO.encode(message.characters, writer.uint32(146).fork()).join();
    }
    if (message.characterProfessions !== undefined) {
      CharacterProfessionsDTO.encode(message.characterProfessions, writer.uint32(154).fork()).join();
    }
    if (message.diseases !== undefined) {
      DiseasesDTO.encode(message.diseases, writer.uint32(162).fork()).join();
    }
    if (message.effects !== undefined) {
      EffectsDTO.encode(message.effects, writer.uint32(170).fork()).join();
    }
    if (message.facts !== undefined) {
      FactsDTO.encode(message.facts, writer.uint32(178).fork()).join();
    }
    if (message.factions !== undefined) {
      FactionsDTO.encode(message.factions, writer.uint32(186).fork()).join();
    }
    if (message.storageSlots !== undefined) {
      StorageSlotsDTO.encode(message.storageSlots, writer.uint32(194).fork()).join();
    }
    if (message.equipmentSlots !== undefined) {
      EquipmentSlotsDTO.encode(message.equipmentSlots, writer.uint32(202).fork()).join();
    }
    if (message.itemSets !== undefined) {
      ItemSetsDTO.encode(message.itemSets, writer.uint32(210).fork()).join();
    }
    if (message.moods !== undefined) {
      MoodsDTO.encode(message.moods, writer.uint32(218).fork()).join();
    }
    if (message.needs !== undefined) {
      NeedsDTO.encode(message.needs, writer.uint32(226).fork()).join();
    }
    if (message.personalityProfiles !== undefined) {
      PersonalityProfilesDTO.encode(message.personalityProfiles, writer.uint32(234).fork()).join();
    }
    if (message.races !== undefined) {
      RacesDTO.encode(message.races, writer.uint32(242).fork()).join();
    }
    if (message.religions !== undefined) {
      ReligionsDTO.encode(message.religions, writer.uint32(250).fork()).join();
    }
    if (message.resistances !== undefined) {
      ResistancesDTO.encode(message.resistances, writer.uint32(258).fork()).join();
    }
    if (message.statuses !== undefined) {
      StatusesDTO.encode(message.statuses, writer.uint32(266).fork()).join();
    }
    if (message.tags !== undefined) {
      TagsDTO.encode(message.tags, writer.uint32(274).fork()).join();
    }
    if (message.backgrounds !== undefined) {
      BackgroundsDTO.encode(message.backgrounds, writer.uint32(282).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CampaignDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CampaignDTO_DynamicStateEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.dynamicState[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.world = WorldDTO.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user = UserDTO.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.items = ItemsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pastExperiences = PastExperiencesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.characterMemories = CharacterMemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.memories = MemoriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.memoryPools = MemoryPoolsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.memoryPoolEntries = MemoryPoolEntriesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.skills = SkillsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.traits = TraitsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.addictions = AddictionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.birthsigns = BirthsignsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.characters = CharactersDTO.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.characterProfessions = CharacterProfessionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.diseases = DiseasesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.effects = EffectsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.facts = FactsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.factions = FactionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.storageSlots = StorageSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.equipmentSlots = EquipmentSlotsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.itemSets = ItemSetsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.moods = MoodsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.needs = NeedsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.personalityProfiles = PersonalityProfilesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.races = RacesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.religions = ReligionsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.resistances = ResistancesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.statuses = StatusesDTO.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.tags = TagsDTO.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.backgrounds = BackgroundsDTO.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampaignDTO {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      dynamicState: isObject(object.dynamicState)
        ? Object.entries(object.dynamicState).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      world: isSet(object.world) ? WorldDTO.fromJSON(object.world) : undefined,
      user: isSet(object.user) ? UserDTO.fromJSON(object.user) : undefined,
      items: isSet(object.items) ? ItemsDTO.fromJSON(object.items) : undefined,
      pastExperiences: isSet(object.pastExperiences) ? PastExperiencesDTO.fromJSON(object.pastExperiences) : undefined,
      characterMemories: isSet(object.characterMemories)
        ? CharacterMemoriesDTO.fromJSON(object.characterMemories)
        : undefined,
      memories: isSet(object.memories) ? MemoriesDTO.fromJSON(object.memories) : undefined,
      memoryPools: isSet(object.memoryPools) ? MemoryPoolsDTO.fromJSON(object.memoryPools) : undefined,
      memoryPoolEntries: isSet(object.memoryPoolEntries)
        ? MemoryPoolEntriesDTO.fromJSON(object.memoryPoolEntries)
        : undefined,
      skills: isSet(object.skills) ? SkillsDTO.fromJSON(object.skills) : undefined,
      traits: isSet(object.traits) ? TraitsDTO.fromJSON(object.traits) : undefined,
      addictions: isSet(object.addictions) ? AddictionsDTO.fromJSON(object.addictions) : undefined,
      birthsigns: isSet(object.birthsigns) ? BirthsignsDTO.fromJSON(object.birthsigns) : undefined,
      characters: isSet(object.characters) ? CharactersDTO.fromJSON(object.characters) : undefined,
      characterProfessions: isSet(object.characterProfessions)
        ? CharacterProfessionsDTO.fromJSON(object.characterProfessions)
        : undefined,
      diseases: isSet(object.diseases) ? DiseasesDTO.fromJSON(object.diseases) : undefined,
      effects: isSet(object.effects) ? EffectsDTO.fromJSON(object.effects) : undefined,
      facts: isSet(object.facts) ? FactsDTO.fromJSON(object.facts) : undefined,
      factions: isSet(object.factions) ? FactionsDTO.fromJSON(object.factions) : undefined,
      storageSlots: isSet(object.storageSlots) ? StorageSlotsDTO.fromJSON(object.storageSlots) : undefined,
      equipmentSlots: isSet(object.equipmentSlots) ? EquipmentSlotsDTO.fromJSON(object.equipmentSlots) : undefined,
      itemSets: isSet(object.itemSets) ? ItemSetsDTO.fromJSON(object.itemSets) : undefined,
      moods: isSet(object.moods) ? MoodsDTO.fromJSON(object.moods) : undefined,
      needs: isSet(object.needs) ? NeedsDTO.fromJSON(object.needs) : undefined,
      personalityProfiles: isSet(object.personalityProfiles)
        ? PersonalityProfilesDTO.fromJSON(object.personalityProfiles)
        : undefined,
      races: isSet(object.races) ? RacesDTO.fromJSON(object.races) : undefined,
      religions: isSet(object.religions) ? ReligionsDTO.fromJSON(object.religions) : undefined,
      resistances: isSet(object.resistances) ? ResistancesDTO.fromJSON(object.resistances) : undefined,
      statuses: isSet(object.statuses) ? StatusesDTO.fromJSON(object.statuses) : undefined,
      tags: isSet(object.tags) ? TagsDTO.fromJSON(object.tags) : undefined,
      backgrounds: isSet(object.backgrounds) ? BackgroundsDTO.fromJSON(object.backgrounds) : undefined,
    };
  },

  toJSON(message: CampaignDTO): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.dynamicState) {
      const entries = Object.entries(message.dynamicState);
      if (entries.length > 0) {
        obj.dynamicState = {};
        entries.forEach(([k, v]) => {
          obj.dynamicState[k] = v;
        });
      }
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.world !== undefined) {
      obj.world = WorldDTO.toJSON(message.world);
    }
    if (message.user !== undefined) {
      obj.user = UserDTO.toJSON(message.user);
    }
    if (message.items !== undefined) {
      obj.items = ItemsDTO.toJSON(message.items);
    }
    if (message.pastExperiences !== undefined) {
      obj.pastExperiences = PastExperiencesDTO.toJSON(message.pastExperiences);
    }
    if (message.characterMemories !== undefined) {
      obj.characterMemories = CharacterMemoriesDTO.toJSON(message.characterMemories);
    }
    if (message.memories !== undefined) {
      obj.memories = MemoriesDTO.toJSON(message.memories);
    }
    if (message.memoryPools !== undefined) {
      obj.memoryPools = MemoryPoolsDTO.toJSON(message.memoryPools);
    }
    if (message.memoryPoolEntries !== undefined) {
      obj.memoryPoolEntries = MemoryPoolEntriesDTO.toJSON(message.memoryPoolEntries);
    }
    if (message.skills !== undefined) {
      obj.skills = SkillsDTO.toJSON(message.skills);
    }
    if (message.traits !== undefined) {
      obj.traits = TraitsDTO.toJSON(message.traits);
    }
    if (message.addictions !== undefined) {
      obj.addictions = AddictionsDTO.toJSON(message.addictions);
    }
    if (message.birthsigns !== undefined) {
      obj.birthsigns = BirthsignsDTO.toJSON(message.birthsigns);
    }
    if (message.characters !== undefined) {
      obj.characters = CharactersDTO.toJSON(message.characters);
    }
    if (message.characterProfessions !== undefined) {
      obj.characterProfessions = CharacterProfessionsDTO.toJSON(message.characterProfessions);
    }
    if (message.diseases !== undefined) {
      obj.diseases = DiseasesDTO.toJSON(message.diseases);
    }
    if (message.effects !== undefined) {
      obj.effects = EffectsDTO.toJSON(message.effects);
    }
    if (message.facts !== undefined) {
      obj.facts = FactsDTO.toJSON(message.facts);
    }
    if (message.factions !== undefined) {
      obj.factions = FactionsDTO.toJSON(message.factions);
    }
    if (message.storageSlots !== undefined) {
      obj.storageSlots = StorageSlotsDTO.toJSON(message.storageSlots);
    }
    if (message.equipmentSlots !== undefined) {
      obj.equipmentSlots = EquipmentSlotsDTO.toJSON(message.equipmentSlots);
    }
    if (message.itemSets !== undefined) {
      obj.itemSets = ItemSetsDTO.toJSON(message.itemSets);
    }
    if (message.moods !== undefined) {
      obj.moods = MoodsDTO.toJSON(message.moods);
    }
    if (message.needs !== undefined) {
      obj.needs = NeedsDTO.toJSON(message.needs);
    }
    if (message.personalityProfiles !== undefined) {
      obj.personalityProfiles = PersonalityProfilesDTO.toJSON(message.personalityProfiles);
    }
    if (message.races !== undefined) {
      obj.races = RacesDTO.toJSON(message.races);
    }
    if (message.religions !== undefined) {
      obj.religions = ReligionsDTO.toJSON(message.religions);
    }
    if (message.resistances !== undefined) {
      obj.resistances = ResistancesDTO.toJSON(message.resistances);
    }
    if (message.statuses !== undefined) {
      obj.statuses = StatusesDTO.toJSON(message.statuses);
    }
    if (message.tags !== undefined) {
      obj.tags = TagsDTO.toJSON(message.tags);
    }
    if (message.backgrounds !== undefined) {
      obj.backgrounds = BackgroundsDTO.toJSON(message.backgrounds);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CampaignDTO>, I>>(base?: I): CampaignDTO {
    return CampaignDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CampaignDTO>, I>>(object: I): CampaignDTO {
    const message = createBaseCampaignDTO();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.dynamicState = Object.entries(object.dynamicState ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createdAt = object.createdAt ?? "";
    message.world = (object.world !== undefined && object.world !== null)
      ? WorldDTO.fromPartial(object.world)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserDTO.fromPartial(object.user) : undefined;
    message.items = (object.items !== undefined && object.items !== null)
      ? ItemsDTO.fromPartial(object.items)
      : undefined;
    message.pastExperiences = (object.pastExperiences !== undefined && object.pastExperiences !== null)
      ? PastExperiencesDTO.fromPartial(object.pastExperiences)
      : undefined;
    message.characterMemories = (object.characterMemories !== undefined && object.characterMemories !== null)
      ? CharacterMemoriesDTO.fromPartial(object.characterMemories)
      : undefined;
    message.memories = (object.memories !== undefined && object.memories !== null)
      ? MemoriesDTO.fromPartial(object.memories)
      : undefined;
    message.memoryPools = (object.memoryPools !== undefined && object.memoryPools !== null)
      ? MemoryPoolsDTO.fromPartial(object.memoryPools)
      : undefined;
    message.memoryPoolEntries = (object.memoryPoolEntries !== undefined && object.memoryPoolEntries !== null)
      ? MemoryPoolEntriesDTO.fromPartial(object.memoryPoolEntries)
      : undefined;
    message.skills = (object.skills !== undefined && object.skills !== null)
      ? SkillsDTO.fromPartial(object.skills)
      : undefined;
    message.traits = (object.traits !== undefined && object.traits !== null)
      ? TraitsDTO.fromPartial(object.traits)
      : undefined;
    message.addictions = (object.addictions !== undefined && object.addictions !== null)
      ? AddictionsDTO.fromPartial(object.addictions)
      : undefined;
    message.birthsigns = (object.birthsigns !== undefined && object.birthsigns !== null)
      ? BirthsignsDTO.fromPartial(object.birthsigns)
      : undefined;
    message.characters = (object.characters !== undefined && object.characters !== null)
      ? CharactersDTO.fromPartial(object.characters)
      : undefined;
    message.characterProfessions = (object.characterProfessions !== undefined && object.characterProfessions !== null)
      ? CharacterProfessionsDTO.fromPartial(object.characterProfessions)
      : undefined;
    message.diseases = (object.diseases !== undefined && object.diseases !== null)
      ? DiseasesDTO.fromPartial(object.diseases)
      : undefined;
    message.effects = (object.effects !== undefined && object.effects !== null)
      ? EffectsDTO.fromPartial(object.effects)
      : undefined;
    message.facts = (object.facts !== undefined && object.facts !== null)
      ? FactsDTO.fromPartial(object.facts)
      : undefined;
    message.factions = (object.factions !== undefined && object.factions !== null)
      ? FactionsDTO.fromPartial(object.factions)
      : undefined;
    message.storageSlots = (object.storageSlots !== undefined && object.storageSlots !== null)
      ? StorageSlotsDTO.fromPartial(object.storageSlots)
      : undefined;
    message.equipmentSlots = (object.equipmentSlots !== undefined && object.equipmentSlots !== null)
      ? EquipmentSlotsDTO.fromPartial(object.equipmentSlots)
      : undefined;
    message.itemSets = (object.itemSets !== undefined && object.itemSets !== null)
      ? ItemSetsDTO.fromPartial(object.itemSets)
      : undefined;
    message.moods = (object.moods !== undefined && object.moods !== null)
      ? MoodsDTO.fromPartial(object.moods)
      : undefined;
    message.needs = (object.needs !== undefined && object.needs !== null)
      ? NeedsDTO.fromPartial(object.needs)
      : undefined;
    message.personalityProfiles = (object.personalityProfiles !== undefined && object.personalityProfiles !== null)
      ? PersonalityProfilesDTO.fromPartial(object.personalityProfiles)
      : undefined;
    message.races = (object.races !== undefined && object.races !== null)
      ? RacesDTO.fromPartial(object.races)
      : undefined;
    message.religions = (object.religions !== undefined && object.religions !== null)
      ? ReligionsDTO.fromPartial(object.religions)
      : undefined;
    message.resistances = (object.resistances !== undefined && object.resistances !== null)
      ? ResistancesDTO.fromPartial(object.resistances)
      : undefined;
    message.statuses = (object.statuses !== undefined && object.statuses !== null)
      ? StatusesDTO.fromPartial(object.statuses)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? TagsDTO.fromPartial(object.tags) : undefined;
    message.backgrounds = (object.backgrounds !== undefined && object.backgrounds !== null)
      ? BackgroundsDTO.fromPartial(object.backgrounds)
      : undefined;
    return message;
  },
};

function createBaseCampaignDTO_DynamicStateEntry(): CampaignDTO_DynamicStateEntry {
  return { key: "", value: "" };
}

export const CampaignDTO_DynamicStateEntry: MessageFns<CampaignDTO_DynamicStateEntry> = {
  encode(message: CampaignDTO_DynamicStateEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CampaignDTO_DynamicStateEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignDTO_DynamicStateEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampaignDTO_DynamicStateEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CampaignDTO_DynamicStateEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CampaignDTO_DynamicStateEntry>, I>>(base?: I): CampaignDTO_DynamicStateEntry {
    return CampaignDTO_DynamicStateEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CampaignDTO_DynamicStateEntry>, I>>(
    object: I,
  ): CampaignDTO_DynamicStateEntry {
    const message = createBaseCampaignDTO_DynamicStateEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCampaignsDTO(): CampaignsDTO {
  return { campaigns: [] };
}

export const CampaignsDTO: MessageFns<CampaignsDTO> = {
  encode(message: CampaignsDTO, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.campaigns) {
      CampaignDTO.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CampaignsDTO {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaignsDTO();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.campaigns.push(CampaignDTO.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CampaignsDTO {
    return {
      campaigns: globalThis.Array.isArray(object?.campaigns)
        ? object.campaigns.map((e: any) => CampaignDTO.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CampaignsDTO): unknown {
    const obj: any = {};
    if (message.campaigns?.length) {
      obj.campaigns = message.campaigns.map((e) => CampaignDTO.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CampaignsDTO>, I>>(base?: I): CampaignsDTO {
    return CampaignsDTO.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CampaignsDTO>, I>>(object: I): CampaignsDTO {
    const message = createBaseCampaignsDTO();
    message.campaigns = object.campaigns?.map((e) => CampaignDTO.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
