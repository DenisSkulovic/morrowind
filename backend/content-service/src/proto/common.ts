// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.3.0
//   protoc               v3.20.3
// source: src/proto/common.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "common";

export enum EffectType {
  DAMAGE = 0,
  HEALING = 1,
  BUFF = 2,
  DEBUFF = 3,
  RESISTANCE = 4,
  STEALING = 5,
  NEUTRAL = 6,
  UNRECOGNIZED = -1,
}

export function effectTypeFromJSON(object: any): EffectType {
  switch (object) {
    case 0:
    case "DAMAGE":
      return EffectType.DAMAGE;
    case 1:
    case "HEALING":
      return EffectType.HEALING;
    case 2:
    case "BUFF":
      return EffectType.BUFF;
    case 3:
    case "DEBUFF":
      return EffectType.DEBUFF;
    case 4:
    case "RESISTANCE":
      return EffectType.RESISTANCE;
    case 5:
    case "STEALING":
      return EffectType.STEALING;
    case 6:
    case "NEUTRAL":
      return EffectType.NEUTRAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectType.UNRECOGNIZED;
  }
}

export function effectTypeToJSON(object: EffectType): string {
  switch (object) {
    case EffectType.DAMAGE:
      return "DAMAGE";
    case EffectType.HEALING:
      return "HEALING";
    case EffectType.BUFF:
      return "BUFF";
    case EffectType.DEBUFF:
      return "DEBUFF";
    case EffectType.RESISTANCE:
      return "RESISTANCE";
    case EffectType.STEALING:
      return "STEALING";
    case EffectType.NEUTRAL:
      return "NEUTRAL";
    case EffectType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EffectTarget {
  HEALTH = 0,
  STAMINA = 1,
  MANA = 2,
  UNRECOGNIZED = -1,
}

export function effectTargetFromJSON(object: any): EffectTarget {
  switch (object) {
    case 0:
    case "HEALTH":
      return EffectTarget.HEALTH;
    case 1:
    case "STAMINA":
      return EffectTarget.STAMINA;
    case 2:
    case "MANA":
      return EffectTarget.MANA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectTarget.UNRECOGNIZED;
  }
}

export function effectTargetToJSON(object: EffectTarget): string {
  switch (object) {
    case EffectTarget.HEALTH:
      return "HEALTH";
    case EffectTarget.STAMINA:
      return "STAMINA";
    case EffectTarget.MANA:
      return "MANA";
    case EffectTarget.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EffectMode {
  INSTANT = 0,
  GRADUAL = 1,
  PERSISTENT = 2,
  UNRECOGNIZED = -1,
}

export function effectModeFromJSON(object: any): EffectMode {
  switch (object) {
    case 0:
    case "INSTANT":
      return EffectMode.INSTANT;
    case 1:
    case "GRADUAL":
      return EffectMode.GRADUAL;
    case 2:
    case "PERSISTENT":
      return EffectMode.PERSISTENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectMode.UNRECOGNIZED;
  }
}

export function effectModeToJSON(object: EffectMode): string {
  switch (object) {
    case EffectMode.INSTANT:
      return "INSTANT";
    case EffectMode.GRADUAL:
      return "GRADUAL";
    case EffectMode.PERSISTENT:
      return "PERSISTENT";
    case EffectMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EffectElement {
  FIRE = 0,
  FROST = 1,
  POISON = 2,
  SHOCK = 3,
  UNRECOGNIZED = -1,
}

export function effectElementFromJSON(object: any): EffectElement {
  switch (object) {
    case 0:
    case "FIRE":
      return EffectElement.FIRE;
    case 1:
    case "FROST":
      return EffectElement.FROST;
    case 2:
    case "POISON":
      return EffectElement.POISON;
    case 3:
    case "SHOCK":
      return EffectElement.SHOCK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EffectElement.UNRECOGNIZED;
  }
}

export function effectElementToJSON(object: EffectElement): string {
  switch (object) {
    case EffectElement.FIRE:
      return "FIRE";
    case EffectElement.FROST:
      return "FROST";
    case EffectElement.POISON:
      return "POISON";
    case EffectElement.SHOCK:
      return "SHOCK";
    case EffectElement.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum FactStatusEnum {
  ACCESSIBLE = 0,
  INACCESSIBLE = 1,
  UNRECOGNIZED = -1,
}

export function factStatusEnumFromJSON(object: any): FactStatusEnum {
  switch (object) {
    case 0:
    case "ACCESSIBLE":
      return FactStatusEnum.ACCESSIBLE;
    case 1:
    case "INACCESSIBLE":
      return FactStatusEnum.INACCESSIBLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FactStatusEnum.UNRECOGNIZED;
  }
}

export function factStatusEnumToJSON(object: FactStatusEnum): string {
  switch (object) {
    case FactStatusEnum.ACCESSIBLE:
      return "ACCESSIBLE";
    case FactStatusEnum.INACCESSIBLE:
      return "INACCESSIBLE";
    case FactStatusEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SkillCategoryEnum {
  CRAFTING = 0,
  MAGIC = 1,
  COMBAT = 2,
  STEALTH = 3,
  SOCIAL = 4,
  UNRECOGNIZED = -1,
}

export function skillCategoryEnumFromJSON(object: any): SkillCategoryEnum {
  switch (object) {
    case 0:
    case "CRAFTING":
      return SkillCategoryEnum.CRAFTING;
    case 1:
    case "MAGIC":
      return SkillCategoryEnum.MAGIC;
    case 2:
    case "COMBAT":
      return SkillCategoryEnum.COMBAT;
    case 3:
    case "STEALTH":
      return SkillCategoryEnum.STEALTH;
    case 4:
    case "SOCIAL":
      return SkillCategoryEnum.SOCIAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SkillCategoryEnum.UNRECOGNIZED;
  }
}

export function skillCategoryEnumToJSON(object: SkillCategoryEnum): string {
  switch (object) {
    case SkillCategoryEnum.CRAFTING:
      return "CRAFTING";
    case SkillCategoryEnum.MAGIC:
      return "MAGIC";
    case SkillCategoryEnum.COMBAT:
      return "COMBAT";
    case SkillCategoryEnum.STEALTH:
      return "STEALTH";
    case SkillCategoryEnum.SOCIAL:
      return "SOCIAL";
    case SkillCategoryEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TagSubtypeEnum {
  MATERIAL = 0,
  CULTURE = 1,
  RELATION = 2,
  FACTION = 3,
  RELIGION = 4,
  WEAPON_QUALITY = 5,
  ARMOR_QUALITY = 6,
  WEAPON_TYPE = 7,
  STATUS = 8,
  QUEST = 9,
  UNRECOGNIZED = -1,
}

export function tagSubtypeEnumFromJSON(object: any): TagSubtypeEnum {
  switch (object) {
    case 0:
    case "MATERIAL":
      return TagSubtypeEnum.MATERIAL;
    case 1:
    case "CULTURE":
      return TagSubtypeEnum.CULTURE;
    case 2:
    case "RELATION":
      return TagSubtypeEnum.RELATION;
    case 3:
    case "FACTION":
      return TagSubtypeEnum.FACTION;
    case 4:
    case "RELIGION":
      return TagSubtypeEnum.RELIGION;
    case 5:
    case "WEAPON_QUALITY":
      return TagSubtypeEnum.WEAPON_QUALITY;
    case 6:
    case "ARMOR_QUALITY":
      return TagSubtypeEnum.ARMOR_QUALITY;
    case 7:
    case "WEAPON_TYPE":
      return TagSubtypeEnum.WEAPON_TYPE;
    case 8:
    case "STATUS":
      return TagSubtypeEnum.STATUS;
    case 9:
    case "QUEST":
      return TagSubtypeEnum.QUEST;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TagSubtypeEnum.UNRECOGNIZED;
  }
}

export function tagSubtypeEnumToJSON(object: TagSubtypeEnum): string {
  switch (object) {
    case TagSubtypeEnum.MATERIAL:
      return "MATERIAL";
    case TagSubtypeEnum.CULTURE:
      return "CULTURE";
    case TagSubtypeEnum.RELATION:
      return "RELATION";
    case TagSubtypeEnum.FACTION:
      return "FACTION";
    case TagSubtypeEnum.RELIGION:
      return "RELIGION";
    case TagSubtypeEnum.WEAPON_QUALITY:
      return "WEAPON_QUALITY";
    case TagSubtypeEnum.ARMOR_QUALITY:
      return "ARMOR_QUALITY";
    case TagSubtypeEnum.WEAPON_TYPE:
      return "WEAPON_TYPE";
    case TagSubtypeEnum.STATUS:
      return "STATUS";
    case TagSubtypeEnum.QUEST:
      return "QUEST";
    case TagSubtypeEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConditionEnum {
  OR = 0,
  ANY = 1,
  AND = 2,
  UNRECOGNIZED = -1,
}

export function conditionEnumFromJSON(object: any): ConditionEnum {
  switch (object) {
    case 0:
    case "OR":
      return ConditionEnum.OR;
    case 1:
    case "ANY":
      return ConditionEnum.ANY;
    case 2:
    case "AND":
      return ConditionEnum.AND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConditionEnum.UNRECOGNIZED;
  }
}

export function conditionEnumToJSON(object: ConditionEnum): string {
  switch (object) {
    case ConditionEnum.OR:
      return "OR";
    case ConditionEnum.ANY:
      return "ANY";
    case ConditionEnum.AND:
      return "AND";
    case ConditionEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum PresetEnum {
  default = 0,
  morrowind = 1,
  UNRECOGNIZED = -1,
}

export function presetEnumFromJSON(object: any): PresetEnum {
  switch (object) {
    case 0:
    case "default":
      return PresetEnum.default;
    case 1:
    case "morrowind":
      return PresetEnum.morrowind;
    case -1:
    case "UNRECOGNIZED":
    default:
      return PresetEnum.UNRECOGNIZED;
  }
}

export function presetEnumToJSON(object: PresetEnum): string {
  switch (object) {
    case PresetEnum.default:
      return "default";
    case PresetEnum.morrowind:
      return "morrowind";
    case PresetEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum MemoryTypeEnum {
  GLOBAL = 0,
  REGIONAL = 1,
  EVENT_RELATED = 2,
  HISTORIC = 3,
  PERSONAL = 4,
  UNRECOGNIZED = -1,
}

export function memoryTypeEnumFromJSON(object: any): MemoryTypeEnum {
  switch (object) {
    case 0:
    case "GLOBAL":
      return MemoryTypeEnum.GLOBAL;
    case 1:
    case "REGIONAL":
      return MemoryTypeEnum.REGIONAL;
    case 2:
    case "EVENT_RELATED":
      return MemoryTypeEnum.EVENT_RELATED;
    case 3:
    case "HISTORIC":
      return MemoryTypeEnum.HISTORIC;
    case 4:
    case "PERSONAL":
      return MemoryTypeEnum.PERSONAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MemoryTypeEnum.UNRECOGNIZED;
  }
}

export function memoryTypeEnumToJSON(object: MemoryTypeEnum): string {
  switch (object) {
    case MemoryTypeEnum.GLOBAL:
      return "GLOBAL";
    case MemoryTypeEnum.REGIONAL:
      return "REGIONAL";
    case MemoryTypeEnum.EVENT_RELATED:
      return "EVENT_RELATED";
    case MemoryTypeEnum.HISTORIC:
      return "HISTORIC";
    case MemoryTypeEnum.PERSONAL:
      return "PERSONAL";
    case MemoryTypeEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NeedTypeEnum {
  DYNAMIC = 0,
  THRESHOLD = 1,
  EXTERNAL = 2,
  UNRECOGNIZED = -1,
}

export function needTypeEnumFromJSON(object: any): NeedTypeEnum {
  switch (object) {
    case 0:
    case "DYNAMIC":
      return NeedTypeEnum.DYNAMIC;
    case 1:
    case "THRESHOLD":
      return NeedTypeEnum.THRESHOLD;
    case 2:
    case "EXTERNAL":
      return NeedTypeEnum.EXTERNAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NeedTypeEnum.UNRECOGNIZED;
  }
}

export function needTypeEnumToJSON(object: NeedTypeEnum): string {
  switch (object) {
    case NeedTypeEnum.DYNAMIC:
      return "DYNAMIC";
    case NeedTypeEnum.THRESHOLD:
      return "THRESHOLD";
    case NeedTypeEnum.EXTERNAL:
      return "EXTERNAL";
    case NeedTypeEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum NeedLayerEnum {
  PHYSIOLOGICAL = 0,
  SAFETY = 1,
  BELONGING_AND_LOVE = 2,
  ESTEEM = 3,
  COGNITIVE = 4,
  AESTHETIC = 5,
  SELF_ACTUALIZATION = 6,
  TRANSCENDENCE = 7,
  UNRECOGNIZED = -1,
}

export function needLayerEnumFromJSON(object: any): NeedLayerEnum {
  switch (object) {
    case 0:
    case "PHYSIOLOGICAL":
      return NeedLayerEnum.PHYSIOLOGICAL;
    case 1:
    case "SAFETY":
      return NeedLayerEnum.SAFETY;
    case 2:
    case "BELONGING_AND_LOVE":
      return NeedLayerEnum.BELONGING_AND_LOVE;
    case 3:
    case "ESTEEM":
      return NeedLayerEnum.ESTEEM;
    case 4:
    case "COGNITIVE":
      return NeedLayerEnum.COGNITIVE;
    case 5:
    case "AESTHETIC":
      return NeedLayerEnum.AESTHETIC;
    case 6:
    case "SELF_ACTUALIZATION":
      return NeedLayerEnum.SELF_ACTUALIZATION;
    case 7:
    case "TRANSCENDENCE":
      return NeedLayerEnum.TRANSCENDENCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return NeedLayerEnum.UNRECOGNIZED;
  }
}

export function needLayerEnumToJSON(object: NeedLayerEnum): string {
  switch (object) {
    case NeedLayerEnum.PHYSIOLOGICAL:
      return "PHYSIOLOGICAL";
    case NeedLayerEnum.SAFETY:
      return "SAFETY";
    case NeedLayerEnum.BELONGING_AND_LOVE:
      return "BELONGING_AND_LOVE";
    case NeedLayerEnum.ESTEEM:
      return "ESTEEM";
    case NeedLayerEnum.COGNITIVE:
      return "COGNITIVE";
    case NeedLayerEnum.AESTHETIC:
      return "AESTHETIC";
    case NeedLayerEnum.SELF_ACTUALIZATION:
      return "SELF_ACTUALIZATION";
    case NeedLayerEnum.TRANSCENDENCE:
      return "TRANSCENDENCE";
    case NeedLayerEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Background {
  id: string;
  name: string;
  faction: GenerationInstruction[];
  disease: GenerationInstruction[];
  addiction: GenerationInstruction[];
  profession: GenerationInstruction[];
  race: GenerationInstruction[];
  religion: GenerationInstruction[];
  personality: GenerationInstruction[];
  items: GenerationInstruction[];
  pastExpChild: GenerationInstruction[];
  pastExpAdult: GenerationInstruction[];
  memoryPools: GenerationInstruction[];
  skillSets: string[];
  skillAdjustments: { [key: string]: number };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
}

export interface Background_SkillAdjustmentsEntry {
  key: string;
  value: number;
}

export interface Effect {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  tags: Tag | undefined;
  type: EffectType;
  target: EffectTarget;
  mode: EffectMode;
  element: EffectElement;
}

export interface Effect_MetadataEntry {
  key: string;
  value: string;
}

export interface Resistance {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  effectType: EffectType;
  targetEffect: EffectTarget;
}

export interface Resistance_MetadataEntry {
  key: string;
  value: string;
}

export interface Status {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  type: EffectType;
  effects: string[];
  duration: number;
}

export interface Status_MetadataEntry {
  key: string;
  value: string;
}

export interface ItemSet {
  id: string;
  blueprintId: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  set: GenerationInstruction | undefined;
}

export interface ItemSet_MetadataEntry {
  key: string;
  value: string;
}

export interface Item {
  blueprintId: string;
  metadata: { [key: string]: string };
  targetEntity: string;
  id: string;
  name: string;
  description: string;
  size: number[];
  quantity?: number | undefined;
  maxQuantity?: number | undefined;
  baseValue?: number | undefined;
  actions: string[];
  requirements?: ItemRequirements | undefined;
  stackable?: boolean | undefined;
  repairable?: boolean | undefined;
  drinkable?: boolean | undefined;
  edible?: boolean | undefined;
  gridPosition: GridPosition | undefined;
  durability?: number | undefined;
  maxDurability?: number | undefined;
  damagePierce?: string | undefined;
  armorClass?: number | undefined;
  stealthDisadvantage?: boolean | undefined;
  damageSlash?: string | undefined;
  damageBlunt?: string | undefined;
  range?: number | undefined;
  twoHanded?: boolean | undefined;
  nutrition?: number | undefined;
  spoilage?: number | undefined;
  thirstQuenched?: number | undefined;
  type?: string | undefined;
  storageSlot: StorageSlot | undefined;
  storageSlots: StorageSlot[];
  equipmentSlot: EquipmentSlot | undefined;
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  trainedSkill?: string | undefined;
  storageSlotDefinition: StorageSlotDefinition[];
  weight?: number | undefined;
}

export interface Item_MetadataEntry {
  key: string;
  value: string;
}

export interface StorageSlot {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  grid: number[];
  gridState: StorageGrid | undefined;
  maxWeight: number;
  parentItem: Item | undefined;
  storedItems: Item[];
}

export interface StorageSlot_MetadataEntry {
  key: string;
  value: string;
}

export interface StorageGrid {
  rows: StorageGridRow[];
}

export interface StorageGridRow {
  row: string[];
}

export interface ItemRequirements {
  key: string;
  value: { [key: string]: number };
}

export interface ItemRequirements_ValueEntry {
  key: string;
  value: number;
}

export interface Character {
  id: string;
  blueprintId: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  firstName: string;
  lastName: string;
  race: Race | undefined;
  gender: string;
  birthsign: Birthsign | undefined;
  birthYear: number;
  birthMonth: number;
  birthDay: number;
  skills: { [key: string]: number };
  equipmentSlots: EquipmentSlot[];
  professions: CharacterProfession[];
  memoryPools: MemoryPool[];
  characterMemories: CharacterMemory[];
  enneagramType: string;
  traits: Trait[];
  diseases: Disease[];
  addictions: Addiction[];
  factions: Faction[];
}

export interface Character_MetadataEntry {
  key: string;
  value: string;
}

export interface Character_SkillsEntry {
  key: string;
  value: number;
}

export interface Addiction {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  character: Character | undefined;
  characters: Character[];
}

export interface Addiction_MetadataEntry {
  key: string;
  value: string;
}

export interface CharacterMemory {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  character: Character | undefined;
  factStatus: { [key: string]: FactStatus };
  importance: number;
  resistance: number;
  accumulator: number;
  acquiredAt: number;
  lastUpdatedAt: number;
  tags: Tag | undefined;
}

export interface CharacterMemory_MetadataEntry {
  key: string;
  value: string;
}

export interface CharacterMemory_FactStatusEntry {
  key: string;
  value: FactStatus | undefined;
}

export interface FactStatus {
  factId: string;
  status: FactStatusEnum;
}

export interface Tag {
  id: string;
  blueprintId: string;
  metadata: { [key: string]: string };
  label: string;
  subtype: TagSubtypeEnum;
  items: Item | undefined;
  pastExperiences: PastExperience[];
  characterMemories: CharacterMemory[];
  memories: Memory[];
  memoryPools: MemoryPool[];
  skills: Skill[];
  traits: Trait[];
  characters: Character[];
  characterProfessions: CharacterProfession[];
  diseases: Disease[];
  effects: Effect[];
  facts: Fact[];
  factions: Faction[];
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
}

export interface Tag_MetadataEntry {
  key: string;
  value: string;
}

export interface Skill {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  tags: Tag | undefined;
  description: string;
  category: SkillCategoryEnum;
}

export interface Skill_MetadataEntry {
  key: string;
  value: string;
}

export interface Trait {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  tags: Tag | undefined;
}

export interface Trait_MetadataEntry {
  key: string;
  value: string;
}

export interface Disease {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  tags: Tag | undefined;
  description: string;
  severity: string;
  effects: string[];
  characters: Character[];
}

export interface Disease_MetadataEntry {
  key: string;
  value: string;
}

export interface Fact {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  tags: Tag | undefined;
  description: string;
  weight: number;
  memories: Memory[];
  characters: Character[];
}

export interface Fact_MetadataEntry {
  key: string;
  value: string;
}

export interface Faction {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  tags: Tag | undefined;
  characters: Character[];
}

export interface Faction_MetadataEntry {
  key: string;
  value: string;
}

export interface MemoryPool {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  description: string;
  memoryPoolEntries: MemoryPoolEntry | undefined;
  characterProfessions: CharacterProfession | undefined;
  tags: Tag | undefined;
}

export interface MemoryPool_MetadataEntry {
  key: string;
  value: string;
}

export interface MemoryPoolEntry {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  memoryPool: MemoryPool | undefined;
  memory: Memory | undefined;
  probability: number;
  defaultClarity: number;
  defaultImportance: number;
}

export interface MemoryPoolEntry_MetadataEntry {
  key: string;
  value: string;
}

export interface CharacterProfession {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  character: Character | undefined;
}

export interface CharacterProfession_MetadataEntry {
  key: string;
  value: string;
}

export interface EquipmentSlot {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  allowedEntities: string[];
  equippedItem: Item | undefined;
  character: Character | undefined;
}

export interface EquipmentSlot_MetadataEntry {
  key: string;
  value: string;
}

export interface Birthsign {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
}

export interface Birthsign_MetadataEntry {
  key: string;
  value: string;
}

export interface Race {
  id: string;
  blueprintId: string;
  name: string;
  equipmentSlotDefinitions: EquipmentSlotDefinition[];
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  metadata: { [key: string]: string };
}

export interface Race_MetadataEntry {
  key: string;
  value: string;
}

export interface EquipmentSlotDefinition {
  name: string;
  allowedEntities: string[];
}

export interface StorageSlotDefinition {
  grid: number[];
  name: string;
  maxWeight: number;
}

export interface Mood {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  description: string;
}

export interface Mood_MetadataEntry {
  key: string;
  value: string;
}

export interface Religion {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  description: string;
  rituals: ReligionRitual[];
  tenets: ReligionTenet[];
}

export interface Religion_MetadataEntry {
  key: string;
  value: string;
}

export interface ReligionRitual {
  name: string;
  description: string;
}

export interface ReligionTenet {
  name: string;
  description: string;
}

export interface GridPosition {
  x: number;
  y: number;
}

export interface GenerationInstruction {
  blueprintId?: string | undefined;
  idsAndQuant?: IdAndQuant | undefined;
  simpleProb?: SimpleProb | undefined;
  gaussianProb?: GaussianProb | undefined;
  combinator?: Combinator | undefined;
}

export interface IdAndQuant {
  idAndQuant: { [key: string]: number };
}

export interface IdAndQuant_IdAndQuantEntry {
  key: string;
  value: number;
}

export interface CharacterGenInstruction {
  blueprintId: string;
  backgroundBlueprintId: string;
  targetEntity: string;
  firstName?: string | undefined;
  lastName?: string | undefined;
  gender?: string | undefined;
  birthEra?: string | undefined;
  birthYear?: string | undefined;
  birthMonth?: string | undefined;
  birthDay?: string | undefined;
  backgroundCustomization: BackgroundCustomization | undefined;
}

export interface CharacterGroupGenInstruction {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  set: Combinator | undefined;
}

export interface CharacterGroupGenInstruction_MetadataEntry {
  key: string;
  value: string;
}

export interface BackgroundCustomization {
  race: GenerationInstruction[];
  faction: GenerationInstruction[];
  disease: GenerationInstruction[];
  addiction: GenerationInstruction[];
  profession: GenerationInstruction[];
  religion: GenerationInstruction[];
  itemSets: GenerationInstruction[];
  items: GenerationInstruction[];
  pastExpChild: GenerationInstruction[];
  pastExpAdult: GenerationInstruction[];
  skillSets: GenerationInstruction[];
  skillAdjustments: { [key: string]: number };
  personality: GenerationInstruction[];
}

export interface BackgroundCustomization_SkillAdjustmentsEntry {
  key: string;
  value: number;
}

export interface SimpleProb {
  cond: ConditionEnum;
  prob: { [key: string]: number };
  clazz: string;
}

export interface SimpleProb_ProbEntry {
  key: string;
  value: number;
}

export interface GaussianProb {
  blueprintId: string;
  prob: number;
  avgQuan?: number | undefined;
  stDev?: number | undefined;
  skew?: number | undefined;
  clazz: string;
}

export interface Combinator {
  name?: string | undefined;
  cond: ConditionEnum;
  /** prob must be a float value between 0 and 1 inclusive */
  prob: number;
  instructions: GenerationInstruction[];
  clazz: string;
}

export interface PastExperience {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  tags: Tag[];
  type: string;
}

export interface PastExperience_MetadataEntry {
  key: string;
  value: string;
}

export interface Memory {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  tags: Tag[];
  facts: Fact[];
  type: MemoryTypeEnum;
  description: string;
}

export interface Memory_MetadataEntry {
  key: string;
  value: string;
}

export interface PersonalityProfile {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  enneagramType: string;
  traits: GenerationInstruction[];
}

export interface PersonalityProfile_MetadataEntry {
  key: string;
  value: string;
}

export interface Need {
  id: string;
  blueprintId: string;
  name: string;
  metadata: { [key: string]: string };
  user: User | undefined;
  campaign: Campaign | undefined;
  world: World | undefined;
  description: string;
  type: NeedTypeEnum;
  layer: NeedLayerEnum;
}

export interface Need_MetadataEntry {
  key: string;
  value: string;
}

export interface User {
  id: string;
  name: string;
  /** relations */
  worlds: World[];
  campaigns: Campaign[];
  items: Item[];
  pastExperiences: PastExperience[];
  characterMemories: CharacterMemory[];
  memories: Memory[];
  memoryPools: MemoryPool[];
  memoryPoolEntries: MemoryPoolEntry[];
  skills: Skill[];
  traits: Trait[];
  addictions: Addiction[];
  birthsigns: Birthsign[];
  characters: Character[];
  characterProfessions: CharacterProfession[];
  diseases: Disease[];
  effects: Effect[];
  facts: Fact[];
  factions: Faction[];
  storageSlots: StorageSlot[];
  equipmentSlots: EquipmentSlot[];
  itemSets: ItemSet[];
  moods: Mood[];
  needs: Need[];
  personalityProfiles: PersonalityProfile[];
  races: Race[];
  religions: Religion[];
  resistances: Resistance[];
  statuses: Status[];
  tags: Tag[];
  backgrounds: Background[];
}

export interface World {
  id: string;
  name: string;
  description: string;
  settings: { [key: string]: string };
  frozen: boolean;
  /** relations */
  user: User | undefined;
  campaigns: Campaign[];
  items: Item[];
  pastExperiences: PastExperience[];
  characterMemories: CharacterMemory[];
  memories: Memory[];
  memoryPools: MemoryPool[];
  memoryPoolEntries: MemoryPoolEntry[];
  skills: Skill[];
  traits: Trait[];
  addictions: Addiction[];
  birthsigns: Birthsign[];
  characters: Character[];
  characterProfessions: CharacterProfession[];
  diseases: Disease[];
  effects: Effect[];
  facts: Fact[];
  factions: Faction[];
  storageSlots: StorageSlot[];
  equipmentSlots: EquipmentSlot[];
  itemSets: ItemSet[];
  moods: Mood[];
  needs: Need[];
  personalityProfiles: PersonalityProfile[];
  races: Race[];
  religions: Religion[];
  resistances: Resistance[];
  statuses: Status[];
  tags: Tag[];
  backgrounds: Background[];
}

export interface World_SettingsEntry {
  key: string;
  value: string;
}

export interface Campaign {
  id: string;
  name: string;
  description: string;
  dynamicState: { [key: string]: string };
  createdAt: string;
  world: World | undefined;
  user:
    | User
    | undefined;
  /** relations */
  items: Item[];
  pastExperiences: PastExperience[];
  characterMemories: CharacterMemory[];
  memories: Memory[];
  memoryPools: MemoryPool[];
  memoryPoolEntries: MemoryPoolEntry[];
  skills: Skill[];
  traits: Trait[];
  addictions: Addiction[];
  birthsigns: Birthsign[];
  characters: Character[];
  characterProfessions: CharacterProfession[];
  diseases: Disease[];
  effects: Effect[];
  facts: Fact[];
  factions: Faction[];
  storageSlots: StorageSlot[];
  equipmentSlots: EquipmentSlot[];
  itemSets: ItemSet[];
  moods: Mood[];
  needs: Need[];
  personalityProfiles: PersonalityProfile[];
  races: Race[];
  religions: Religion[];
  resistances: Resistance[];
  statuses: Status[];
  tags: Tag[];
  backgrounds: Background[];
}

export interface Campaign_DynamicStateEntry {
  key: string;
  value: string;
}

function createBaseBackground(): Background {
  return {
    id: "",
    name: "",
    faction: [],
    disease: [],
    addiction: [],
    profession: [],
    race: [],
    religion: [],
    personality: [],
    items: [],
    pastExpChild: [],
    pastExpAdult: [],
    memoryPools: [],
    skillSets: [],
    skillAdjustments: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
  };
}

export const Background: MessageFns<Background> = {
  encode(message: Background, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.faction) {
      GenerationInstruction.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.disease) {
      GenerationInstruction.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.addiction) {
      GenerationInstruction.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.profession) {
      GenerationInstruction.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.race) {
      GenerationInstruction.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.religion) {
      GenerationInstruction.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.personality) {
      GenerationInstruction.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.items) {
      GenerationInstruction.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.pastExpChild) {
      GenerationInstruction.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.pastExpAdult) {
      GenerationInstruction.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.memoryPools) {
      GenerationInstruction.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.skillSets) {
      writer.uint32(114).string(v!);
    }
    Object.entries(message.skillAdjustments).forEach(([key, value]) => {
      Background_SkillAdjustmentsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(130).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(138).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(146).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Background {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackground();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.faction.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.disease.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addiction.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.profession.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.race.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.religion.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.personality.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.items.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.pastExpChild.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.pastExpAdult.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.memoryPools.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.skillSets.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = Background_SkillAdjustmentsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.skillAdjustments[entry15.key] = entry15.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Background {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      faction: globalThis.Array.isArray(object?.faction)
        ? object.faction.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      disease: globalThis.Array.isArray(object?.disease)
        ? object.disease.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      addiction: globalThis.Array.isArray(object?.addiction)
        ? object.addiction.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      profession: globalThis.Array.isArray(object?.profession)
        ? object.profession.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      race: globalThis.Array.isArray(object?.race)
        ? object.race.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      religion: globalThis.Array.isArray(object?.religion)
        ? object.religion.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      personality: globalThis.Array.isArray(object?.personality)
        ? object.personality.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      pastExpChild: globalThis.Array.isArray(object?.pastExpChild)
        ? object.pastExpChild.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      pastExpAdult: globalThis.Array.isArray(object?.pastExpAdult)
        ? object.pastExpAdult.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      memoryPools: globalThis.Array.isArray(object?.memoryPools)
        ? object.memoryPools.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      skillSets: globalThis.Array.isArray(object?.skillSets)
        ? object.skillSets.map((e: any) => globalThis.String(e))
        : [],
      skillAdjustments: isObject(object.skillAdjustments)
        ? Object.entries(object.skillAdjustments).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
    };
  },

  toJSON(message: Background): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.faction?.length) {
      obj.faction = message.faction.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.disease?.length) {
      obj.disease = message.disease.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.addiction?.length) {
      obj.addiction = message.addiction.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.profession?.length) {
      obj.profession = message.profession.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.race?.length) {
      obj.race = message.race.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.religion?.length) {
      obj.religion = message.religion.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.personality?.length) {
      obj.personality = message.personality.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.pastExpChild?.length) {
      obj.pastExpChild = message.pastExpChild.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.pastExpAdult?.length) {
      obj.pastExpAdult = message.pastExpAdult.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.memoryPools?.length) {
      obj.memoryPools = message.memoryPools.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.skillSets?.length) {
      obj.skillSets = message.skillSets;
    }
    if (message.skillAdjustments) {
      const entries = Object.entries(message.skillAdjustments);
      if (entries.length > 0) {
        obj.skillAdjustments = {};
        entries.forEach(([k, v]) => {
          obj.skillAdjustments[k] = Math.round(v);
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Background>, I>>(base?: I): Background {
    return Background.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Background>, I>>(object: I): Background {
    const message = createBaseBackground();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.faction = object.faction?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.disease = object.disease?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.addiction = object.addiction?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.profession = object.profession?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.race = object.race?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.religion = object.religion?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.personality = object.personality?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.items = object.items?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.pastExpChild = object.pastExpChild?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.pastExpAdult = object.pastExpAdult?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.memoryPools = object.memoryPools?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.skillSets = object.skillSets?.map((e) => e) || [];
    message.skillAdjustments = Object.entries(object.skillAdjustments ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    return message;
  },
};

function createBaseBackground_SkillAdjustmentsEntry(): Background_SkillAdjustmentsEntry {
  return { key: "", value: 0 };
}

export const Background_SkillAdjustmentsEntry: MessageFns<Background_SkillAdjustmentsEntry> = {
  encode(message: Background_SkillAdjustmentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Background_SkillAdjustmentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackground_SkillAdjustmentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Background_SkillAdjustmentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Background_SkillAdjustmentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Background_SkillAdjustmentsEntry>, I>>(
    base?: I,
  ): Background_SkillAdjustmentsEntry {
    return Background_SkillAdjustmentsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Background_SkillAdjustmentsEntry>, I>>(
    object: I,
  ): Background_SkillAdjustmentsEntry {
    const message = createBaseBackground_SkillAdjustmentsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseEffect(): Effect {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    type: 0,
    target: 0,
    mode: 0,
    element: 0,
  };
}

export const Effect: MessageFns<Effect> = {
  encode(message: Effect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Effect_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      Tag.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.target !== 0) {
      writer.uint32(80).int32(message.target);
    }
    if (message.mode !== 0) {
      writer.uint32(88).int32(message.mode);
    }
    if (message.element !== 0) {
      writer.uint32(96).int32(message.element);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Effect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Effect_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = Tag.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.mode = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.element = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Effect {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? Tag.fromJSON(object.tags) : undefined,
      type: isSet(object.type) ? effectTypeFromJSON(object.type) : 0,
      target: isSet(object.target) ? effectTargetFromJSON(object.target) : 0,
      mode: isSet(object.mode) ? effectModeFromJSON(object.mode) : 0,
      element: isSet(object.element) ? effectElementFromJSON(object.element) : 0,
    };
  },

  toJSON(message: Effect): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = Tag.toJSON(message.tags);
    }
    if (message.type !== 0) {
      obj.type = effectTypeToJSON(message.type);
    }
    if (message.target !== 0) {
      obj.target = effectTargetToJSON(message.target);
    }
    if (message.mode !== 0) {
      obj.mode = effectModeToJSON(message.mode);
    }
    if (message.element !== 0) {
      obj.element = effectElementToJSON(message.element);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Effect>, I>>(base?: I): Effect {
    return Effect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Effect>, I>>(object: I): Effect {
    const message = createBaseEffect();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tag.fromPartial(object.tags) : undefined;
    message.type = object.type ?? 0;
    message.target = object.target ?? 0;
    message.mode = object.mode ?? 0;
    message.element = object.element ?? 0;
    return message;
  },
};

function createBaseEffect_MetadataEntry(): Effect_MetadataEntry {
  return { key: "", value: "" };
}

export const Effect_MetadataEntry: MessageFns<Effect_MetadataEntry> = {
  encode(message: Effect_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Effect_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEffect_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Effect_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Effect_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Effect_MetadataEntry>, I>>(base?: I): Effect_MetadataEntry {
    return Effect_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Effect_MetadataEntry>, I>>(object: I): Effect_MetadataEntry {
    const message = createBaseEffect_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseResistance(): Resistance {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    effectType: 0,
    targetEffect: 0,
  };
}

export const Resistance: MessageFns<Resistance> = {
  encode(message: Resistance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Resistance_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.effectType !== 0) {
      writer.uint32(64).int32(message.effectType);
    }
    if (message.targetEffect !== 0) {
      writer.uint32(72).int32(message.targetEffect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resistance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResistance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Resistance_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.effectType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.targetEffect = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resistance {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      effectType: isSet(object.effectType) ? effectTypeFromJSON(object.effectType) : 0,
      targetEffect: isSet(object.targetEffect) ? effectTargetFromJSON(object.targetEffect) : 0,
    };
  },

  toJSON(message: Resistance): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.effectType !== 0) {
      obj.effectType = effectTypeToJSON(message.effectType);
    }
    if (message.targetEffect !== 0) {
      obj.targetEffect = effectTargetToJSON(message.targetEffect);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resistance>, I>>(base?: I): Resistance {
    return Resistance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resistance>, I>>(object: I): Resistance {
    const message = createBaseResistance();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.effectType = object.effectType ?? 0;
    message.targetEffect = object.targetEffect ?? 0;
    return message;
  },
};

function createBaseResistance_MetadataEntry(): Resistance_MetadataEntry {
  return { key: "", value: "" };
}

export const Resistance_MetadataEntry: MessageFns<Resistance_MetadataEntry> = {
  encode(message: Resistance_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Resistance_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResistance_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Resistance_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Resistance_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Resistance_MetadataEntry>, I>>(base?: I): Resistance_MetadataEntry {
    return Resistance_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Resistance_MetadataEntry>, I>>(object: I): Resistance_MetadataEntry {
    const message = createBaseResistance_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStatus(): Status {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    type: 0,
    effects: [],
    duration: 0,
  };
}

export const Status: MessageFns<Status> = {
  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Status_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(64).int32(message.type);
    }
    for (const v of message.effects) {
      writer.uint32(74).string(v!);
    }
    if (message.duration !== 0) {
      writer.uint32(80).int32(message.duration);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Status_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.effects.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.duration = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      type: isSet(object.type) ? effectTypeFromJSON(object.type) : 0,
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => globalThis.String(e)) : [],
      duration: isSet(object.duration) ? globalThis.Number(object.duration) : 0,
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.type !== 0) {
      obj.type = effectTypeToJSON(message.type);
    }
    if (message.effects?.length) {
      obj.effects = message.effects;
    }
    if (message.duration !== 0) {
      obj.duration = Math.round(message.duration);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status>, I>>(base?: I): Status {
    return Status.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status>, I>>(object: I): Status {
    const message = createBaseStatus();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.type = object.type ?? 0;
    message.effects = object.effects?.map((e) => e) || [];
    message.duration = object.duration ?? 0;
    return message;
  },
};

function createBaseStatus_MetadataEntry(): Status_MetadataEntry {
  return { key: "", value: "" };
}

export const Status_MetadataEntry: MessageFns<Status_MetadataEntry> = {
  encode(message: Status_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Status_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Status_MetadataEntry>, I>>(base?: I): Status_MetadataEntry {
    return Status_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Status_MetadataEntry>, I>>(object: I): Status_MetadataEntry {
    const message = createBaseStatus_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseItemSet(): ItemSet {
  return {
    id: "",
    blueprintId: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    set: undefined,
  };
}

export const ItemSet: MessageFns<ItemSet> = {
  encode(message: ItemSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ItemSet_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(34).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(42).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(50).fork()).join();
    }
    if (message.set !== undefined) {
      GenerationInstruction.encode(message.set, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ItemSet_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.set = GenerationInstruction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemSet {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      set: isSet(object.set) ? GenerationInstruction.fromJSON(object.set) : undefined,
    };
  },

  toJSON(message: ItemSet): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.set !== undefined) {
      obj.set = GenerationInstruction.toJSON(message.set);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemSet>, I>>(base?: I): ItemSet {
    return ItemSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemSet>, I>>(object: I): ItemSet {
    const message = createBaseItemSet();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.set = (object.set !== undefined && object.set !== null)
      ? GenerationInstruction.fromPartial(object.set)
      : undefined;
    return message;
  },
};

function createBaseItemSet_MetadataEntry(): ItemSet_MetadataEntry {
  return { key: "", value: "" };
}

export const ItemSet_MetadataEntry: MessageFns<ItemSet_MetadataEntry> = {
  encode(message: ItemSet_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemSet_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemSet_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemSet_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ItemSet_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemSet_MetadataEntry>, I>>(base?: I): ItemSet_MetadataEntry {
    return ItemSet_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemSet_MetadataEntry>, I>>(object: I): ItemSet_MetadataEntry {
    const message = createBaseItemSet_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseItem(): Item {
  return {
    blueprintId: "",
    metadata: {},
    targetEntity: "",
    id: "",
    name: "",
    description: "",
    size: [],
    quantity: undefined,
    maxQuantity: undefined,
    baseValue: undefined,
    actions: [],
    requirements: undefined,
    stackable: undefined,
    repairable: undefined,
    drinkable: undefined,
    edible: undefined,
    gridPosition: undefined,
    durability: undefined,
    maxDurability: undefined,
    damagePierce: undefined,
    armorClass: undefined,
    stealthDisadvantage: undefined,
    damageSlash: undefined,
    damageBlunt: undefined,
    range: undefined,
    twoHanded: undefined,
    nutrition: undefined,
    spoilage: undefined,
    thirstQuenched: undefined,
    type: undefined,
    storageSlot: undefined,
    storageSlots: [],
    equipmentSlot: undefined,
    user: undefined,
    campaign: undefined,
    world: undefined,
    trainedSkill: undefined,
    storageSlotDefinition: [],
    weight: undefined,
  };
}

export const Item: MessageFns<Item> = {
  encode(message: Item, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Item_MetadataEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.targetEntity !== "") {
      writer.uint32(26).string(message.targetEntity);
    }
    if (message.id !== "") {
      writer.uint32(34).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    writer.uint32(58).fork();
    for (const v of message.size) {
      writer.int32(v);
    }
    writer.join();
    if (message.quantity !== undefined) {
      writer.uint32(64).int32(message.quantity);
    }
    if (message.maxQuantity !== undefined) {
      writer.uint32(72).int32(message.maxQuantity);
    }
    if (message.baseValue !== undefined) {
      writer.uint32(80).int32(message.baseValue);
    }
    for (const v of message.actions) {
      writer.uint32(90).string(v!);
    }
    if (message.requirements !== undefined) {
      ItemRequirements.encode(message.requirements, writer.uint32(98).fork()).join();
    }
    if (message.stackable !== undefined) {
      writer.uint32(104).bool(message.stackable);
    }
    if (message.repairable !== undefined) {
      writer.uint32(112).bool(message.repairable);
    }
    if (message.drinkable !== undefined) {
      writer.uint32(120).bool(message.drinkable);
    }
    if (message.edible !== undefined) {
      writer.uint32(128).bool(message.edible);
    }
    if (message.gridPosition !== undefined) {
      GridPosition.encode(message.gridPosition, writer.uint32(138).fork()).join();
    }
    if (message.durability !== undefined) {
      writer.uint32(144).int32(message.durability);
    }
    if (message.maxDurability !== undefined) {
      writer.uint32(152).int32(message.maxDurability);
    }
    if (message.damagePierce !== undefined) {
      writer.uint32(162).string(message.damagePierce);
    }
    if (message.armorClass !== undefined) {
      writer.uint32(168).int32(message.armorClass);
    }
    if (message.stealthDisadvantage !== undefined) {
      writer.uint32(176).bool(message.stealthDisadvantage);
    }
    if (message.damageSlash !== undefined) {
      writer.uint32(186).string(message.damageSlash);
    }
    if (message.damageBlunt !== undefined) {
      writer.uint32(194).string(message.damageBlunt);
    }
    if (message.range !== undefined) {
      writer.uint32(200).int32(message.range);
    }
    if (message.twoHanded !== undefined) {
      writer.uint32(208).bool(message.twoHanded);
    }
    if (message.nutrition !== undefined) {
      writer.uint32(216).int32(message.nutrition);
    }
    if (message.spoilage !== undefined) {
      writer.uint32(224).int32(message.spoilage);
    }
    if (message.thirstQuenched !== undefined) {
      writer.uint32(232).int32(message.thirstQuenched);
    }
    if (message.type !== undefined) {
      writer.uint32(242).string(message.type);
    }
    if (message.storageSlot !== undefined) {
      StorageSlot.encode(message.storageSlot, writer.uint32(250).fork()).join();
    }
    for (const v of message.storageSlots) {
      StorageSlot.encode(v!, writer.uint32(258).fork()).join();
    }
    if (message.equipmentSlot !== undefined) {
      EquipmentSlot.encode(message.equipmentSlot, writer.uint32(266).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(274).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(282).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(290).fork()).join();
    }
    if (message.trainedSkill !== undefined) {
      writer.uint32(298).string(message.trainedSkill);
    }
    for (const v of message.storageSlotDefinition) {
      StorageSlotDefinition.encode(v!, writer.uint32(306).fork()).join();
    }
    if (message.weight !== undefined) {
      writer.uint32(317).float(message.weight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Item {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Item_MetadataEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.metadata[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag === 56) {
            message.size.push(reader.int32());

            continue;
          }

          if (tag === 58) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.size.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxQuantity = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.baseValue = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.requirements = ItemRequirements.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.stackable = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.repairable = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.drinkable = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.edible = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.gridPosition = GridPosition.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.durability = reader.int32();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.maxDurability = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.damagePierce = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.armorClass = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.stealthDisadvantage = reader.bool();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.damageSlash = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.damageBlunt = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }

          message.range = reader.int32();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }

          message.twoHanded = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.nutrition = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.spoilage = reader.int32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.thirstQuenched = reader.int32();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.storageSlot = StorageSlot.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.storageSlots.push(StorageSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.equipmentSlot = EquipmentSlot.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 37: {
          if (tag !== 298) {
            break;
          }

          message.trainedSkill = reader.string();
          continue;
        }
        case 38: {
          if (tag !== 306) {
            break;
          }

          message.storageSlotDefinition.push(StorageSlotDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 39: {
          if (tag !== 317) {
            break;
          }

          message.weight = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Item {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      size: globalThis.Array.isArray(object?.size) ? object.size.map((e: any) => globalThis.Number(e)) : [],
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : undefined,
      maxQuantity: isSet(object.maxQuantity) ? globalThis.Number(object.maxQuantity) : undefined,
      baseValue: isSet(object.baseValue) ? globalThis.Number(object.baseValue) : undefined,
      actions: globalThis.Array.isArray(object?.actions) ? object.actions.map((e: any) => globalThis.String(e)) : [],
      requirements: isSet(object.requirements) ? ItemRequirements.fromJSON(object.requirements) : undefined,
      stackable: isSet(object.stackable) ? globalThis.Boolean(object.stackable) : undefined,
      repairable: isSet(object.repairable) ? globalThis.Boolean(object.repairable) : undefined,
      drinkable: isSet(object.drinkable) ? globalThis.Boolean(object.drinkable) : undefined,
      edible: isSet(object.edible) ? globalThis.Boolean(object.edible) : undefined,
      gridPosition: isSet(object.gridPosition) ? GridPosition.fromJSON(object.gridPosition) : undefined,
      durability: isSet(object.durability) ? globalThis.Number(object.durability) : undefined,
      maxDurability: isSet(object.maxDurability) ? globalThis.Number(object.maxDurability) : undefined,
      damagePierce: isSet(object.damagePierce) ? globalThis.String(object.damagePierce) : undefined,
      armorClass: isSet(object.armorClass) ? globalThis.Number(object.armorClass) : undefined,
      stealthDisadvantage: isSet(object.stealthDisadvantage)
        ? globalThis.Boolean(object.stealthDisadvantage)
        : undefined,
      damageSlash: isSet(object.damageSlash) ? globalThis.String(object.damageSlash) : undefined,
      damageBlunt: isSet(object.damageBlunt) ? globalThis.String(object.damageBlunt) : undefined,
      range: isSet(object.range) ? globalThis.Number(object.range) : undefined,
      twoHanded: isSet(object.twoHanded) ? globalThis.Boolean(object.twoHanded) : undefined,
      nutrition: isSet(object.nutrition) ? globalThis.Number(object.nutrition) : undefined,
      spoilage: isSet(object.spoilage) ? globalThis.Number(object.spoilage) : undefined,
      thirstQuenched: isSet(object.thirstQuenched) ? globalThis.Number(object.thirstQuenched) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      storageSlot: isSet(object.storageSlot) ? StorageSlot.fromJSON(object.storageSlot) : undefined,
      storageSlots: globalThis.Array.isArray(object?.storageSlots)
        ? object.storageSlots.map((e: any) => StorageSlot.fromJSON(e))
        : [],
      equipmentSlot: isSet(object.equipmentSlot) ? EquipmentSlot.fromJSON(object.equipmentSlot) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      trainedSkill: isSet(object.trainedSkill) ? globalThis.String(object.trainedSkill) : undefined,
      storageSlotDefinition: globalThis.Array.isArray(object?.storageSlotDefinition)
        ? object.storageSlotDefinition.map((e: any) => StorageSlotDefinition.fromJSON(e))
        : [],
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : undefined,
    };
  },

  toJSON(message: Item): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.size?.length) {
      obj.size = message.size.map((e) => Math.round(e));
    }
    if (message.quantity !== undefined) {
      obj.quantity = Math.round(message.quantity);
    }
    if (message.maxQuantity !== undefined) {
      obj.maxQuantity = Math.round(message.maxQuantity);
    }
    if (message.baseValue !== undefined) {
      obj.baseValue = Math.round(message.baseValue);
    }
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    if (message.requirements !== undefined) {
      obj.requirements = ItemRequirements.toJSON(message.requirements);
    }
    if (message.stackable !== undefined) {
      obj.stackable = message.stackable;
    }
    if (message.repairable !== undefined) {
      obj.repairable = message.repairable;
    }
    if (message.drinkable !== undefined) {
      obj.drinkable = message.drinkable;
    }
    if (message.edible !== undefined) {
      obj.edible = message.edible;
    }
    if (message.gridPosition !== undefined) {
      obj.gridPosition = GridPosition.toJSON(message.gridPosition);
    }
    if (message.durability !== undefined) {
      obj.durability = Math.round(message.durability);
    }
    if (message.maxDurability !== undefined) {
      obj.maxDurability = Math.round(message.maxDurability);
    }
    if (message.damagePierce !== undefined) {
      obj.damagePierce = message.damagePierce;
    }
    if (message.armorClass !== undefined) {
      obj.armorClass = Math.round(message.armorClass);
    }
    if (message.stealthDisadvantage !== undefined) {
      obj.stealthDisadvantage = message.stealthDisadvantage;
    }
    if (message.damageSlash !== undefined) {
      obj.damageSlash = message.damageSlash;
    }
    if (message.damageBlunt !== undefined) {
      obj.damageBlunt = message.damageBlunt;
    }
    if (message.range !== undefined) {
      obj.range = Math.round(message.range);
    }
    if (message.twoHanded !== undefined) {
      obj.twoHanded = message.twoHanded;
    }
    if (message.nutrition !== undefined) {
      obj.nutrition = Math.round(message.nutrition);
    }
    if (message.spoilage !== undefined) {
      obj.spoilage = Math.round(message.spoilage);
    }
    if (message.thirstQuenched !== undefined) {
      obj.thirstQuenched = Math.round(message.thirstQuenched);
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.storageSlot !== undefined) {
      obj.storageSlot = StorageSlot.toJSON(message.storageSlot);
    }
    if (message.storageSlots?.length) {
      obj.storageSlots = message.storageSlots.map((e) => StorageSlot.toJSON(e));
    }
    if (message.equipmentSlot !== undefined) {
      obj.equipmentSlot = EquipmentSlot.toJSON(message.equipmentSlot);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.trainedSkill !== undefined) {
      obj.trainedSkill = message.trainedSkill;
    }
    if (message.storageSlotDefinition?.length) {
      obj.storageSlotDefinition = message.storageSlotDefinition.map((e) => StorageSlotDefinition.toJSON(e));
    }
    if (message.weight !== undefined) {
      obj.weight = message.weight;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Item>, I>>(base?: I): Item {
    return Item.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Item>, I>>(object: I): Item {
    const message = createBaseItem();
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.targetEntity = object.targetEntity ?? "";
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.size = object.size?.map((e) => e) || [];
    message.quantity = object.quantity ?? undefined;
    message.maxQuantity = object.maxQuantity ?? undefined;
    message.baseValue = object.baseValue ?? undefined;
    message.actions = object.actions?.map((e) => e) || [];
    message.requirements = (object.requirements !== undefined && object.requirements !== null)
      ? ItemRequirements.fromPartial(object.requirements)
      : undefined;
    message.stackable = object.stackable ?? undefined;
    message.repairable = object.repairable ?? undefined;
    message.drinkable = object.drinkable ?? undefined;
    message.edible = object.edible ?? undefined;
    message.gridPosition = (object.gridPosition !== undefined && object.gridPosition !== null)
      ? GridPosition.fromPartial(object.gridPosition)
      : undefined;
    message.durability = object.durability ?? undefined;
    message.maxDurability = object.maxDurability ?? undefined;
    message.damagePierce = object.damagePierce ?? undefined;
    message.armorClass = object.armorClass ?? undefined;
    message.stealthDisadvantage = object.stealthDisadvantage ?? undefined;
    message.damageSlash = object.damageSlash ?? undefined;
    message.damageBlunt = object.damageBlunt ?? undefined;
    message.range = object.range ?? undefined;
    message.twoHanded = object.twoHanded ?? undefined;
    message.nutrition = object.nutrition ?? undefined;
    message.spoilage = object.spoilage ?? undefined;
    message.thirstQuenched = object.thirstQuenched ?? undefined;
    message.type = object.type ?? undefined;
    message.storageSlot = (object.storageSlot !== undefined && object.storageSlot !== null)
      ? StorageSlot.fromPartial(object.storageSlot)
      : undefined;
    message.storageSlots = object.storageSlots?.map((e) => StorageSlot.fromPartial(e)) || [];
    message.equipmentSlot = (object.equipmentSlot !== undefined && object.equipmentSlot !== null)
      ? EquipmentSlot.fromPartial(object.equipmentSlot)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.trainedSkill = object.trainedSkill ?? undefined;
    message.storageSlotDefinition = object.storageSlotDefinition?.map((e) => StorageSlotDefinition.fromPartial(e)) ||
      [];
    message.weight = object.weight ?? undefined;
    return message;
  },
};

function createBaseItem_MetadataEntry(): Item_MetadataEntry {
  return { key: "", value: "" };
}

export const Item_MetadataEntry: MessageFns<Item_MetadataEntry> = {
  encode(message: Item_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Item_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItem_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Item_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Item_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Item_MetadataEntry>, I>>(base?: I): Item_MetadataEntry {
    return Item_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Item_MetadataEntry>, I>>(object: I): Item_MetadataEntry {
    const message = createBaseItem_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStorageSlot(): StorageSlot {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    grid: [],
    gridState: undefined,
    maxWeight: 0,
    parentItem: undefined,
    storedItems: [],
  };
}

export const StorageSlot: MessageFns<StorageSlot> = {
  encode(message: StorageSlot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      StorageSlot_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    writer.uint32(66).fork();
    for (const v of message.grid) {
      writer.int32(v);
    }
    writer.join();
    if (message.gridState !== undefined) {
      StorageGrid.encode(message.gridState, writer.uint32(74).fork()).join();
    }
    if (message.maxWeight !== 0) {
      writer.uint32(80).int32(message.maxWeight);
    }
    if (message.parentItem !== undefined) {
      Item.encode(message.parentItem, writer.uint32(90).fork()).join();
    }
    for (const v of message.storedItems) {
      Item.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = StorageSlot_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.grid.push(reader.int32());

            continue;
          }

          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.grid.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.gridState = StorageGrid.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.maxWeight = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.parentItem = Item.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.storedItems.push(Item.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlot {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      grid: globalThis.Array.isArray(object?.grid) ? object.grid.map((e: any) => globalThis.Number(e)) : [],
      gridState: isSet(object.gridState) ? StorageGrid.fromJSON(object.gridState) : undefined,
      maxWeight: isSet(object.maxWeight) ? globalThis.Number(object.maxWeight) : 0,
      parentItem: isSet(object.parentItem) ? Item.fromJSON(object.parentItem) : undefined,
      storedItems: globalThis.Array.isArray(object?.storedItems)
        ? object.storedItems.map((e: any) => Item.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StorageSlot): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.grid?.length) {
      obj.grid = message.grid.map((e) => Math.round(e));
    }
    if (message.gridState !== undefined) {
      obj.gridState = StorageGrid.toJSON(message.gridState);
    }
    if (message.maxWeight !== 0) {
      obj.maxWeight = Math.round(message.maxWeight);
    }
    if (message.parentItem !== undefined) {
      obj.parentItem = Item.toJSON(message.parentItem);
    }
    if (message.storedItems?.length) {
      obj.storedItems = message.storedItems.map((e) => Item.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlot>, I>>(base?: I): StorageSlot {
    return StorageSlot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlot>, I>>(object: I): StorageSlot {
    const message = createBaseStorageSlot();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.grid = object.grid?.map((e) => e) || [];
    message.gridState = (object.gridState !== undefined && object.gridState !== null)
      ? StorageGrid.fromPartial(object.gridState)
      : undefined;
    message.maxWeight = object.maxWeight ?? 0;
    message.parentItem = (object.parentItem !== undefined && object.parentItem !== null)
      ? Item.fromPartial(object.parentItem)
      : undefined;
    message.storedItems = object.storedItems?.map((e) => Item.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorageSlot_MetadataEntry(): StorageSlot_MetadataEntry {
  return { key: "", value: "" };
}

export const StorageSlot_MetadataEntry: MessageFns<StorageSlot_MetadataEntry> = {
  encode(message: StorageSlot_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlot_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlot_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlot_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: StorageSlot_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlot_MetadataEntry>, I>>(base?: I): StorageSlot_MetadataEntry {
    return StorageSlot_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlot_MetadataEntry>, I>>(object: I): StorageSlot_MetadataEntry {
    const message = createBaseStorageSlot_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseStorageGrid(): StorageGrid {
  return { rows: [] };
}

export const StorageGrid: MessageFns<StorageGrid> = {
  encode(message: StorageGrid, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rows) {
      StorageGridRow.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageGrid {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageGrid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rows.push(StorageGridRow.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageGrid {
    return {
      rows: globalThis.Array.isArray(object?.rows) ? object.rows.map((e: any) => StorageGridRow.fromJSON(e)) : [],
    };
  },

  toJSON(message: StorageGrid): unknown {
    const obj: any = {};
    if (message.rows?.length) {
      obj.rows = message.rows.map((e) => StorageGridRow.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageGrid>, I>>(base?: I): StorageGrid {
    return StorageGrid.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageGrid>, I>>(object: I): StorageGrid {
    const message = createBaseStorageGrid();
    message.rows = object.rows?.map((e) => StorageGridRow.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStorageGridRow(): StorageGridRow {
  return { row: [] };
}

export const StorageGridRow: MessageFns<StorageGridRow> = {
  encode(message: StorageGridRow, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.row) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageGridRow {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageGridRow();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.row.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageGridRow {
    return { row: globalThis.Array.isArray(object?.row) ? object.row.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: StorageGridRow): unknown {
    const obj: any = {};
    if (message.row?.length) {
      obj.row = message.row;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageGridRow>, I>>(base?: I): StorageGridRow {
    return StorageGridRow.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageGridRow>, I>>(object: I): StorageGridRow {
    const message = createBaseStorageGridRow();
    message.row = object.row?.map((e) => e) || [];
    return message;
  },
};

function createBaseItemRequirements(): ItemRequirements {
  return { key: "", value: {} };
}

export const ItemRequirements: MessageFns<ItemRequirements> = {
  encode(message: ItemRequirements, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    Object.entries(message.value).forEach(([key, value]) => {
      ItemRequirements_ValueEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemRequirements {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemRequirements();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ItemRequirements_ValueEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.value[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemRequirements {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isObject(object.value)
        ? Object.entries(object.value).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ItemRequirements): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value) {
      const entries = Object.entries(message.value);
      if (entries.length > 0) {
        obj.value = {};
        entries.forEach(([k, v]) => {
          obj.value[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemRequirements>, I>>(base?: I): ItemRequirements {
    return ItemRequirements.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemRequirements>, I>>(object: I): ItemRequirements {
    const message = createBaseItemRequirements();
    message.key = object.key ?? "";
    message.value = Object.entries(object.value ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseItemRequirements_ValueEntry(): ItemRequirements_ValueEntry {
  return { key: "", value: 0 };
}

export const ItemRequirements_ValueEntry: MessageFns<ItemRequirements_ValueEntry> = {
  encode(message: ItemRequirements_ValueEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemRequirements_ValueEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemRequirements_ValueEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ItemRequirements_ValueEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ItemRequirements_ValueEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ItemRequirements_ValueEntry>, I>>(base?: I): ItemRequirements_ValueEntry {
    return ItemRequirements_ValueEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ItemRequirements_ValueEntry>, I>>(object: I): ItemRequirements_ValueEntry {
    const message = createBaseItemRequirements_ValueEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCharacter(): Character {
  return {
    id: "",
    blueprintId: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    firstName: "",
    lastName: "",
    race: undefined,
    gender: "",
    birthsign: undefined,
    birthYear: 0,
    birthMonth: 0,
    birthDay: 0,
    skills: {},
    equipmentSlots: [],
    professions: [],
    memoryPools: [],
    characterMemories: [],
    enneagramType: "",
    traits: [],
    diseases: [],
    addictions: [],
    factions: [],
  };
}

export const Character: MessageFns<Character> = {
  encode(message: Character, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Character_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(34).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(42).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(50).fork()).join();
    }
    if (message.firstName !== "") {
      writer.uint32(58).string(message.firstName);
    }
    if (message.lastName !== "") {
      writer.uint32(66).string(message.lastName);
    }
    if (message.race !== undefined) {
      Race.encode(message.race, writer.uint32(74).fork()).join();
    }
    if (message.gender !== "") {
      writer.uint32(82).string(message.gender);
    }
    if (message.birthsign !== undefined) {
      Birthsign.encode(message.birthsign, writer.uint32(90).fork()).join();
    }
    if (message.birthYear !== 0) {
      writer.uint32(96).int32(message.birthYear);
    }
    if (message.birthMonth !== 0) {
      writer.uint32(104).int32(message.birthMonth);
    }
    if (message.birthDay !== 0) {
      writer.uint32(112).int32(message.birthDay);
    }
    Object.entries(message.skills).forEach(([key, value]) => {
      Character_SkillsEntry.encode({ key: key as any, value }, writer.uint32(122).fork()).join();
    });
    for (const v of message.equipmentSlots) {
      EquipmentSlot.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.professions) {
      CharacterProfession.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.memoryPools) {
      MemoryPool.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.characterMemories) {
      CharacterMemory.encode(v!, writer.uint32(154).fork()).join();
    }
    if (message.enneagramType !== "") {
      writer.uint32(162).string(message.enneagramType);
    }
    for (const v of message.traits) {
      Trait.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.diseases) {
      Disease.encode(v!, writer.uint32(178).fork()).join();
    }
    for (const v of message.addictions) {
      Addiction.encode(v!, writer.uint32(186).fork()).join();
    }
    for (const v of message.factions) {
      Faction.encode(v!, writer.uint32(194).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Character {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Character_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.race = Race.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.birthsign = Birthsign.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.birthYear = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.birthMonth = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.birthDay = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          const entry15 = Character_SkillsEntry.decode(reader, reader.uint32());
          if (entry15.value !== undefined) {
            message.skills[entry15.key] = entry15.value;
          }
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.equipmentSlots.push(EquipmentSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.professions.push(CharacterProfession.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.memoryPools.push(MemoryPool.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.characterMemories.push(CharacterMemory.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.enneagramType = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.traits.push(Trait.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.diseases.push(Disease.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.addictions.push(Addiction.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.factions.push(Faction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Character {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : "",
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : "",
      race: isSet(object.race) ? Race.fromJSON(object.race) : undefined,
      gender: isSet(object.gender) ? globalThis.String(object.gender) : "",
      birthsign: isSet(object.birthsign) ? Birthsign.fromJSON(object.birthsign) : undefined,
      birthYear: isSet(object.birthYear) ? globalThis.Number(object.birthYear) : 0,
      birthMonth: isSet(object.birthMonth) ? globalThis.Number(object.birthMonth) : 0,
      birthDay: isSet(object.birthDay) ? globalThis.Number(object.birthDay) : 0,
      skills: isObject(object.skills)
        ? Object.entries(object.skills).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      equipmentSlots: globalThis.Array.isArray(object?.equipmentSlots)
        ? object.equipmentSlots.map((e: any) => EquipmentSlot.fromJSON(e))
        : [],
      professions: globalThis.Array.isArray(object?.professions)
        ? object.professions.map((e: any) => CharacterProfession.fromJSON(e))
        : [],
      memoryPools: globalThis.Array.isArray(object?.memoryPools)
        ? object.memoryPools.map((e: any) => MemoryPool.fromJSON(e))
        : [],
      characterMemories: globalThis.Array.isArray(object?.characterMemories)
        ? object.characterMemories.map((e: any) => CharacterMemory.fromJSON(e))
        : [],
      enneagramType: isSet(object.enneagramType) ? globalThis.String(object.enneagramType) : "",
      traits: globalThis.Array.isArray(object?.traits) ? object.traits.map((e: any) => Trait.fromJSON(e)) : [],
      diseases: globalThis.Array.isArray(object?.diseases) ? object.diseases.map((e: any) => Disease.fromJSON(e)) : [],
      addictions: globalThis.Array.isArray(object?.addictions)
        ? object.addictions.map((e: any) => Addiction.fromJSON(e))
        : [],
      factions: globalThis.Array.isArray(object?.factions)
        ? object.factions.map((e: any) => Faction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Character): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.firstName !== "") {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== "") {
      obj.lastName = message.lastName;
    }
    if (message.race !== undefined) {
      obj.race = Race.toJSON(message.race);
    }
    if (message.gender !== "") {
      obj.gender = message.gender;
    }
    if (message.birthsign !== undefined) {
      obj.birthsign = Birthsign.toJSON(message.birthsign);
    }
    if (message.birthYear !== 0) {
      obj.birthYear = Math.round(message.birthYear);
    }
    if (message.birthMonth !== 0) {
      obj.birthMonth = Math.round(message.birthMonth);
    }
    if (message.birthDay !== 0) {
      obj.birthDay = Math.round(message.birthDay);
    }
    if (message.skills) {
      const entries = Object.entries(message.skills);
      if (entries.length > 0) {
        obj.skills = {};
        entries.forEach(([k, v]) => {
          obj.skills[k] = Math.round(v);
        });
      }
    }
    if (message.equipmentSlots?.length) {
      obj.equipmentSlots = message.equipmentSlots.map((e) => EquipmentSlot.toJSON(e));
    }
    if (message.professions?.length) {
      obj.professions = message.professions.map((e) => CharacterProfession.toJSON(e));
    }
    if (message.memoryPools?.length) {
      obj.memoryPools = message.memoryPools.map((e) => MemoryPool.toJSON(e));
    }
    if (message.characterMemories?.length) {
      obj.characterMemories = message.characterMemories.map((e) => CharacterMemory.toJSON(e));
    }
    if (message.enneagramType !== "") {
      obj.enneagramType = message.enneagramType;
    }
    if (message.traits?.length) {
      obj.traits = message.traits.map((e) => Trait.toJSON(e));
    }
    if (message.diseases?.length) {
      obj.diseases = message.diseases.map((e) => Disease.toJSON(e));
    }
    if (message.addictions?.length) {
      obj.addictions = message.addictions.map((e) => Addiction.toJSON(e));
    }
    if (message.factions?.length) {
      obj.factions = message.factions.map((e) => Faction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Character>, I>>(base?: I): Character {
    return Character.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Character>, I>>(object: I): Character {
    const message = createBaseCharacter();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.firstName = object.firstName ?? "";
    message.lastName = object.lastName ?? "";
    message.race = (object.race !== undefined && object.race !== null) ? Race.fromPartial(object.race) : undefined;
    message.gender = object.gender ?? "";
    message.birthsign = (object.birthsign !== undefined && object.birthsign !== null)
      ? Birthsign.fromPartial(object.birthsign)
      : undefined;
    message.birthYear = object.birthYear ?? 0;
    message.birthMonth = object.birthMonth ?? 0;
    message.birthDay = object.birthDay ?? 0;
    message.skills = Object.entries(object.skills ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.equipmentSlots = object.equipmentSlots?.map((e) => EquipmentSlot.fromPartial(e)) || [];
    message.professions = object.professions?.map((e) => CharacterProfession.fromPartial(e)) || [];
    message.memoryPools = object.memoryPools?.map((e) => MemoryPool.fromPartial(e)) || [];
    message.characterMemories = object.characterMemories?.map((e) => CharacterMemory.fromPartial(e)) || [];
    message.enneagramType = object.enneagramType ?? "";
    message.traits = object.traits?.map((e) => Trait.fromPartial(e)) || [];
    message.diseases = object.diseases?.map((e) => Disease.fromPartial(e)) || [];
    message.addictions = object.addictions?.map((e) => Addiction.fromPartial(e)) || [];
    message.factions = object.factions?.map((e) => Faction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCharacter_MetadataEntry(): Character_MetadataEntry {
  return { key: "", value: "" };
}

export const Character_MetadataEntry: MessageFns<Character_MetadataEntry> = {
  encode(message: Character_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Character_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacter_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Character_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Character_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Character_MetadataEntry>, I>>(base?: I): Character_MetadataEntry {
    return Character_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Character_MetadataEntry>, I>>(object: I): Character_MetadataEntry {
    const message = createBaseCharacter_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCharacter_SkillsEntry(): Character_SkillsEntry {
  return { key: "", value: 0 };
}

export const Character_SkillsEntry: MessageFns<Character_SkillsEntry> = {
  encode(message: Character_SkillsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Character_SkillsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacter_SkillsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Character_SkillsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Character_SkillsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Character_SkillsEntry>, I>>(base?: I): Character_SkillsEntry {
    return Character_SkillsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Character_SkillsEntry>, I>>(object: I): Character_SkillsEntry {
    const message = createBaseCharacter_SkillsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseAddiction(): Addiction {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    character: undefined,
    characters: [],
  };
}

export const Addiction: MessageFns<Addiction> = {
  encode(message: Addiction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Addiction_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.character !== undefined) {
      Character.encode(message.character, writer.uint32(66).fork()).join();
    }
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Addiction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddiction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Addiction_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.character = Character.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Addiction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      character: isSet(object.character) ? Character.fromJSON(object.character) : undefined,
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Addiction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.character !== undefined) {
      obj.character = Character.toJSON(message.character);
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Addiction>, I>>(base?: I): Addiction {
    return Addiction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Addiction>, I>>(object: I): Addiction {
    const message = createBaseAddiction();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.character = (object.character !== undefined && object.character !== null)
      ? Character.fromPartial(object.character)
      : undefined;
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddiction_MetadataEntry(): Addiction_MetadataEntry {
  return { key: "", value: "" };
}

export const Addiction_MetadataEntry: MessageFns<Addiction_MetadataEntry> = {
  encode(message: Addiction_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Addiction_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddiction_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Addiction_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Addiction_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Addiction_MetadataEntry>, I>>(base?: I): Addiction_MetadataEntry {
    return Addiction_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Addiction_MetadataEntry>, I>>(object: I): Addiction_MetadataEntry {
    const message = createBaseAddiction_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCharacterMemory(): CharacterMemory {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    character: undefined,
    factStatus: {},
    importance: 0,
    resistance: 0,
    accumulator: 0,
    acquiredAt: 0,
    lastUpdatedAt: 0,
    tags: undefined,
  };
}

export const CharacterMemory: MessageFns<CharacterMemory> = {
  encode(message: CharacterMemory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CharacterMemory_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.character !== undefined) {
      Character.encode(message.character, writer.uint32(66).fork()).join();
    }
    Object.entries(message.factStatus).forEach(([key, value]) => {
      CharacterMemory_FactStatusEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    if (message.importance !== 0) {
      writer.uint32(80).int32(message.importance);
    }
    if (message.resistance !== 0) {
      writer.uint32(88).int32(message.resistance);
    }
    if (message.accumulator !== 0) {
      writer.uint32(96).int32(message.accumulator);
    }
    if (message.acquiredAt !== 0) {
      writer.uint32(104).int32(message.acquiredAt);
    }
    if (message.lastUpdatedAt !== 0) {
      writer.uint32(112).int32(message.lastUpdatedAt);
    }
    if (message.tags !== undefined) {
      Tag.encode(message.tags, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterMemory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterMemory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CharacterMemory_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.character = Character.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = CharacterMemory_FactStatusEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.factStatus[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.importance = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.resistance = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.accumulator = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.acquiredAt = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.lastUpdatedAt = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.tags = Tag.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterMemory {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      character: isSet(object.character) ? Character.fromJSON(object.character) : undefined,
      factStatus: isObject(object.factStatus)
        ? Object.entries(object.factStatus).reduce<{ [key: string]: FactStatus }>((acc, [key, value]) => {
          acc[key] = FactStatus.fromJSON(value);
          return acc;
        }, {})
        : {},
      importance: isSet(object.importance) ? globalThis.Number(object.importance) : 0,
      resistance: isSet(object.resistance) ? globalThis.Number(object.resistance) : 0,
      accumulator: isSet(object.accumulator) ? globalThis.Number(object.accumulator) : 0,
      acquiredAt: isSet(object.acquiredAt) ? globalThis.Number(object.acquiredAt) : 0,
      lastUpdatedAt: isSet(object.lastUpdatedAt) ? globalThis.Number(object.lastUpdatedAt) : 0,
      tags: isSet(object.tags) ? Tag.fromJSON(object.tags) : undefined,
    };
  },

  toJSON(message: CharacterMemory): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.character !== undefined) {
      obj.character = Character.toJSON(message.character);
    }
    if (message.factStatus) {
      const entries = Object.entries(message.factStatus);
      if (entries.length > 0) {
        obj.factStatus = {};
        entries.forEach(([k, v]) => {
          obj.factStatus[k] = FactStatus.toJSON(v);
        });
      }
    }
    if (message.importance !== 0) {
      obj.importance = Math.round(message.importance);
    }
    if (message.resistance !== 0) {
      obj.resistance = Math.round(message.resistance);
    }
    if (message.accumulator !== 0) {
      obj.accumulator = Math.round(message.accumulator);
    }
    if (message.acquiredAt !== 0) {
      obj.acquiredAt = Math.round(message.acquiredAt);
    }
    if (message.lastUpdatedAt !== 0) {
      obj.lastUpdatedAt = Math.round(message.lastUpdatedAt);
    }
    if (message.tags !== undefined) {
      obj.tags = Tag.toJSON(message.tags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterMemory>, I>>(base?: I): CharacterMemory {
    return CharacterMemory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterMemory>, I>>(object: I): CharacterMemory {
    const message = createBaseCharacterMemory();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.character = (object.character !== undefined && object.character !== null)
      ? Character.fromPartial(object.character)
      : undefined;
    message.factStatus = Object.entries(object.factStatus ?? {}).reduce<{ [key: string]: FactStatus }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = FactStatus.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.importance = object.importance ?? 0;
    message.resistance = object.resistance ?? 0;
    message.accumulator = object.accumulator ?? 0;
    message.acquiredAt = object.acquiredAt ?? 0;
    message.lastUpdatedAt = object.lastUpdatedAt ?? 0;
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tag.fromPartial(object.tags) : undefined;
    return message;
  },
};

function createBaseCharacterMemory_MetadataEntry(): CharacterMemory_MetadataEntry {
  return { key: "", value: "" };
}

export const CharacterMemory_MetadataEntry: MessageFns<CharacterMemory_MetadataEntry> = {
  encode(message: CharacterMemory_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterMemory_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterMemory_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterMemory_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CharacterMemory_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterMemory_MetadataEntry>, I>>(base?: I): CharacterMemory_MetadataEntry {
    return CharacterMemory_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterMemory_MetadataEntry>, I>>(
    object: I,
  ): CharacterMemory_MetadataEntry {
    const message = createBaseCharacterMemory_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCharacterMemory_FactStatusEntry(): CharacterMemory_FactStatusEntry {
  return { key: "", value: undefined };
}

export const CharacterMemory_FactStatusEntry: MessageFns<CharacterMemory_FactStatusEntry> = {
  encode(message: CharacterMemory_FactStatusEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      FactStatus.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterMemory_FactStatusEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterMemory_FactStatusEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = FactStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterMemory_FactStatusEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? FactStatus.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: CharacterMemory_FactStatusEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = FactStatus.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterMemory_FactStatusEntry>, I>>(base?: I): CharacterMemory_FactStatusEntry {
    return CharacterMemory_FactStatusEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterMemory_FactStatusEntry>, I>>(
    object: I,
  ): CharacterMemory_FactStatusEntry {
    const message = createBaseCharacterMemory_FactStatusEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? FactStatus.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseFactStatus(): FactStatus {
  return { factId: "", status: 0 };
}

export const FactStatus: MessageFns<FactStatus> = {
  encode(message: FactStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.factId !== "") {
      writer.uint32(10).string(message.factId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.factId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactStatus {
    return {
      factId: isSet(object.factId) ? globalThis.String(object.factId) : "",
      status: isSet(object.status) ? factStatusEnumFromJSON(object.status) : 0,
    };
  },

  toJSON(message: FactStatus): unknown {
    const obj: any = {};
    if (message.factId !== "") {
      obj.factId = message.factId;
    }
    if (message.status !== 0) {
      obj.status = factStatusEnumToJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FactStatus>, I>>(base?: I): FactStatus {
    return FactStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FactStatus>, I>>(object: I): FactStatus {
    const message = createBaseFactStatus();
    message.factId = object.factId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseTag(): Tag {
  return {
    id: "",
    blueprintId: "",
    metadata: {},
    label: "",
    subtype: 0,
    items: undefined,
    pastExperiences: [],
    characterMemories: [],
    memories: [],
    memoryPools: [],
    skills: [],
    traits: [],
    characters: [],
    characterProfessions: [],
    diseases: [],
    effects: [],
    facts: [],
    factions: [],
    user: undefined,
    campaign: undefined,
    world: undefined,
  };
}

export const Tag: MessageFns<Tag> = {
  encode(message: Tag, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Tag_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    if (message.subtype !== 0) {
      writer.uint32(40).int32(message.subtype);
    }
    if (message.items !== undefined) {
      Item.encode(message.items, writer.uint32(50).fork()).join();
    }
    for (const v of message.pastExperiences) {
      PastExperience.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.characterMemories) {
      CharacterMemory.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.memories) {
      Memory.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.memoryPools) {
      MemoryPool.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.skills) {
      Skill.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.traits) {
      Trait.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.characterProfessions) {
      CharacterProfession.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.diseases) {
      Disease.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.effects) {
      Effect.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.facts) {
      Fact.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.factions) {
      Faction.encode(v!, writer.uint32(146).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(154).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(162).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = Tag_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.subtype = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.items = Item.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pastExperiences.push(PastExperience.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.characterMemories.push(CharacterMemory.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memories.push(Memory.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.memoryPools.push(MemoryPool.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.skills.push(Skill.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.traits.push(Trait.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.characterProfessions.push(CharacterProfession.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.diseases.push(Disease.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.facts.push(Fact.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.factions.push(Faction.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      subtype: isSet(object.subtype) ? tagSubtypeEnumFromJSON(object.subtype) : 0,
      items: isSet(object.items) ? Item.fromJSON(object.items) : undefined,
      pastExperiences: globalThis.Array.isArray(object?.pastExperiences)
        ? object.pastExperiences.map((e: any) => PastExperience.fromJSON(e))
        : [],
      characterMemories: globalThis.Array.isArray(object?.characterMemories)
        ? object.characterMemories.map((e: any) => CharacterMemory.fromJSON(e))
        : [],
      memories: globalThis.Array.isArray(object?.memories) ? object.memories.map((e: any) => Memory.fromJSON(e)) : [],
      memoryPools: globalThis.Array.isArray(object?.memoryPools)
        ? object.memoryPools.map((e: any) => MemoryPool.fromJSON(e))
        : [],
      skills: globalThis.Array.isArray(object?.skills) ? object.skills.map((e: any) => Skill.fromJSON(e)) : [],
      traits: globalThis.Array.isArray(object?.traits) ? object.traits.map((e: any) => Trait.fromJSON(e)) : [],
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
      characterProfessions: globalThis.Array.isArray(object?.characterProfessions)
        ? object.characterProfessions.map((e: any) => CharacterProfession.fromJSON(e))
        : [],
      diseases: globalThis.Array.isArray(object?.diseases)
        ? object.diseases.map((e: any) => Disease.fromJSON(e))
        : [],
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => Effect.fromJSON(e)) : [],
      facts: globalThis.Array.isArray(object?.facts) ? object.facts.map((e: any) => Fact.fromJSON(e)) : [],
      factions: globalThis.Array.isArray(object?.factions) ? object.factions.map((e: any) => Faction.fromJSON(e)) : [],
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
    };
  },

  toJSON(message: Tag): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.subtype !== 0) {
      obj.subtype = tagSubtypeEnumToJSON(message.subtype);
    }
    if (message.items !== undefined) {
      obj.items = Item.toJSON(message.items);
    }
    if (message.pastExperiences?.length) {
      obj.pastExperiences = message.pastExperiences.map((e) => PastExperience.toJSON(e));
    }
    if (message.characterMemories?.length) {
      obj.characterMemories = message.characterMemories.map((e) => CharacterMemory.toJSON(e));
    }
    if (message.memories?.length) {
      obj.memories = message.memories.map((e) => Memory.toJSON(e));
    }
    if (message.memoryPools?.length) {
      obj.memoryPools = message.memoryPools.map((e) => MemoryPool.toJSON(e));
    }
    if (message.skills?.length) {
      obj.skills = message.skills.map((e) => Skill.toJSON(e));
    }
    if (message.traits?.length) {
      obj.traits = message.traits.map((e) => Trait.toJSON(e));
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    if (message.characterProfessions?.length) {
      obj.characterProfessions = message.characterProfessions.map((e) => CharacterProfession.toJSON(e));
    }
    if (message.diseases?.length) {
      obj.diseases = message.diseases.map((e) => Disease.toJSON(e));
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    if (message.facts?.length) {
      obj.facts = message.facts.map((e) => Fact.toJSON(e));
    }
    if (message.factions?.length) {
      obj.factions = message.factions.map((e) => Faction.toJSON(e));
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tag>, I>>(base?: I): Tag {
    return Tag.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tag>, I>>(object: I): Tag {
    const message = createBaseTag();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.label = object.label ?? "";
    message.subtype = object.subtype ?? 0;
    message.items = (object.items !== undefined && object.items !== null) ? Item.fromPartial(object.items) : undefined;
    message.pastExperiences = object.pastExperiences?.map((e) => PastExperience.fromPartial(e)) || [];
    message.characterMemories = object.characterMemories?.map((e) => CharacterMemory.fromPartial(e)) || [];
    message.memories = object.memories?.map((e) => Memory.fromPartial(e)) || [];
    message.memoryPools = object.memoryPools?.map((e) => MemoryPool.fromPartial(e)) || [];
    message.skills = object.skills?.map((e) => Skill.fromPartial(e)) || [];
    message.traits = object.traits?.map((e) => Trait.fromPartial(e)) || [];
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    message.characterProfessions = object.characterProfessions?.map((e) => CharacterProfession.fromPartial(e)) || [];
    message.diseases = object.diseases?.map((e) => Disease.fromPartial(e)) || [];
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    message.facts = object.facts?.map((e) => Fact.fromPartial(e)) || [];
    message.factions = object.factions?.map((e) => Faction.fromPartial(e)) || [];
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    return message;
  },
};

function createBaseTag_MetadataEntry(): Tag_MetadataEntry {
  return { key: "", value: "" };
}

export const Tag_MetadataEntry: MessageFns<Tag_MetadataEntry> = {
  encode(message: Tag_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tag_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTag_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tag_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Tag_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tag_MetadataEntry>, I>>(base?: I): Tag_MetadataEntry {
    return Tag_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tag_MetadataEntry>, I>>(object: I): Tag_MetadataEntry {
    const message = createBaseTag_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSkill(): Skill {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    description: "",
    category: 0,
  };
}

export const Skill: MessageFns<Skill> = {
  encode(message: Skill, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Skill_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      Tag.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.category !== 0) {
      writer.uint32(80).int32(message.category);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Skill {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkill();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Skill_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = Tag.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Skill {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? Tag.fromJSON(object.tags) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      category: isSet(object.category) ? skillCategoryEnumFromJSON(object.category) : 0,
    };
  },

  toJSON(message: Skill): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = Tag.toJSON(message.tags);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.category !== 0) {
      obj.category = skillCategoryEnumToJSON(message.category);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Skill>, I>>(base?: I): Skill {
    return Skill.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Skill>, I>>(object: I): Skill {
    const message = createBaseSkill();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tag.fromPartial(object.tags) : undefined;
    message.description = object.description ?? "";
    message.category = object.category ?? 0;
    return message;
  },
};

function createBaseSkill_MetadataEntry(): Skill_MetadataEntry {
  return { key: "", value: "" };
}

export const Skill_MetadataEntry: MessageFns<Skill_MetadataEntry> = {
  encode(message: Skill_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Skill_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkill_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Skill_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Skill_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Skill_MetadataEntry>, I>>(base?: I): Skill_MetadataEntry {
    return Skill_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Skill_MetadataEntry>, I>>(object: I): Skill_MetadataEntry {
    const message = createBaseSkill_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTrait(): Trait {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
  };
}

export const Trait: MessageFns<Trait> = {
  encode(message: Trait, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Trait_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      Tag.encode(message.tags, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trait {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrait();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Trait_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = Tag.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trait {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? Tag.fromJSON(object.tags) : undefined,
    };
  },

  toJSON(message: Trait): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = Tag.toJSON(message.tags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trait>, I>>(base?: I): Trait {
    return Trait.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trait>, I>>(object: I): Trait {
    const message = createBaseTrait();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tag.fromPartial(object.tags) : undefined;
    return message;
  },
};

function createBaseTrait_MetadataEntry(): Trait_MetadataEntry {
  return { key: "", value: "" };
}

export const Trait_MetadataEntry: MessageFns<Trait_MetadataEntry> = {
  encode(message: Trait_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trait_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrait_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Trait_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Trait_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Trait_MetadataEntry>, I>>(base?: I): Trait_MetadataEntry {
    return Trait_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Trait_MetadataEntry>, I>>(object: I): Trait_MetadataEntry {
    const message = createBaseTrait_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDisease(): Disease {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    description: "",
    severity: "",
    effects: [],
    characters: [],
  };
}

export const Disease: MessageFns<Disease> = {
  encode(message: Disease, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Disease_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      Tag.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.severity !== "") {
      writer.uint32(82).string(message.severity);
    }
    for (const v of message.effects) {
      writer.uint32(90).string(v!);
    }
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Disease {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisease();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Disease_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = Tag.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.severity = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.effects.push(reader.string());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Disease {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? Tag.fromJSON(object.tags) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      severity: isSet(object.severity) ? globalThis.String(object.severity) : "",
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => globalThis.String(e)) : [],
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Disease): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = Tag.toJSON(message.tags);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.severity !== "") {
      obj.severity = message.severity;
    }
    if (message.effects?.length) {
      obj.effects = message.effects;
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Disease>, I>>(base?: I): Disease {
    return Disease.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Disease>, I>>(object: I): Disease {
    const message = createBaseDisease();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tag.fromPartial(object.tags) : undefined;
    message.description = object.description ?? "";
    message.severity = object.severity ?? "";
    message.effects = object.effects?.map((e) => e) || [];
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDisease_MetadataEntry(): Disease_MetadataEntry {
  return { key: "", value: "" };
}

export const Disease_MetadataEntry: MessageFns<Disease_MetadataEntry> = {
  encode(message: Disease_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Disease_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisease_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Disease_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Disease_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Disease_MetadataEntry>, I>>(base?: I): Disease_MetadataEntry {
    return Disease_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Disease_MetadataEntry>, I>>(object: I): Disease_MetadataEntry {
    const message = createBaseDisease_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFact(): Fact {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    description: "",
    weight: 0,
    memories: [],
    characters: [],
  };
}

export const Fact: MessageFns<Fact> = {
  encode(message: Fact, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Fact_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      Tag.encode(message.tags, writer.uint32(66).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.weight !== 0) {
      writer.uint32(80).int32(message.weight);
    }
    for (const v of message.memories) {
      Memory.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fact {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFact();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Fact_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = Tag.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.weight = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.memories.push(Memory.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fact {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? Tag.fromJSON(object.tags) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
      memories: globalThis.Array.isArray(object?.memories) ? object.memories.map((e: any) => Memory.fromJSON(e)) : [],
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Fact): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = Tag.toJSON(message.tags);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.weight !== 0) {
      obj.weight = Math.round(message.weight);
    }
    if (message.memories?.length) {
      obj.memories = message.memories.map((e) => Memory.toJSON(e));
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fact>, I>>(base?: I): Fact {
    return Fact.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fact>, I>>(object: I): Fact {
    const message = createBaseFact();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tag.fromPartial(object.tags) : undefined;
    message.description = object.description ?? "";
    message.weight = object.weight ?? 0;
    message.memories = object.memories?.map((e) => Memory.fromPartial(e)) || [];
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFact_MetadataEntry(): Fact_MetadataEntry {
  return { key: "", value: "" };
}

export const Fact_MetadataEntry: MessageFns<Fact_MetadataEntry> = {
  encode(message: Fact_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fact_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFact_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Fact_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Fact_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Fact_MetadataEntry>, I>>(base?: I): Fact_MetadataEntry {
    return Fact_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fact_MetadataEntry>, I>>(object: I): Fact_MetadataEntry {
    const message = createBaseFact_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFaction(): Faction {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: undefined,
    characters: [],
  };
}

export const Faction: MessageFns<Faction> = {
  encode(message: Faction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Faction_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.tags !== undefined) {
      Tag.encode(message.tags, writer.uint32(66).fork()).join();
    }
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Faction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Faction_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags = Tag.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Faction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      tags: isSet(object.tags) ? Tag.fromJSON(object.tags) : undefined,
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Faction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.tags !== undefined) {
      obj.tags = Tag.toJSON(message.tags);
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Faction>, I>>(base?: I): Faction {
    return Faction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Faction>, I>>(object: I): Faction {
    const message = createBaseFaction();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tag.fromPartial(object.tags) : undefined;
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFaction_MetadataEntry(): Faction_MetadataEntry {
  return { key: "", value: "" };
}

export const Faction_MetadataEntry: MessageFns<Faction_MetadataEntry> = {
  encode(message: Faction_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Faction_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFaction_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Faction_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Faction_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Faction_MetadataEntry>, I>>(base?: I): Faction_MetadataEntry {
    return Faction_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Faction_MetadataEntry>, I>>(object: I): Faction_MetadataEntry {
    const message = createBaseFaction_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMemoryPool(): MemoryPool {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
    memoryPoolEntries: undefined,
    characterProfessions: undefined,
    tags: undefined,
  };
}

export const MemoryPool: MessageFns<MemoryPool> = {
  encode(message: MemoryPool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      MemoryPool_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.memoryPoolEntries !== undefined) {
      MemoryPoolEntry.encode(message.memoryPoolEntries, writer.uint32(74).fork()).join();
    }
    if (message.characterProfessions !== undefined) {
      CharacterProfession.encode(message.characterProfessions, writer.uint32(82).fork()).join();
    }
    if (message.tags !== undefined) {
      Tag.encode(message.tags, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = MemoryPool_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memoryPoolEntries = MemoryPoolEntry.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.characterProfessions = CharacterProfession.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.tags = Tag.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPool {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      memoryPoolEntries: isSet(object.memoryPoolEntries)
        ? MemoryPoolEntry.fromJSON(object.memoryPoolEntries)
        : undefined,
      characterProfessions: isSet(object.characterProfessions)
        ? CharacterProfession.fromJSON(object.characterProfessions)
        : undefined,
      tags: isSet(object.tags) ? Tag.fromJSON(object.tags) : undefined,
    };
  },

  toJSON(message: MemoryPool): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.memoryPoolEntries !== undefined) {
      obj.memoryPoolEntries = MemoryPoolEntry.toJSON(message.memoryPoolEntries);
    }
    if (message.characterProfessions !== undefined) {
      obj.characterProfessions = CharacterProfession.toJSON(message.characterProfessions);
    }
    if (message.tags !== undefined) {
      obj.tags = Tag.toJSON(message.tags);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPool>, I>>(base?: I): MemoryPool {
    return MemoryPool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPool>, I>>(object: I): MemoryPool {
    const message = createBaseMemoryPool();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.description = object.description ?? "";
    message.memoryPoolEntries = (object.memoryPoolEntries !== undefined && object.memoryPoolEntries !== null)
      ? MemoryPoolEntry.fromPartial(object.memoryPoolEntries)
      : undefined;
    message.characterProfessions = (object.characterProfessions !== undefined && object.characterProfessions !== null)
      ? CharacterProfession.fromPartial(object.characterProfessions)
      : undefined;
    message.tags = (object.tags !== undefined && object.tags !== null) ? Tag.fromPartial(object.tags) : undefined;
    return message;
  },
};

function createBaseMemoryPool_MetadataEntry(): MemoryPool_MetadataEntry {
  return { key: "", value: "" };
}

export const MemoryPool_MetadataEntry: MessageFns<MemoryPool_MetadataEntry> = {
  encode(message: MemoryPool_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPool_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPool_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPool_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MemoryPool_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPool_MetadataEntry>, I>>(base?: I): MemoryPool_MetadataEntry {
    return MemoryPool_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPool_MetadataEntry>, I>>(object: I): MemoryPool_MetadataEntry {
    const message = createBaseMemoryPool_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMemoryPoolEntry(): MemoryPoolEntry {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    memoryPool: undefined,
    memory: undefined,
    probability: 0,
    defaultClarity: 0,
    defaultImportance: 0,
  };
}

export const MemoryPoolEntry: MessageFns<MemoryPoolEntry> = {
  encode(message: MemoryPoolEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      MemoryPoolEntry_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.memoryPool !== undefined) {
      MemoryPool.encode(message.memoryPool, writer.uint32(66).fork()).join();
    }
    if (message.memory !== undefined) {
      Memory.encode(message.memory, writer.uint32(74).fork()).join();
    }
    if (message.probability !== 0) {
      writer.uint32(80).int32(message.probability);
    }
    if (message.defaultClarity !== 0) {
      writer.uint32(88).int32(message.defaultClarity);
    }
    if (message.defaultImportance !== 0) {
      writer.uint32(96).int32(message.defaultImportance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = MemoryPoolEntry_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.memoryPool = MemoryPool.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memory = Memory.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.probability = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.defaultClarity = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.defaultImportance = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolEntry {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      memoryPool: isSet(object.memoryPool) ? MemoryPool.fromJSON(object.memoryPool) : undefined,
      memory: isSet(object.memory) ? Memory.fromJSON(object.memory) : undefined,
      probability: isSet(object.probability) ? globalThis.Number(object.probability) : 0,
      defaultClarity: isSet(object.defaultClarity) ? globalThis.Number(object.defaultClarity) : 0,
      defaultImportance: isSet(object.defaultImportance) ? globalThis.Number(object.defaultImportance) : 0,
    };
  },

  toJSON(message: MemoryPoolEntry): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.memoryPool !== undefined) {
      obj.memoryPool = MemoryPool.toJSON(message.memoryPool);
    }
    if (message.memory !== undefined) {
      obj.memory = Memory.toJSON(message.memory);
    }
    if (message.probability !== 0) {
      obj.probability = Math.round(message.probability);
    }
    if (message.defaultClarity !== 0) {
      obj.defaultClarity = Math.round(message.defaultClarity);
    }
    if (message.defaultImportance !== 0) {
      obj.defaultImportance = Math.round(message.defaultImportance);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolEntry>, I>>(base?: I): MemoryPoolEntry {
    return MemoryPoolEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolEntry>, I>>(object: I): MemoryPoolEntry {
    const message = createBaseMemoryPoolEntry();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.memoryPool = (object.memoryPool !== undefined && object.memoryPool !== null)
      ? MemoryPool.fromPartial(object.memoryPool)
      : undefined;
    message.memory = (object.memory !== undefined && object.memory !== null)
      ? Memory.fromPartial(object.memory)
      : undefined;
    message.probability = object.probability ?? 0;
    message.defaultClarity = object.defaultClarity ?? 0;
    message.defaultImportance = object.defaultImportance ?? 0;
    return message;
  },
};

function createBaseMemoryPoolEntry_MetadataEntry(): MemoryPoolEntry_MetadataEntry {
  return { key: "", value: "" };
}

export const MemoryPoolEntry_MetadataEntry: MessageFns<MemoryPoolEntry_MetadataEntry> = {
  encode(message: MemoryPoolEntry_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MemoryPoolEntry_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemoryPoolEntry_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MemoryPoolEntry_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MemoryPoolEntry_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MemoryPoolEntry_MetadataEntry>, I>>(base?: I): MemoryPoolEntry_MetadataEntry {
    return MemoryPoolEntry_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MemoryPoolEntry_MetadataEntry>, I>>(
    object: I,
  ): MemoryPoolEntry_MetadataEntry {
    const message = createBaseMemoryPoolEntry_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCharacterProfession(): CharacterProfession {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    character: undefined,
  };
}

export const CharacterProfession: MessageFns<CharacterProfession> = {
  encode(message: CharacterProfession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CharacterProfession_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.character !== undefined) {
      Character.encode(message.character, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CharacterProfession_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.character = Character.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfession {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      character: isSet(object.character) ? Character.fromJSON(object.character) : undefined,
    };
  },

  toJSON(message: CharacterProfession): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.character !== undefined) {
      obj.character = Character.toJSON(message.character);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfession>, I>>(base?: I): CharacterProfession {
    return CharacterProfession.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfession>, I>>(object: I): CharacterProfession {
    const message = createBaseCharacterProfession();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.character = (object.character !== undefined && object.character !== null)
      ? Character.fromPartial(object.character)
      : undefined;
    return message;
  },
};

function createBaseCharacterProfession_MetadataEntry(): CharacterProfession_MetadataEntry {
  return { key: "", value: "" };
}

export const CharacterProfession_MetadataEntry: MessageFns<CharacterProfession_MetadataEntry> = {
  encode(message: CharacterProfession_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterProfession_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterProfession_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterProfession_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CharacterProfession_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterProfession_MetadataEntry>, I>>(
    base?: I,
  ): CharacterProfession_MetadataEntry {
    return CharacterProfession_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterProfession_MetadataEntry>, I>>(
    object: I,
  ): CharacterProfession_MetadataEntry {
    const message = createBaseCharacterProfession_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEquipmentSlot(): EquipmentSlot {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    allowedEntities: [],
    equippedItem: undefined,
    character: undefined,
  };
}

export const EquipmentSlot: MessageFns<EquipmentSlot> = {
  encode(message: EquipmentSlot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      EquipmentSlot_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    for (const v of message.allowedEntities) {
      writer.uint32(66).string(v!);
    }
    if (message.equippedItem !== undefined) {
      Item.encode(message.equippedItem, writer.uint32(74).fork()).join();
    }
    if (message.character !== undefined) {
      Character.encode(message.character, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = EquipmentSlot_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.allowedEntities.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.equippedItem = Item.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.character = Character.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlot {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      allowedEntities: globalThis.Array.isArray(object?.allowedEntities)
        ? object.allowedEntities.map((e: any) => globalThis.String(e))
        : [],
      equippedItem: isSet(object.equippedItem) ? Item.fromJSON(object.equippedItem) : undefined,
      character: isSet(object.character) ? Character.fromJSON(object.character) : undefined,
    };
  },

  toJSON(message: EquipmentSlot): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.allowedEntities?.length) {
      obj.allowedEntities = message.allowedEntities;
    }
    if (message.equippedItem !== undefined) {
      obj.equippedItem = Item.toJSON(message.equippedItem);
    }
    if (message.character !== undefined) {
      obj.character = Character.toJSON(message.character);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlot>, I>>(base?: I): EquipmentSlot {
    return EquipmentSlot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlot>, I>>(object: I): EquipmentSlot {
    const message = createBaseEquipmentSlot();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.allowedEntities = object.allowedEntities?.map((e) => e) || [];
    message.equippedItem = (object.equippedItem !== undefined && object.equippedItem !== null)
      ? Item.fromPartial(object.equippedItem)
      : undefined;
    message.character = (object.character !== undefined && object.character !== null)
      ? Character.fromPartial(object.character)
      : undefined;
    return message;
  },
};

function createBaseEquipmentSlot_MetadataEntry(): EquipmentSlot_MetadataEntry {
  return { key: "", value: "" };
}

export const EquipmentSlot_MetadataEntry: MessageFns<EquipmentSlot_MetadataEntry> = {
  encode(message: EquipmentSlot_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlot_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlot_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlot_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EquipmentSlot_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlot_MetadataEntry>, I>>(base?: I): EquipmentSlot_MetadataEntry {
    return EquipmentSlot_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlot_MetadataEntry>, I>>(object: I): EquipmentSlot_MetadataEntry {
    const message = createBaseEquipmentSlot_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBirthsign(): Birthsign {
  return { id: "", blueprintId: "", name: "", metadata: {}, user: undefined, campaign: undefined, world: undefined };
}

export const Birthsign: MessageFns<Birthsign> = {
  encode(message: Birthsign, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Birthsign_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Birthsign {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBirthsign();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Birthsign_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Birthsign {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
    };
  },

  toJSON(message: Birthsign): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Birthsign>, I>>(base?: I): Birthsign {
    return Birthsign.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Birthsign>, I>>(object: I): Birthsign {
    const message = createBaseBirthsign();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    return message;
  },
};

function createBaseBirthsign_MetadataEntry(): Birthsign_MetadataEntry {
  return { key: "", value: "" };
}

export const Birthsign_MetadataEntry: MessageFns<Birthsign_MetadataEntry> = {
  encode(message: Birthsign_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Birthsign_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBirthsign_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Birthsign_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Birthsign_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Birthsign_MetadataEntry>, I>>(base?: I): Birthsign_MetadataEntry {
    return Birthsign_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Birthsign_MetadataEntry>, I>>(object: I): Birthsign_MetadataEntry {
    const message = createBaseBirthsign_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRace(): Race {
  return {
    id: "",
    blueprintId: "",
    name: "",
    equipmentSlotDefinitions: [],
    user: undefined,
    campaign: undefined,
    world: undefined,
    metadata: {},
  };
}

export const Race: MessageFns<Race> = {
  encode(message: Race, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    for (const v of message.equipmentSlotDefinitions) {
      EquipmentSlotDefinition.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Race_MetadataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Race {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.equipmentSlotDefinitions.push(EquipmentSlotDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = Race_MetadataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Race {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      equipmentSlotDefinitions: globalThis.Array.isArray(object?.equipmentSlotDefinitions)
        ? object.equipmentSlotDefinitions.map((e: any) => EquipmentSlotDefinition.fromJSON(e))
        : [],
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: Race): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.equipmentSlotDefinitions?.length) {
      obj.equipmentSlotDefinitions = message.equipmentSlotDefinitions.map((e) => EquipmentSlotDefinition.toJSON(e));
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Race>, I>>(base?: I): Race {
    return Race.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Race>, I>>(object: I): Race {
    const message = createBaseRace();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.equipmentSlotDefinitions =
      object.equipmentSlotDefinitions?.map((e) => EquipmentSlotDefinition.fromPartial(e)) || [];
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRace_MetadataEntry(): Race_MetadataEntry {
  return { key: "", value: "" };
}

export const Race_MetadataEntry: MessageFns<Race_MetadataEntry> = {
  encode(message: Race_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Race_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRace_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Race_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Race_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Race_MetadataEntry>, I>>(base?: I): Race_MetadataEntry {
    return Race_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Race_MetadataEntry>, I>>(object: I): Race_MetadataEntry {
    const message = createBaseRace_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEquipmentSlotDefinition(): EquipmentSlotDefinition {
  return { name: "", allowedEntities: [] };
}

export const EquipmentSlotDefinition: MessageFns<EquipmentSlotDefinition> = {
  encode(message: EquipmentSlotDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.allowedEntities) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EquipmentSlotDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEquipmentSlotDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowedEntities.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EquipmentSlotDefinition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      allowedEntities: globalThis.Array.isArray(object?.allowedEntities)
        ? object.allowedEntities.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EquipmentSlotDefinition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.allowedEntities?.length) {
      obj.allowedEntities = message.allowedEntities;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EquipmentSlotDefinition>, I>>(base?: I): EquipmentSlotDefinition {
    return EquipmentSlotDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EquipmentSlotDefinition>, I>>(object: I): EquipmentSlotDefinition {
    const message = createBaseEquipmentSlotDefinition();
    message.name = object.name ?? "";
    message.allowedEntities = object.allowedEntities?.map((e) => e) || [];
    return message;
  },
};

function createBaseStorageSlotDefinition(): StorageSlotDefinition {
  return { grid: [], name: "", maxWeight: 0 };
}

export const StorageSlotDefinition: MessageFns<StorageSlotDefinition> = {
  encode(message: StorageSlotDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.grid) {
      writer.int32(v);
    }
    writer.join();
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.maxWeight !== 0) {
      writer.uint32(24).int32(message.maxWeight);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageSlotDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageSlotDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.grid.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.grid.push(reader.int32());
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxWeight = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageSlotDefinition {
    return {
      grid: globalThis.Array.isArray(object?.grid) ? object.grid.map((e: any) => globalThis.Number(e)) : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      maxWeight: isSet(object.maxWeight) ? globalThis.Number(object.maxWeight) : 0,
    };
  },

  toJSON(message: StorageSlotDefinition): unknown {
    const obj: any = {};
    if (message.grid?.length) {
      obj.grid = message.grid.map((e) => Math.round(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.maxWeight !== 0) {
      obj.maxWeight = Math.round(message.maxWeight);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageSlotDefinition>, I>>(base?: I): StorageSlotDefinition {
    return StorageSlotDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageSlotDefinition>, I>>(object: I): StorageSlotDefinition {
    const message = createBaseStorageSlotDefinition();
    message.grid = object.grid?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.maxWeight = object.maxWeight ?? 0;
    return message;
  },
};

function createBaseMood(): Mood {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
  };
}

export const Mood: MessageFns<Mood> = {
  encode(message: Mood, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Mood_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mood {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMood();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Mood_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mood {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Mood): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mood>, I>>(base?: I): Mood {
    return Mood.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mood>, I>>(object: I): Mood {
    const message = createBaseMood();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseMood_MetadataEntry(): Mood_MetadataEntry {
  return { key: "", value: "" };
}

export const Mood_MetadataEntry: MessageFns<Mood_MetadataEntry> = {
  encode(message: Mood_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Mood_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMood_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Mood_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Mood_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Mood_MetadataEntry>, I>>(base?: I): Mood_MetadataEntry {
    return Mood_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Mood_MetadataEntry>, I>>(object: I): Mood_MetadataEntry {
    const message = createBaseMood_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseReligion(): Religion {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
    rituals: [],
    tenets: [],
  };
}

export const Religion: MessageFns<Religion> = {
  encode(message: Religion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Religion_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    for (const v of message.rituals) {
      ReligionRitual.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.tenets) {
      ReligionTenet.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Religion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Religion_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.rituals.push(ReligionRitual.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tenets.push(ReligionTenet.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Religion {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      rituals: globalThis.Array.isArray(object?.rituals)
        ? object.rituals.map((e: any) => ReligionRitual.fromJSON(e))
        : [],
      tenets: globalThis.Array.isArray(object?.tenets) ? object.tenets.map((e: any) => ReligionTenet.fromJSON(e)) : [],
    };
  },

  toJSON(message: Religion): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.rituals?.length) {
      obj.rituals = message.rituals.map((e) => ReligionRitual.toJSON(e));
    }
    if (message.tenets?.length) {
      obj.tenets = message.tenets.map((e) => ReligionTenet.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Religion>, I>>(base?: I): Religion {
    return Religion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Religion>, I>>(object: I): Religion {
    const message = createBaseReligion();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.description = object.description ?? "";
    message.rituals = object.rituals?.map((e) => ReligionRitual.fromPartial(e)) || [];
    message.tenets = object.tenets?.map((e) => ReligionTenet.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReligion_MetadataEntry(): Religion_MetadataEntry {
  return { key: "", value: "" };
}

export const Religion_MetadataEntry: MessageFns<Religion_MetadataEntry> = {
  encode(message: Religion_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Religion_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligion_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Religion_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Religion_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Religion_MetadataEntry>, I>>(base?: I): Religion_MetadataEntry {
    return Religion_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Religion_MetadataEntry>, I>>(object: I): Religion_MetadataEntry {
    const message = createBaseReligion_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseReligionRitual(): ReligionRitual {
  return { name: "", description: "" };
}

export const ReligionRitual: MessageFns<ReligionRitual> = {
  encode(message: ReligionRitual, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionRitual {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionRitual();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionRitual {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ReligionRitual): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionRitual>, I>>(base?: I): ReligionRitual {
    return ReligionRitual.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionRitual>, I>>(object: I): ReligionRitual {
    const message = createBaseReligionRitual();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseReligionTenet(): ReligionTenet {
  return { name: "", description: "" };
}

export const ReligionTenet: MessageFns<ReligionTenet> = {
  encode(message: ReligionTenet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReligionTenet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReligionTenet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReligionTenet {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: ReligionTenet): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReligionTenet>, I>>(base?: I): ReligionTenet {
    return ReligionTenet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReligionTenet>, I>>(object: I): ReligionTenet {
    const message = createBaseReligionTenet();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseGridPosition(): GridPosition {
  return { x: 0, y: 0 };
}

export const GridPosition: MessageFns<GridPosition> = {
  encode(message: GridPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(8).int32(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(16).int32(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GridPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGridPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.x = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.y = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GridPosition {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: GridPosition): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = Math.round(message.x);
    }
    if (message.y !== 0) {
      obj.y = Math.round(message.y);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GridPosition>, I>>(base?: I): GridPosition {
    return GridPosition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GridPosition>, I>>(object: I): GridPosition {
    const message = createBaseGridPosition();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseGenerationInstruction(): GenerationInstruction {
  return {
    blueprintId: undefined,
    idsAndQuant: undefined,
    simpleProb: undefined,
    gaussianProb: undefined,
    combinator: undefined,
  };
}

export const GenerationInstruction: MessageFns<GenerationInstruction> = {
  encode(message: GenerationInstruction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== undefined) {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.idsAndQuant !== undefined) {
      IdAndQuant.encode(message.idsAndQuant, writer.uint32(18).fork()).join();
    }
    if (message.simpleProb !== undefined) {
      SimpleProb.encode(message.simpleProb, writer.uint32(26).fork()).join();
    }
    if (message.gaussianProb !== undefined) {
      GaussianProb.encode(message.gaussianProb, writer.uint32(34).fork()).join();
    }
    if (message.combinator !== undefined) {
      Combinator.encode(message.combinator, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerationInstruction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerationInstruction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.idsAndQuant = IdAndQuant.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.simpleProb = SimpleProb.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gaussianProb = GaussianProb.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.combinator = Combinator.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenerationInstruction {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : undefined,
      idsAndQuant: isSet(object.idsAndQuant) ? IdAndQuant.fromJSON(object.idsAndQuant) : undefined,
      simpleProb: isSet(object.simpleProb) ? SimpleProb.fromJSON(object.simpleProb) : undefined,
      gaussianProb: isSet(object.gaussianProb) ? GaussianProb.fromJSON(object.gaussianProb) : undefined,
      combinator: isSet(object.combinator) ? Combinator.fromJSON(object.combinator) : undefined,
    };
  },

  toJSON(message: GenerationInstruction): unknown {
    const obj: any = {};
    if (message.blueprintId !== undefined) {
      obj.blueprintId = message.blueprintId;
    }
    if (message.idsAndQuant !== undefined) {
      obj.idsAndQuant = IdAndQuant.toJSON(message.idsAndQuant);
    }
    if (message.simpleProb !== undefined) {
      obj.simpleProb = SimpleProb.toJSON(message.simpleProb);
    }
    if (message.gaussianProb !== undefined) {
      obj.gaussianProb = GaussianProb.toJSON(message.gaussianProb);
    }
    if (message.combinator !== undefined) {
      obj.combinator = Combinator.toJSON(message.combinator);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerationInstruction>, I>>(base?: I): GenerationInstruction {
    return GenerationInstruction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerationInstruction>, I>>(object: I): GenerationInstruction {
    const message = createBaseGenerationInstruction();
    message.blueprintId = object.blueprintId ?? undefined;
    message.idsAndQuant = (object.idsAndQuant !== undefined && object.idsAndQuant !== null)
      ? IdAndQuant.fromPartial(object.idsAndQuant)
      : undefined;
    message.simpleProb = (object.simpleProb !== undefined && object.simpleProb !== null)
      ? SimpleProb.fromPartial(object.simpleProb)
      : undefined;
    message.gaussianProb = (object.gaussianProb !== undefined && object.gaussianProb !== null)
      ? GaussianProb.fromPartial(object.gaussianProb)
      : undefined;
    message.combinator = (object.combinator !== undefined && object.combinator !== null)
      ? Combinator.fromPartial(object.combinator)
      : undefined;
    return message;
  },
};

function createBaseIdAndQuant(): IdAndQuant {
  return { idAndQuant: {} };
}

export const IdAndQuant: MessageFns<IdAndQuant> = {
  encode(message: IdAndQuant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.idAndQuant).forEach(([key, value]) => {
      IdAndQuant_IdAndQuantEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdAndQuant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdAndQuant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = IdAndQuant_IdAndQuantEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.idAndQuant[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdAndQuant {
    return {
      idAndQuant: isObject(object.idAndQuant)
        ? Object.entries(object.idAndQuant).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: IdAndQuant): unknown {
    const obj: any = {};
    if (message.idAndQuant) {
      const entries = Object.entries(message.idAndQuant);
      if (entries.length > 0) {
        obj.idAndQuant = {};
        entries.forEach(([k, v]) => {
          obj.idAndQuant[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdAndQuant>, I>>(base?: I): IdAndQuant {
    return IdAndQuant.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdAndQuant>, I>>(object: I): IdAndQuant {
    const message = createBaseIdAndQuant();
    message.idAndQuant = Object.entries(object.idAndQuant ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseIdAndQuant_IdAndQuantEntry(): IdAndQuant_IdAndQuantEntry {
  return { key: "", value: 0 };
}

export const IdAndQuant_IdAndQuantEntry: MessageFns<IdAndQuant_IdAndQuantEntry> = {
  encode(message: IdAndQuant_IdAndQuantEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdAndQuant_IdAndQuantEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdAndQuant_IdAndQuantEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdAndQuant_IdAndQuantEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: IdAndQuant_IdAndQuantEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IdAndQuant_IdAndQuantEntry>, I>>(base?: I): IdAndQuant_IdAndQuantEntry {
    return IdAndQuant_IdAndQuantEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IdAndQuant_IdAndQuantEntry>, I>>(object: I): IdAndQuant_IdAndQuantEntry {
    const message = createBaseIdAndQuant_IdAndQuantEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCharacterGenInstruction(): CharacterGenInstruction {
  return {
    blueprintId: "",
    backgroundBlueprintId: "",
    targetEntity: "",
    firstName: undefined,
    lastName: undefined,
    gender: undefined,
    birthEra: undefined,
    birthYear: undefined,
    birthMonth: undefined,
    birthDay: undefined,
    backgroundCustomization: undefined,
  };
}

export const CharacterGenInstruction: MessageFns<CharacterGenInstruction> = {
  encode(message: CharacterGenInstruction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.backgroundBlueprintId !== "") {
      writer.uint32(18).string(message.backgroundBlueprintId);
    }
    if (message.targetEntity !== "") {
      writer.uint32(26).string(message.targetEntity);
    }
    if (message.firstName !== undefined) {
      writer.uint32(34).string(message.firstName);
    }
    if (message.lastName !== undefined) {
      writer.uint32(42).string(message.lastName);
    }
    if (message.gender !== undefined) {
      writer.uint32(50).string(message.gender);
    }
    if (message.birthEra !== undefined) {
      writer.uint32(58).string(message.birthEra);
    }
    if (message.birthYear !== undefined) {
      writer.uint32(66).string(message.birthYear);
    }
    if (message.birthMonth !== undefined) {
      writer.uint32(74).string(message.birthMonth);
    }
    if (message.birthDay !== undefined) {
      writer.uint32(82).string(message.birthDay);
    }
    if (message.backgroundCustomization !== undefined) {
      BackgroundCustomization.encode(message.backgroundCustomization, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGenInstruction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGenInstruction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.backgroundBlueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetEntity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastName = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gender = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.birthEra = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.birthYear = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.birthMonth = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.birthDay = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.backgroundCustomization = BackgroundCustomization.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGenInstruction {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      backgroundBlueprintId: isSet(object.backgroundBlueprintId) ? globalThis.String(object.backgroundBlueprintId) : "",
      targetEntity: isSet(object.targetEntity) ? globalThis.String(object.targetEntity) : "",
      firstName: isSet(object.firstName) ? globalThis.String(object.firstName) : undefined,
      lastName: isSet(object.lastName) ? globalThis.String(object.lastName) : undefined,
      gender: isSet(object.gender) ? globalThis.String(object.gender) : undefined,
      birthEra: isSet(object.birthEra) ? globalThis.String(object.birthEra) : undefined,
      birthYear: isSet(object.birthYear) ? globalThis.String(object.birthYear) : undefined,
      birthMonth: isSet(object.birthMonth) ? globalThis.String(object.birthMonth) : undefined,
      birthDay: isSet(object.birthDay) ? globalThis.String(object.birthDay) : undefined,
      backgroundCustomization: isSet(object.backgroundCustomization)
        ? BackgroundCustomization.fromJSON(object.backgroundCustomization)
        : undefined,
    };
  },

  toJSON(message: CharacterGenInstruction): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.backgroundBlueprintId !== "") {
      obj.backgroundBlueprintId = message.backgroundBlueprintId;
    }
    if (message.targetEntity !== "") {
      obj.targetEntity = message.targetEntity;
    }
    if (message.firstName !== undefined) {
      obj.firstName = message.firstName;
    }
    if (message.lastName !== undefined) {
      obj.lastName = message.lastName;
    }
    if (message.gender !== undefined) {
      obj.gender = message.gender;
    }
    if (message.birthEra !== undefined) {
      obj.birthEra = message.birthEra;
    }
    if (message.birthYear !== undefined) {
      obj.birthYear = message.birthYear;
    }
    if (message.birthMonth !== undefined) {
      obj.birthMonth = message.birthMonth;
    }
    if (message.birthDay !== undefined) {
      obj.birthDay = message.birthDay;
    }
    if (message.backgroundCustomization !== undefined) {
      obj.backgroundCustomization = BackgroundCustomization.toJSON(message.backgroundCustomization);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGenInstruction>, I>>(base?: I): CharacterGenInstruction {
    return CharacterGenInstruction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGenInstruction>, I>>(object: I): CharacterGenInstruction {
    const message = createBaseCharacterGenInstruction();
    message.blueprintId = object.blueprintId ?? "";
    message.backgroundBlueprintId = object.backgroundBlueprintId ?? "";
    message.targetEntity = object.targetEntity ?? "";
    message.firstName = object.firstName ?? undefined;
    message.lastName = object.lastName ?? undefined;
    message.gender = object.gender ?? undefined;
    message.birthEra = object.birthEra ?? undefined;
    message.birthYear = object.birthYear ?? undefined;
    message.birthMonth = object.birthMonth ?? undefined;
    message.birthDay = object.birthDay ?? undefined;
    message.backgroundCustomization =
      (object.backgroundCustomization !== undefined && object.backgroundCustomization !== null)
        ? BackgroundCustomization.fromPartial(object.backgroundCustomization)
        : undefined;
    return message;
  },
};

function createBaseCharacterGroupGenInstruction(): CharacterGroupGenInstruction {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    set: undefined,
  };
}

export const CharacterGroupGenInstruction: MessageFns<CharacterGroupGenInstruction> = {
  encode(message: CharacterGroupGenInstruction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CharacterGroupGenInstruction_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.set !== undefined) {
      Combinator.encode(message.set, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGroupGenInstruction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGroupGenInstruction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CharacterGroupGenInstruction_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.set = Combinator.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGroupGenInstruction {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      set: isSet(object.set) ? Combinator.fromJSON(object.set) : undefined,
    };
  },

  toJSON(message: CharacterGroupGenInstruction): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.set !== undefined) {
      obj.set = Combinator.toJSON(message.set);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGroupGenInstruction>, I>>(base?: I): CharacterGroupGenInstruction {
    return CharacterGroupGenInstruction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGroupGenInstruction>, I>>(object: I): CharacterGroupGenInstruction {
    const message = createBaseCharacterGroupGenInstruction();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.set = (object.set !== undefined && object.set !== null) ? Combinator.fromPartial(object.set) : undefined;
    return message;
  },
};

function createBaseCharacterGroupGenInstruction_MetadataEntry(): CharacterGroupGenInstruction_MetadataEntry {
  return { key: "", value: "" };
}

export const CharacterGroupGenInstruction_MetadataEntry: MessageFns<CharacterGroupGenInstruction_MetadataEntry> = {
  encode(message: CharacterGroupGenInstruction_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CharacterGroupGenInstruction_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCharacterGroupGenInstruction_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CharacterGroupGenInstruction_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CharacterGroupGenInstruction_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CharacterGroupGenInstruction_MetadataEntry>, I>>(
    base?: I,
  ): CharacterGroupGenInstruction_MetadataEntry {
    return CharacterGroupGenInstruction_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CharacterGroupGenInstruction_MetadataEntry>, I>>(
    object: I,
  ): CharacterGroupGenInstruction_MetadataEntry {
    const message = createBaseCharacterGroupGenInstruction_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseBackgroundCustomization(): BackgroundCustomization {
  return {
    race: [],
    faction: [],
    disease: [],
    addiction: [],
    profession: [],
    religion: [],
    itemSets: [],
    items: [],
    pastExpChild: [],
    pastExpAdult: [],
    skillSets: [],
    skillAdjustments: {},
    personality: [],
  };
}

export const BackgroundCustomization: MessageFns<BackgroundCustomization> = {
  encode(message: BackgroundCustomization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.race) {
      GenerationInstruction.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.faction) {
      GenerationInstruction.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.disease) {
      GenerationInstruction.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.addiction) {
      GenerationInstruction.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.profession) {
      GenerationInstruction.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.religion) {
      GenerationInstruction.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.itemSets) {
      GenerationInstruction.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.items) {
      GenerationInstruction.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.pastExpChild) {
      GenerationInstruction.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.pastExpAdult) {
      GenerationInstruction.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.skillSets) {
      GenerationInstruction.encode(v!, writer.uint32(90).fork()).join();
    }
    Object.entries(message.skillAdjustments).forEach(([key, value]) => {
      BackgroundCustomization_SkillAdjustmentsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    for (const v of message.personality) {
      GenerationInstruction.encode(v!, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BackgroundCustomization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBackgroundCustomization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.race.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.faction.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.disease.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.addiction.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.profession.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.religion.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.itemSets.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.items.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pastExpChild.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.pastExpAdult.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.skillSets.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = BackgroundCustomization_SkillAdjustmentsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.skillAdjustments[entry12.key] = entry12.value;
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.personality.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BackgroundCustomization {
    return {
      race: globalThis.Array.isArray(object?.race)
        ? object.race.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      faction: globalThis.Array.isArray(object?.faction)
        ? object.faction.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      disease: globalThis.Array.isArray(object?.disease)
        ? object.disease.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      addiction: globalThis.Array.isArray(object?.addiction)
        ? object.addiction.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      profession: globalThis.Array.isArray(object?.profession)
        ? object.profession.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      religion: globalThis.Array.isArray(object?.religion)
        ? object.religion.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      itemSets: globalThis.Array.isArray(object?.itemSets)
        ? object.itemSets.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      pastExpChild: globalThis.Array.isArray(object?.pastExpChild)
        ? object.pastExpChild.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      pastExpAdult: globalThis.Array.isArray(object?.pastExpAdult)
        ? object.pastExpAdult.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      skillSets: globalThis.Array.isArray(object?.skillSets)
        ? object.skillSets.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      skillAdjustments: isObject(object.skillAdjustments)
        ? Object.entries(object.skillAdjustments).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      personality: globalThis.Array.isArray(object?.personality)
        ? object.personality.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: BackgroundCustomization): unknown {
    const obj: any = {};
    if (message.race?.length) {
      obj.race = message.race.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.faction?.length) {
      obj.faction = message.faction.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.disease?.length) {
      obj.disease = message.disease.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.addiction?.length) {
      obj.addiction = message.addiction.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.profession?.length) {
      obj.profession = message.profession.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.religion?.length) {
      obj.religion = message.religion.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.itemSets?.length) {
      obj.itemSets = message.itemSets.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.pastExpChild?.length) {
      obj.pastExpChild = message.pastExpChild.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.pastExpAdult?.length) {
      obj.pastExpAdult = message.pastExpAdult.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.skillSets?.length) {
      obj.skillSets = message.skillSets.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.skillAdjustments) {
      const entries = Object.entries(message.skillAdjustments);
      if (entries.length > 0) {
        obj.skillAdjustments = {};
        entries.forEach(([k, v]) => {
          obj.skillAdjustments[k] = Math.round(v);
        });
      }
    }
    if (message.personality?.length) {
      obj.personality = message.personality.map((e) => GenerationInstruction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BackgroundCustomization>, I>>(base?: I): BackgroundCustomization {
    return BackgroundCustomization.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BackgroundCustomization>, I>>(object: I): BackgroundCustomization {
    const message = createBaseBackgroundCustomization();
    message.race = object.race?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.faction = object.faction?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.disease = object.disease?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.addiction = object.addiction?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.profession = object.profession?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.religion = object.religion?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.itemSets = object.itemSets?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.items = object.items?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.pastExpChild = object.pastExpChild?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.pastExpAdult = object.pastExpAdult?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.skillSets = object.skillSets?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.skillAdjustments = Object.entries(object.skillAdjustments ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    message.personality = object.personality?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseBackgroundCustomization_SkillAdjustmentsEntry(): BackgroundCustomization_SkillAdjustmentsEntry {
  return { key: "", value: 0 };
}

export const BackgroundCustomization_SkillAdjustmentsEntry: MessageFns<BackgroundCustomization_SkillAdjustmentsEntry> =
  {
    encode(
      message: BackgroundCustomization_SkillAdjustmentsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== 0) {
        writer.uint32(16).int32(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): BackgroundCustomization_SkillAdjustmentsEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseBackgroundCustomization_SkillAdjustmentsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.value = reader.int32();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): BackgroundCustomization_SkillAdjustmentsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.Number(object.value) : 0,
      };
    },

    toJSON(message: BackgroundCustomization_SkillAdjustmentsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== 0) {
        obj.value = Math.round(message.value);
      }
      return obj;
    },

    create<I extends Exact<DeepPartial<BackgroundCustomization_SkillAdjustmentsEntry>, I>>(
      base?: I,
    ): BackgroundCustomization_SkillAdjustmentsEntry {
      return BackgroundCustomization_SkillAdjustmentsEntry.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<BackgroundCustomization_SkillAdjustmentsEntry>, I>>(
      object: I,
    ): BackgroundCustomization_SkillAdjustmentsEntry {
      const message = createBaseBackgroundCustomization_SkillAdjustmentsEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? 0;
      return message;
    },
  };

function createBaseSimpleProb(): SimpleProb {
  return { cond: 0, prob: {}, clazz: "" };
}

export const SimpleProb: MessageFns<SimpleProb> = {
  encode(message: SimpleProb, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cond !== 0) {
      writer.uint32(8).int32(message.cond);
    }
    Object.entries(message.prob).forEach(([key, value]) => {
      SimpleProb_ProbEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.clazz !== "") {
      writer.uint32(26).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleProb {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleProb();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cond = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SimpleProb_ProbEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.prob[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleProb {
    return {
      cond: isSet(object.cond) ? conditionEnumFromJSON(object.cond) : 0,
      prob: isObject(object.prob)
        ? Object.entries(object.prob).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: SimpleProb): unknown {
    const obj: any = {};
    if (message.cond !== 0) {
      obj.cond = conditionEnumToJSON(message.cond);
    }
    if (message.prob) {
      const entries = Object.entries(message.prob);
      if (entries.length > 0) {
        obj.prob = {};
        entries.forEach(([k, v]) => {
          obj.prob[k] = v;
        });
      }
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleProb>, I>>(base?: I): SimpleProb {
    return SimpleProb.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleProb>, I>>(object: I): SimpleProb {
    const message = createBaseSimpleProb();
    message.cond = object.cond ?? 0;
    message.prob = Object.entries(object.prob ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseSimpleProb_ProbEntry(): SimpleProb_ProbEntry {
  return { key: "", value: 0 };
}

export const SimpleProb_ProbEntry: MessageFns<SimpleProb_ProbEntry> = {
  encode(message: SimpleProb_ProbEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimpleProb_ProbEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimpleProb_ProbEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimpleProb_ProbEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: SimpleProb_ProbEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimpleProb_ProbEntry>, I>>(base?: I): SimpleProb_ProbEntry {
    return SimpleProb_ProbEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimpleProb_ProbEntry>, I>>(object: I): SimpleProb_ProbEntry {
    const message = createBaseSimpleProb_ProbEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseGaussianProb(): GaussianProb {
  return { blueprintId: "", prob: 0, avgQuan: undefined, stDev: undefined, skew: undefined, clazz: "" };
}

export const GaussianProb: MessageFns<GaussianProb> = {
  encode(message: GaussianProb, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.blueprintId !== "") {
      writer.uint32(10).string(message.blueprintId);
    }
    if (message.prob !== 0) {
      writer.uint32(21).float(message.prob);
    }
    if (message.avgQuan !== undefined) {
      writer.uint32(24).int32(message.avgQuan);
    }
    if (message.stDev !== undefined) {
      writer.uint32(37).float(message.stDev);
    }
    if (message.skew !== undefined) {
      writer.uint32(45).float(message.skew);
    }
    if (message.clazz !== "") {
      writer.uint32(50).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GaussianProb {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGaussianProb();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.prob = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.avgQuan = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.stDev = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.skew = reader.float();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GaussianProb {
    return {
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      prob: isSet(object.prob) ? globalThis.Number(object.prob) : 0,
      avgQuan: isSet(object.avgQuan) ? globalThis.Number(object.avgQuan) : undefined,
      stDev: isSet(object.stDev) ? globalThis.Number(object.stDev) : undefined,
      skew: isSet(object.skew) ? globalThis.Number(object.skew) : undefined,
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: GaussianProb): unknown {
    const obj: any = {};
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.prob !== 0) {
      obj.prob = message.prob;
    }
    if (message.avgQuan !== undefined) {
      obj.avgQuan = Math.round(message.avgQuan);
    }
    if (message.stDev !== undefined) {
      obj.stDev = message.stDev;
    }
    if (message.skew !== undefined) {
      obj.skew = message.skew;
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GaussianProb>, I>>(base?: I): GaussianProb {
    return GaussianProb.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GaussianProb>, I>>(object: I): GaussianProb {
    const message = createBaseGaussianProb();
    message.blueprintId = object.blueprintId ?? "";
    message.prob = object.prob ?? 0;
    message.avgQuan = object.avgQuan ?? undefined;
    message.stDev = object.stDev ?? undefined;
    message.skew = object.skew ?? undefined;
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBaseCombinator(): Combinator {
  return { name: undefined, cond: 0, prob: 0, instructions: [], clazz: "" };
}

export const Combinator: MessageFns<Combinator> = {
  encode(message: Combinator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== undefined) {
      writer.uint32(10).string(message.name);
    }
    if (message.cond !== 0) {
      writer.uint32(16).int32(message.cond);
    }
    if (message.prob !== 0) {
      writer.uint32(29).float(message.prob);
    }
    for (const v of message.instructions) {
      GenerationInstruction.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.clazz !== "") {
      writer.uint32(42).string(message.clazz);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Combinator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCombinator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cond = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.prob = reader.float();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instructions.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clazz = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Combinator {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      cond: isSet(object.cond) ? conditionEnumFromJSON(object.cond) : 0,
      prob: isSet(object.prob) ? globalThis.Number(object.prob) : 0,
      instructions: globalThis.Array.isArray(object?.instructions)
        ? object.instructions.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
      clazz: isSet(object.clazz) ? globalThis.String(object.clazz) : "",
    };
  },

  toJSON(message: Combinator): unknown {
    const obj: any = {};
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.cond !== 0) {
      obj.cond = conditionEnumToJSON(message.cond);
    }
    if (message.prob !== 0) {
      obj.prob = message.prob;
    }
    if (message.instructions?.length) {
      obj.instructions = message.instructions.map((e) => GenerationInstruction.toJSON(e));
    }
    if (message.clazz !== "") {
      obj.clazz = message.clazz;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Combinator>, I>>(base?: I): Combinator {
    return Combinator.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Combinator>, I>>(object: I): Combinator {
    const message = createBaseCombinator();
    message.name = object.name ?? undefined;
    message.cond = object.cond ?? 0;
    message.prob = object.prob ?? 0;
    message.instructions = object.instructions?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    message.clazz = object.clazz ?? "";
    return message;
  },
};

function createBasePastExperience(): PastExperience {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    type: "",
  };
}

export const PastExperience: MessageFns<PastExperience> = {
  encode(message: PastExperience, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      PastExperience_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(66).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(74).string(message.type);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PastExperience {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePastExperience();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = PastExperience_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.type = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PastExperience {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => Tag.fromJSON(e)) : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
    };
  },

  toJSON(message: PastExperience): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Tag.toJSON(e));
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PastExperience>, I>>(base?: I): PastExperience {
    return PastExperience.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PastExperience>, I>>(object: I): PastExperience {
    const message = createBasePastExperience();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
    message.type = object.type ?? "";
    return message;
  },
};

function createBasePastExperience_MetadataEntry(): PastExperience_MetadataEntry {
  return { key: "", value: "" };
}

export const PastExperience_MetadataEntry: MessageFns<PastExperience_MetadataEntry> = {
  encode(message: PastExperience_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PastExperience_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePastExperience_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PastExperience_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PastExperience_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PastExperience_MetadataEntry>, I>>(base?: I): PastExperience_MetadataEntry {
    return PastExperience_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PastExperience_MetadataEntry>, I>>(object: I): PastExperience_MetadataEntry {
    const message = createBasePastExperience_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMemory(): Memory {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    tags: [],
    facts: [],
    type: 0,
    description: "",
  };
}

export const Memory: MessageFns<Memory> = {
  encode(message: Memory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Memory_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.facts) {
      Fact.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(80).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(90).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Memory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Memory_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.facts.push(Fact.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memory {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => Tag.fromJSON(e)) : [],
      facts: globalThis.Array.isArray(object?.facts) ? object.facts.map((e: any) => Fact.fromJSON(e)) : [],
      type: isSet(object.type) ? memoryTypeEnumFromJSON(object.type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: Memory): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Tag.toJSON(e));
    }
    if (message.facts?.length) {
      obj.facts = message.facts.map((e) => Fact.toJSON(e));
    }
    if (message.type !== 0) {
      obj.type = memoryTypeEnumToJSON(message.type);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memory>, I>>(base?: I): Memory {
    return Memory.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memory>, I>>(object: I): Memory {
    const message = createBaseMemory();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
    message.facts = object.facts?.map((e) => Fact.fromPartial(e)) || [];
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseMemory_MetadataEntry(): Memory_MetadataEntry {
  return { key: "", value: "" };
}

export const Memory_MetadataEntry: MessageFns<Memory_MetadataEntry> = {
  encode(message: Memory_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Memory_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemory_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memory_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Memory_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memory_MetadataEntry>, I>>(base?: I): Memory_MetadataEntry {
    return Memory_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memory_MetadataEntry>, I>>(object: I): Memory_MetadataEntry {
    const message = createBaseMemory_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBasePersonalityProfile(): PersonalityProfile {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    enneagramType: "",
    traits: [],
  };
}

export const PersonalityProfile: MessageFns<PersonalityProfile> = {
  encode(message: PersonalityProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      PersonalityProfile_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.enneagramType !== "") {
      writer.uint32(66).string(message.enneagramType);
    }
    for (const v of message.traits) {
      GenerationInstruction.encode(v!, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalityProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalityProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = PersonalityProfile_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.enneagramType = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.traits.push(GenerationInstruction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalityProfile {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      enneagramType: isSet(object.enneagramType) ? globalThis.String(object.enneagramType) : "",
      traits: globalThis.Array.isArray(object?.traits)
        ? object.traits.map((e: any) => GenerationInstruction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PersonalityProfile): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.enneagramType !== "") {
      obj.enneagramType = message.enneagramType;
    }
    if (message.traits?.length) {
      obj.traits = message.traits.map((e) => GenerationInstruction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonalityProfile>, I>>(base?: I): PersonalityProfile {
    return PersonalityProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonalityProfile>, I>>(object: I): PersonalityProfile {
    const message = createBasePersonalityProfile();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.enneagramType = object.enneagramType ?? "";
    message.traits = object.traits?.map((e) => GenerationInstruction.fromPartial(e)) || [];
    return message;
  },
};

function createBasePersonalityProfile_MetadataEntry(): PersonalityProfile_MetadataEntry {
  return { key: "", value: "" };
}

export const PersonalityProfile_MetadataEntry: MessageFns<PersonalityProfile_MetadataEntry> = {
  encode(message: PersonalityProfile_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PersonalityProfile_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePersonalityProfile_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PersonalityProfile_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: PersonalityProfile_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PersonalityProfile_MetadataEntry>, I>>(
    base?: I,
  ): PersonalityProfile_MetadataEntry {
    return PersonalityProfile_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PersonalityProfile_MetadataEntry>, I>>(
    object: I,
  ): PersonalityProfile_MetadataEntry {
    const message = createBasePersonalityProfile_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNeed(): Need {
  return {
    id: "",
    blueprintId: "",
    name: "",
    metadata: {},
    user: undefined,
    campaign: undefined,
    world: undefined,
    description: "",
    type: 0,
    layer: 0,
  };
}

export const Need: MessageFns<Need> = {
  encode(message: Need, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.blueprintId !== "") {
      writer.uint32(18).string(message.blueprintId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      Need_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(42).fork()).join();
    }
    if (message.campaign !== undefined) {
      Campaign.encode(message.campaign, writer.uint32(50).fork()).join();
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(58).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(66).string(message.description);
    }
    if (message.type !== 0) {
      writer.uint32(72).int32(message.type);
    }
    if (message.layer !== 0) {
      writer.uint32(80).int32(message.layer);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Need {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNeed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blueprintId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Need_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.campaign = Campaign.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.layer = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Need {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      blueprintId: isSet(object.blueprintId) ? globalThis.String(object.blueprintId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaign: isSet(object.campaign) ? Campaign.fromJSON(object.campaign) : undefined,
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      type: isSet(object.type) ? needTypeEnumFromJSON(object.type) : 0,
      layer: isSet(object.layer) ? needLayerEnumFromJSON(object.layer) : 0,
    };
  },

  toJSON(message: Need): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.blueprintId !== "") {
      obj.blueprintId = message.blueprintId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaign !== undefined) {
      obj.campaign = Campaign.toJSON(message.campaign);
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.type !== 0) {
      obj.type = needTypeEnumToJSON(message.type);
    }
    if (message.layer !== 0) {
      obj.layer = needLayerEnumToJSON(message.layer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Need>, I>>(base?: I): Need {
    return Need.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Need>, I>>(object: I): Need {
    const message = createBaseNeed();
    message.id = object.id ?? "";
    message.blueprintId = object.blueprintId ?? "";
    message.name = object.name ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaign = (object.campaign !== undefined && object.campaign !== null)
      ? Campaign.fromPartial(object.campaign)
      : undefined;
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.description = object.description ?? "";
    message.type = object.type ?? 0;
    message.layer = object.layer ?? 0;
    return message;
  },
};

function createBaseNeed_MetadataEntry(): Need_MetadataEntry {
  return { key: "", value: "" };
}

export const Need_MetadataEntry: MessageFns<Need_MetadataEntry> = {
  encode(message: Need_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Need_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNeed_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Need_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Need_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Need_MetadataEntry>, I>>(base?: I): Need_MetadataEntry {
    return Need_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Need_MetadataEntry>, I>>(object: I): Need_MetadataEntry {
    const message = createBaseNeed_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUser(): User {
  return {
    id: "",
    name: "",
    worlds: [],
    campaigns: [],
    items: [],
    pastExperiences: [],
    characterMemories: [],
    memories: [],
    memoryPools: [],
    memoryPoolEntries: [],
    skills: [],
    traits: [],
    addictions: [],
    birthsigns: [],
    characters: [],
    characterProfessions: [],
    diseases: [],
    effects: [],
    facts: [],
    factions: [],
    storageSlots: [],
    equipmentSlots: [],
    itemSets: [],
    moods: [],
    needs: [],
    personalityProfiles: [],
    races: [],
    religions: [],
    resistances: [],
    statuses: [],
    tags: [],
    backgrounds: [],
  };
}

export const User: MessageFns<User> = {
  encode(message: User, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    for (const v of message.worlds) {
      World.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.campaigns) {
      Campaign.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.items) {
      Item.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.pastExperiences) {
      PastExperience.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.characterMemories) {
      CharacterMemory.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.memories) {
      Memory.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.memoryPools) {
      MemoryPool.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.memoryPoolEntries) {
      MemoryPoolEntry.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.skills) {
      Skill.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.traits) {
      Trait.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.addictions) {
      Addiction.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.birthsigns) {
      Birthsign.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.characterProfessions) {
      CharacterProfession.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.diseases) {
      Disease.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.effects) {
      Effect.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.facts) {
      Fact.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.factions) {
      Faction.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.storageSlots) {
      StorageSlot.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.equipmentSlots) {
      EquipmentSlot.encode(v!, writer.uint32(178).fork()).join();
    }
    for (const v of message.itemSets) {
      ItemSet.encode(v!, writer.uint32(186).fork()).join();
    }
    for (const v of message.moods) {
      Mood.encode(v!, writer.uint32(194).fork()).join();
    }
    for (const v of message.needs) {
      Need.encode(v!, writer.uint32(202).fork()).join();
    }
    for (const v of message.personalityProfiles) {
      PersonalityProfile.encode(v!, writer.uint32(210).fork()).join();
    }
    for (const v of message.races) {
      Race.encode(v!, writer.uint32(218).fork()).join();
    }
    for (const v of message.religions) {
      Religion.encode(v!, writer.uint32(226).fork()).join();
    }
    for (const v of message.resistances) {
      Resistance.encode(v!, writer.uint32(234).fork()).join();
    }
    for (const v of message.statuses) {
      Status.encode(v!, writer.uint32(242).fork()).join();
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(250).fork()).join();
    }
    for (const v of message.backgrounds) {
      Background.encode(v!, writer.uint32(258).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): User {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.worlds.push(World.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.campaigns.push(Campaign.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.items.push(Item.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pastExperiences.push(PastExperience.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.characterMemories.push(CharacterMemory.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.memories.push(Memory.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.memoryPools.push(MemoryPool.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.memoryPoolEntries.push(MemoryPoolEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.skills.push(Skill.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.traits.push(Trait.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.addictions.push(Addiction.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.birthsigns.push(Birthsign.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.characterProfessions.push(CharacterProfession.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.diseases.push(Disease.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.facts.push(Fact.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.factions.push(Faction.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.storageSlots.push(StorageSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.equipmentSlots.push(EquipmentSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.itemSets.push(ItemSet.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.moods.push(Mood.decode(reader, reader.uint32()));
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.needs.push(Need.decode(reader, reader.uint32()));
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.personalityProfiles.push(PersonalityProfile.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.races.push(Race.decode(reader, reader.uint32()));
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.religions.push(Religion.decode(reader, reader.uint32()));
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.resistances.push(Resistance.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.statuses.push(Status.decode(reader, reader.uint32()));
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.backgrounds.push(Background.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): User {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      worlds: globalThis.Array.isArray(object?.worlds) ? object.worlds.map((e: any) => World.fromJSON(e)) : [],
      campaigns: globalThis.Array.isArray(object?.campaigns)
        ? object.campaigns.map((e: any) => Campaign.fromJSON(e))
        : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Item.fromJSON(e)) : [],
      pastExperiences: globalThis.Array.isArray(object?.pastExperiences)
        ? object.pastExperiences.map((e: any) => PastExperience.fromJSON(e))
        : [],
      characterMemories: globalThis.Array.isArray(object?.characterMemories)
        ? object.characterMemories.map((e: any) => CharacterMemory.fromJSON(e))
        : [],
      memories: globalThis.Array.isArray(object?.memories) ? object.memories.map((e: any) => Memory.fromJSON(e)) : [],
      memoryPools: globalThis.Array.isArray(object?.memoryPools)
        ? object.memoryPools.map((e: any) => MemoryPool.fromJSON(e))
        : [],
      memoryPoolEntries: globalThis.Array.isArray(object?.memoryPoolEntries)
        ? object.memoryPoolEntries.map((e: any) => MemoryPoolEntry.fromJSON(e))
        : [],
      skills: globalThis.Array.isArray(object?.skills) ? object.skills.map((e: any) => Skill.fromJSON(e)) : [],
      traits: globalThis.Array.isArray(object?.traits) ? object.traits.map((e: any) => Trait.fromJSON(e)) : [],
      addictions: globalThis.Array.isArray(object?.addictions)
        ? object.addictions.map((e: any) => Addiction.fromJSON(e))
        : [],
      birthsigns: globalThis.Array.isArray(object?.birthsigns)
        ? object.birthsigns.map((e: any) => Birthsign.fromJSON(e))
        : [],
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
      characterProfessions: globalThis.Array.isArray(object?.characterProfessions)
        ? object.characterProfessions.map((e: any) => CharacterProfession.fromJSON(e))
        : [],
      diseases: globalThis.Array.isArray(object?.diseases) ? object.diseases.map((e: any) => Disease.fromJSON(e)) : [],
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => Effect.fromJSON(e)) : [],
      facts: globalThis.Array.isArray(object?.facts) ? object.facts.map((e: any) => Fact.fromJSON(e)) : [],
      factions: globalThis.Array.isArray(object?.factions) ? object.factions.map((e: any) => Faction.fromJSON(e)) : [],
      storageSlots: globalThis.Array.isArray(object?.storageSlots)
        ? object.storageSlots.map((e: any) => StorageSlot.fromJSON(e))
        : [],
      equipmentSlots: globalThis.Array.isArray(object?.equipmentSlots)
        ? object.equipmentSlots.map((e: any) => EquipmentSlot.fromJSON(e))
        : [],
      itemSets: globalThis.Array.isArray(object?.itemSets)
        ? object.itemSets.map((e: any) => ItemSet.fromJSON(e))
        : [],
      moods: globalThis.Array.isArray(object?.moods) ? object.moods.map((e: any) => Mood.fromJSON(e)) : [],
      needs: globalThis.Array.isArray(object?.needs) ? object.needs.map((e: any) => Need.fromJSON(e)) : [],
      personalityProfiles: globalThis.Array.isArray(object?.personalityProfiles)
        ? object.personalityProfiles.map((e: any) => PersonalityProfile.fromJSON(e))
        : [],
      races: globalThis.Array.isArray(object?.races)
        ? object.races.map((e: any) => Race.fromJSON(e))
        : [],
      religions: globalThis.Array.isArray(object?.religions)
        ? object.religions.map((e: any) => Religion.fromJSON(e))
        : [],
      resistances: globalThis.Array.isArray(object?.resistances)
        ? object.resistances.map((e: any) => Resistance.fromJSON(e))
        : [],
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => Status.fromJSON(e)) : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => Tag.fromJSON(e)) : [],
      backgrounds: globalThis.Array.isArray(object?.backgrounds)
        ? object.backgrounds.map((e: any) => Background.fromJSON(e))
        : [],
    };
  },

  toJSON(message: User): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.worlds?.length) {
      obj.worlds = message.worlds.map((e) => World.toJSON(e));
    }
    if (message.campaigns?.length) {
      obj.campaigns = message.campaigns.map((e) => Campaign.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Item.toJSON(e));
    }
    if (message.pastExperiences?.length) {
      obj.pastExperiences = message.pastExperiences.map((e) => PastExperience.toJSON(e));
    }
    if (message.characterMemories?.length) {
      obj.characterMemories = message.characterMemories.map((e) => CharacterMemory.toJSON(e));
    }
    if (message.memories?.length) {
      obj.memories = message.memories.map((e) => Memory.toJSON(e));
    }
    if (message.memoryPools?.length) {
      obj.memoryPools = message.memoryPools.map((e) => MemoryPool.toJSON(e));
    }
    if (message.memoryPoolEntries?.length) {
      obj.memoryPoolEntries = message.memoryPoolEntries.map((e) => MemoryPoolEntry.toJSON(e));
    }
    if (message.skills?.length) {
      obj.skills = message.skills.map((e) => Skill.toJSON(e));
    }
    if (message.traits?.length) {
      obj.traits = message.traits.map((e) => Trait.toJSON(e));
    }
    if (message.addictions?.length) {
      obj.addictions = message.addictions.map((e) => Addiction.toJSON(e));
    }
    if (message.birthsigns?.length) {
      obj.birthsigns = message.birthsigns.map((e) => Birthsign.toJSON(e));
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    if (message.characterProfessions?.length) {
      obj.characterProfessions = message.characterProfessions.map((e) => CharacterProfession.toJSON(e));
    }
    if (message.diseases?.length) {
      obj.diseases = message.diseases.map((e) => Disease.toJSON(e));
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    if (message.facts?.length) {
      obj.facts = message.facts.map((e) => Fact.toJSON(e));
    }
    if (message.factions?.length) {
      obj.factions = message.factions.map((e) => Faction.toJSON(e));
    }
    if (message.storageSlots?.length) {
      obj.storageSlots = message.storageSlots.map((e) => StorageSlot.toJSON(e));
    }
    if (message.equipmentSlots?.length) {
      obj.equipmentSlots = message.equipmentSlots.map((e) => EquipmentSlot.toJSON(e));
    }
    if (message.itemSets?.length) {
      obj.itemSets = message.itemSets.map((e) => ItemSet.toJSON(e));
    }
    if (message.moods?.length) {
      obj.moods = message.moods.map((e) => Mood.toJSON(e));
    }
    if (message.needs?.length) {
      obj.needs = message.needs.map((e) => Need.toJSON(e));
    }
    if (message.personalityProfiles?.length) {
      obj.personalityProfiles = message.personalityProfiles.map((e) => PersonalityProfile.toJSON(e));
    }
    if (message.races?.length) {
      obj.races = message.races.map((e) => Race.toJSON(e));
    }
    if (message.religions?.length) {
      obj.religions = message.religions.map((e) => Religion.toJSON(e));
    }
    if (message.resistances?.length) {
      obj.resistances = message.resistances.map((e) => Resistance.toJSON(e));
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => Status.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Tag.toJSON(e));
    }
    if (message.backgrounds?.length) {
      obj.backgrounds = message.backgrounds.map((e) => Background.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<User>, I>>(base?: I): User {
    return User.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<User>, I>>(object: I): User {
    const message = createBaseUser();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.worlds = object.worlds?.map((e) => World.fromPartial(e)) || [];
    message.campaigns = object.campaigns?.map((e) => Campaign.fromPartial(e)) || [];
    message.items = object.items?.map((e) => Item.fromPartial(e)) || [];
    message.pastExperiences = object.pastExperiences?.map((e) => PastExperience.fromPartial(e)) || [];
    message.characterMemories = object.characterMemories?.map((e) => CharacterMemory.fromPartial(e)) || [];
    message.memories = object.memories?.map((e) => Memory.fromPartial(e)) || [];
    message.memoryPools = object.memoryPools?.map((e) => MemoryPool.fromPartial(e)) || [];
    message.memoryPoolEntries = object.memoryPoolEntries?.map((e) => MemoryPoolEntry.fromPartial(e)) || [];
    message.skills = object.skills?.map((e) => Skill.fromPartial(e)) || [];
    message.traits = object.traits?.map((e) => Trait.fromPartial(e)) || [];
    message.addictions = object.addictions?.map((e) => Addiction.fromPartial(e)) || [];
    message.birthsigns = object.birthsigns?.map((e) => Birthsign.fromPartial(e)) || [];
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    message.characterProfessions = object.characterProfessions?.map((e) => CharacterProfession.fromPartial(e)) || [];
    message.diseases = object.diseases?.map((e) => Disease.fromPartial(e)) || [];
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    message.facts = object.facts?.map((e) => Fact.fromPartial(e)) || [];
    message.factions = object.factions?.map((e) => Faction.fromPartial(e)) || [];
    message.storageSlots = object.storageSlots?.map((e) => StorageSlot.fromPartial(e)) || [];
    message.equipmentSlots = object.equipmentSlots?.map((e) => EquipmentSlot.fromPartial(e)) || [];
    message.itemSets = object.itemSets?.map((e) => ItemSet.fromPartial(e)) || [];
    message.moods = object.moods?.map((e) => Mood.fromPartial(e)) || [];
    message.needs = object.needs?.map((e) => Need.fromPartial(e)) || [];
    message.personalityProfiles = object.personalityProfiles?.map((e) => PersonalityProfile.fromPartial(e)) || [];
    message.races = object.races?.map((e) => Race.fromPartial(e)) || [];
    message.religions = object.religions?.map((e) => Religion.fromPartial(e)) || [];
    message.resistances = object.resistances?.map((e) => Resistance.fromPartial(e)) || [];
    message.statuses = object.statuses?.map((e) => Status.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
    message.backgrounds = object.backgrounds?.map((e) => Background.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorld(): World {
  return {
    id: "",
    name: "",
    description: "",
    settings: {},
    frozen: false,
    user: undefined,
    campaigns: [],
    items: [],
    pastExperiences: [],
    characterMemories: [],
    memories: [],
    memoryPools: [],
    memoryPoolEntries: [],
    skills: [],
    traits: [],
    addictions: [],
    birthsigns: [],
    characters: [],
    characterProfessions: [],
    diseases: [],
    effects: [],
    facts: [],
    factions: [],
    storageSlots: [],
    equipmentSlots: [],
    itemSets: [],
    moods: [],
    needs: [],
    personalityProfiles: [],
    races: [],
    religions: [],
    resistances: [],
    statuses: [],
    tags: [],
    backgrounds: [],
  };
}

export const World: MessageFns<World> = {
  encode(message: World, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.settings).forEach(([key, value]) => {
      World_SettingsEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.frozen !== false) {
      writer.uint32(40).bool(message.frozen);
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(50).fork()).join();
    }
    for (const v of message.campaigns) {
      Campaign.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.items) {
      Item.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.pastExperiences) {
      PastExperience.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.characterMemories) {
      CharacterMemory.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.memories) {
      Memory.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.memoryPools) {
      MemoryPool.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.memoryPoolEntries) {
      MemoryPoolEntry.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.skills) {
      Skill.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.traits) {
      Trait.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.addictions) {
      Addiction.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.birthsigns) {
      Birthsign.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.characterProfessions) {
      CharacterProfession.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.diseases) {
      Disease.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.effects) {
      Effect.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.facts) {
      Fact.encode(v!, writer.uint32(178).fork()).join();
    }
    for (const v of message.factions) {
      Faction.encode(v!, writer.uint32(186).fork()).join();
    }
    for (const v of message.storageSlots) {
      StorageSlot.encode(v!, writer.uint32(194).fork()).join();
    }
    for (const v of message.equipmentSlots) {
      EquipmentSlot.encode(v!, writer.uint32(202).fork()).join();
    }
    for (const v of message.itemSets) {
      ItemSet.encode(v!, writer.uint32(210).fork()).join();
    }
    for (const v of message.moods) {
      Mood.encode(v!, writer.uint32(218).fork()).join();
    }
    for (const v of message.needs) {
      Need.encode(v!, writer.uint32(226).fork()).join();
    }
    for (const v of message.personalityProfiles) {
      PersonalityProfile.encode(v!, writer.uint32(234).fork()).join();
    }
    for (const v of message.races) {
      Race.encode(v!, writer.uint32(242).fork()).join();
    }
    for (const v of message.religions) {
      Religion.encode(v!, writer.uint32(250).fork()).join();
    }
    for (const v of message.resistances) {
      Resistance.encode(v!, writer.uint32(258).fork()).join();
    }
    for (const v of message.statuses) {
      Status.encode(v!, writer.uint32(266).fork()).join();
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(274).fork()).join();
    }
    for (const v of message.backgrounds) {
      Background.encode(v!, writer.uint32(282).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): World {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorld();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = World_SettingsEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.settings[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.frozen = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.campaigns.push(Campaign.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.items.push(Item.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pastExperiences.push(PastExperience.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.characterMemories.push(CharacterMemory.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.memories.push(Memory.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.memoryPools.push(MemoryPool.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.memoryPoolEntries.push(MemoryPoolEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.skills.push(Skill.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.traits.push(Trait.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.addictions.push(Addiction.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.birthsigns.push(Birthsign.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.characterProfessions.push(CharacterProfession.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.diseases.push(Disease.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.facts.push(Fact.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.factions.push(Faction.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.storageSlots.push(StorageSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.equipmentSlots.push(EquipmentSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.itemSets.push(ItemSet.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.moods.push(Mood.decode(reader, reader.uint32()));
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.needs.push(Need.decode(reader, reader.uint32()));
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.personalityProfiles.push(PersonalityProfile.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.races.push(Race.decode(reader, reader.uint32()));
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.religions.push(Religion.decode(reader, reader.uint32()));
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.resistances.push(Resistance.decode(reader, reader.uint32()));
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.statuses.push(Status.decode(reader, reader.uint32()));
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.backgrounds.push(Background.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): World {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      settings: isObject(object.settings)
        ? Object.entries(object.settings).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      frozen: isSet(object.frozen) ? globalThis.Boolean(object.frozen) : false,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      campaigns: globalThis.Array.isArray(object?.campaigns)
        ? object.campaigns.map((e: any) => Campaign.fromJSON(e))
        : [],
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Item.fromJSON(e)) : [],
      pastExperiences: globalThis.Array.isArray(object?.pastExperiences)
        ? object.pastExperiences.map((e: any) => PastExperience.fromJSON(e))
        : [],
      characterMemories: globalThis.Array.isArray(object?.characterMemories)
        ? object.characterMemories.map((e: any) => CharacterMemory.fromJSON(e))
        : [],
      memories: globalThis.Array.isArray(object?.memories)
        ? object.memories.map((e: any) => Memory.fromJSON(e))
        : [],
      memoryPools: globalThis.Array.isArray(object?.memoryPools)
        ? object.memoryPools.map((e: any) => MemoryPool.fromJSON(e))
        : [],
      memoryPoolEntries: globalThis.Array.isArray(object?.memoryPoolEntries)
        ? object.memoryPoolEntries.map((e: any) => MemoryPoolEntry.fromJSON(e))
        : [],
      skills: globalThis.Array.isArray(object?.skills) ? object.skills.map((e: any) => Skill.fromJSON(e)) : [],
      traits: globalThis.Array.isArray(object?.traits) ? object.traits.map((e: any) => Trait.fromJSON(e)) : [],
      addictions: globalThis.Array.isArray(object?.addictions)
        ? object.addictions.map((e: any) => Addiction.fromJSON(e))
        : [],
      birthsigns: globalThis.Array.isArray(object?.birthsigns)
        ? object.birthsigns.map((e: any) => Birthsign.fromJSON(e))
        : [],
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
      characterProfessions: globalThis.Array.isArray(object?.characterProfessions)
        ? object.characterProfessions.map((e: any) => CharacterProfession.fromJSON(e))
        : [],
      diseases: globalThis.Array.isArray(object?.diseases) ? object.diseases.map((e: any) => Disease.fromJSON(e)) : [],
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => Effect.fromJSON(e)) : [],
      facts: globalThis.Array.isArray(object?.facts) ? object.facts.map((e: any) => Fact.fromJSON(e)) : [],
      factions: globalThis.Array.isArray(object?.factions) ? object.factions.map((e: any) => Faction.fromJSON(e)) : [],
      storageSlots: globalThis.Array.isArray(object?.storageSlots)
        ? object.storageSlots.map((e: any) => StorageSlot.fromJSON(e))
        : [],
      equipmentSlots: globalThis.Array.isArray(object?.equipmentSlots)
        ? object.equipmentSlots.map((e: any) => EquipmentSlot.fromJSON(e))
        : [],
      itemSets: globalThis.Array.isArray(object?.itemSets)
        ? object.itemSets.map((e: any) => ItemSet.fromJSON(e))
        : [],
      moods: globalThis.Array.isArray(object?.moods) ? object.moods.map((e: any) => Mood.fromJSON(e)) : [],
      needs: globalThis.Array.isArray(object?.needs) ? object.needs.map((e: any) => Need.fromJSON(e)) : [],
      personalityProfiles: globalThis.Array.isArray(object?.personalityProfiles)
        ? object.personalityProfiles.map((e: any) => PersonalityProfile.fromJSON(e))
        : [],
      races: globalThis.Array.isArray(object?.races)
        ? object.races.map((e: any) => Race.fromJSON(e))
        : [],
      religions: globalThis.Array.isArray(object?.religions)
        ? object.religions.map((e: any) => Religion.fromJSON(e))
        : [],
      resistances: globalThis.Array.isArray(object?.resistances)
        ? object.resistances.map((e: any) => Resistance.fromJSON(e))
        : [],
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => Status.fromJSON(e)) : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => Tag.fromJSON(e)) : [],
      backgrounds: globalThis.Array.isArray(object?.backgrounds)
        ? object.backgrounds.map((e: any) => Background.fromJSON(e))
        : [],
    };
  },

  toJSON(message: World): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.settings) {
      const entries = Object.entries(message.settings);
      if (entries.length > 0) {
        obj.settings = {};
        entries.forEach(([k, v]) => {
          obj.settings[k] = v;
        });
      }
    }
    if (message.frozen !== false) {
      obj.frozen = message.frozen;
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.campaigns?.length) {
      obj.campaigns = message.campaigns.map((e) => Campaign.toJSON(e));
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Item.toJSON(e));
    }
    if (message.pastExperiences?.length) {
      obj.pastExperiences = message.pastExperiences.map((e) => PastExperience.toJSON(e));
    }
    if (message.characterMemories?.length) {
      obj.characterMemories = message.characterMemories.map((e) => CharacterMemory.toJSON(e));
    }
    if (message.memories?.length) {
      obj.memories = message.memories.map((e) => Memory.toJSON(e));
    }
    if (message.memoryPools?.length) {
      obj.memoryPools = message.memoryPools.map((e) => MemoryPool.toJSON(e));
    }
    if (message.memoryPoolEntries?.length) {
      obj.memoryPoolEntries = message.memoryPoolEntries.map((e) => MemoryPoolEntry.toJSON(e));
    }
    if (message.skills?.length) {
      obj.skills = message.skills.map((e) => Skill.toJSON(e));
    }
    if (message.traits?.length) {
      obj.traits = message.traits.map((e) => Trait.toJSON(e));
    }
    if (message.addictions?.length) {
      obj.addictions = message.addictions.map((e) => Addiction.toJSON(e));
    }
    if (message.birthsigns?.length) {
      obj.birthsigns = message.birthsigns.map((e) => Birthsign.toJSON(e));
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    if (message.characterProfessions?.length) {
      obj.characterProfessions = message.characterProfessions.map((e) => CharacterProfession.toJSON(e));
    }
    if (message.diseases?.length) {
      obj.diseases = message.diseases.map((e) => Disease.toJSON(e));
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    if (message.facts?.length) {
      obj.facts = message.facts.map((e) => Fact.toJSON(e));
    }
    if (message.factions?.length) {
      obj.factions = message.factions.map((e) => Faction.toJSON(e));
    }
    if (message.storageSlots?.length) {
      obj.storageSlots = message.storageSlots.map((e) => StorageSlot.toJSON(e));
    }
    if (message.equipmentSlots?.length) {
      obj.equipmentSlots = message.equipmentSlots.map((e) => EquipmentSlot.toJSON(e));
    }
    if (message.itemSets?.length) {
      obj.itemSets = message.itemSets.map((e) => ItemSet.toJSON(e));
    }
    if (message.moods?.length) {
      obj.moods = message.moods.map((e) => Mood.toJSON(e));
    }
    if (message.needs?.length) {
      obj.needs = message.needs.map((e) => Need.toJSON(e));
    }
    if (message.personalityProfiles?.length) {
      obj.personalityProfiles = message.personalityProfiles.map((e) => PersonalityProfile.toJSON(e));
    }
    if (message.races?.length) {
      obj.races = message.races.map((e) => Race.toJSON(e));
    }
    if (message.religions?.length) {
      obj.religions = message.religions.map((e) => Religion.toJSON(e));
    }
    if (message.resistances?.length) {
      obj.resistances = message.resistances.map((e) => Resistance.toJSON(e));
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => Status.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Tag.toJSON(e));
    }
    if (message.backgrounds?.length) {
      obj.backgrounds = message.backgrounds.map((e) => Background.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<World>, I>>(base?: I): World {
    return World.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<World>, I>>(object: I): World {
    const message = createBaseWorld();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.settings = Object.entries(object.settings ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.frozen = object.frozen ?? false;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.campaigns = object.campaigns?.map((e) => Campaign.fromPartial(e)) || [];
    message.items = object.items?.map((e) => Item.fromPartial(e)) || [];
    message.pastExperiences = object.pastExperiences?.map((e) => PastExperience.fromPartial(e)) || [];
    message.characterMemories = object.characterMemories?.map((e) => CharacterMemory.fromPartial(e)) || [];
    message.memories = object.memories?.map((e) => Memory.fromPartial(e)) || [];
    message.memoryPools = object.memoryPools?.map((e) => MemoryPool.fromPartial(e)) || [];
    message.memoryPoolEntries = object.memoryPoolEntries?.map((e) => MemoryPoolEntry.fromPartial(e)) || [];
    message.skills = object.skills?.map((e) => Skill.fromPartial(e)) || [];
    message.traits = object.traits?.map((e) => Trait.fromPartial(e)) || [];
    message.addictions = object.addictions?.map((e) => Addiction.fromPartial(e)) || [];
    message.birthsigns = object.birthsigns?.map((e) => Birthsign.fromPartial(e)) || [];
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    message.characterProfessions = object.characterProfessions?.map((e) => CharacterProfession.fromPartial(e)) || [];
    message.diseases = object.diseases?.map((e) => Disease.fromPartial(e)) || [];
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    message.facts = object.facts?.map((e) => Fact.fromPartial(e)) || [];
    message.factions = object.factions?.map((e) => Faction.fromPartial(e)) || [];
    message.storageSlots = object.storageSlots?.map((e) => StorageSlot.fromPartial(e)) || [];
    message.equipmentSlots = object.equipmentSlots?.map((e) => EquipmentSlot.fromPartial(e)) || [];
    message.itemSets = object.itemSets?.map((e) => ItemSet.fromPartial(e)) || [];
    message.moods = object.moods?.map((e) => Mood.fromPartial(e)) || [];
    message.needs = object.needs?.map((e) => Need.fromPartial(e)) || [];
    message.personalityProfiles = object.personalityProfiles?.map((e) => PersonalityProfile.fromPartial(e)) || [];
    message.races = object.races?.map((e) => Race.fromPartial(e)) || [];
    message.religions = object.religions?.map((e) => Religion.fromPartial(e)) || [];
    message.resistances = object.resistances?.map((e) => Resistance.fromPartial(e)) || [];
    message.statuses = object.statuses?.map((e) => Status.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
    message.backgrounds = object.backgrounds?.map((e) => Background.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorld_SettingsEntry(): World_SettingsEntry {
  return { key: "", value: "" };
}

export const World_SettingsEntry: MessageFns<World_SettingsEntry> = {
  encode(message: World_SettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): World_SettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorld_SettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): World_SettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: World_SettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<World_SettingsEntry>, I>>(base?: I): World_SettingsEntry {
    return World_SettingsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<World_SettingsEntry>, I>>(object: I): World_SettingsEntry {
    const message = createBaseWorld_SettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCampaign(): Campaign {
  return {
    id: "",
    name: "",
    description: "",
    dynamicState: {},
    createdAt: "",
    world: undefined,
    user: undefined,
    items: [],
    pastExperiences: [],
    characterMemories: [],
    memories: [],
    memoryPools: [],
    memoryPoolEntries: [],
    skills: [],
    traits: [],
    addictions: [],
    birthsigns: [],
    characters: [],
    characterProfessions: [],
    diseases: [],
    effects: [],
    facts: [],
    factions: [],
    storageSlots: [],
    equipmentSlots: [],
    itemSets: [],
    moods: [],
    needs: [],
    personalityProfiles: [],
    races: [],
    religions: [],
    resistances: [],
    statuses: [],
    tags: [],
    backgrounds: [],
  };
}

export const Campaign: MessageFns<Campaign> = {
  encode(message: Campaign, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    Object.entries(message.dynamicState).forEach(([key, value]) => {
      Campaign_DynamicStateEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.world !== undefined) {
      World.encode(message.world, writer.uint32(50).fork()).join();
    }
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(58).fork()).join();
    }
    for (const v of message.items) {
      Item.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.pastExperiences) {
      PastExperience.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.characterMemories) {
      CharacterMemory.encode(v!, writer.uint32(82).fork()).join();
    }
    for (const v of message.memories) {
      Memory.encode(v!, writer.uint32(90).fork()).join();
    }
    for (const v of message.memoryPools) {
      MemoryPool.encode(v!, writer.uint32(98).fork()).join();
    }
    for (const v of message.memoryPoolEntries) {
      MemoryPoolEntry.encode(v!, writer.uint32(106).fork()).join();
    }
    for (const v of message.skills) {
      Skill.encode(v!, writer.uint32(114).fork()).join();
    }
    for (const v of message.traits) {
      Trait.encode(v!, writer.uint32(122).fork()).join();
    }
    for (const v of message.addictions) {
      Addiction.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.birthsigns) {
      Birthsign.encode(v!, writer.uint32(138).fork()).join();
    }
    for (const v of message.characters) {
      Character.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.characterProfessions) {
      CharacterProfession.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.diseases) {
      Disease.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.effects) {
      Effect.encode(v!, writer.uint32(170).fork()).join();
    }
    for (const v of message.facts) {
      Fact.encode(v!, writer.uint32(178).fork()).join();
    }
    for (const v of message.factions) {
      Faction.encode(v!, writer.uint32(186).fork()).join();
    }
    for (const v of message.storageSlots) {
      StorageSlot.encode(v!, writer.uint32(194).fork()).join();
    }
    for (const v of message.equipmentSlots) {
      EquipmentSlot.encode(v!, writer.uint32(202).fork()).join();
    }
    for (const v of message.itemSets) {
      ItemSet.encode(v!, writer.uint32(210).fork()).join();
    }
    for (const v of message.moods) {
      Mood.encode(v!, writer.uint32(218).fork()).join();
    }
    for (const v of message.needs) {
      Need.encode(v!, writer.uint32(226).fork()).join();
    }
    for (const v of message.personalityProfiles) {
      PersonalityProfile.encode(v!, writer.uint32(234).fork()).join();
    }
    for (const v of message.races) {
      Race.encode(v!, writer.uint32(242).fork()).join();
    }
    for (const v of message.religions) {
      Religion.encode(v!, writer.uint32(250).fork()).join();
    }
    for (const v of message.resistances) {
      Resistance.encode(v!, writer.uint32(258).fork()).join();
    }
    for (const v of message.statuses) {
      Status.encode(v!, writer.uint32(266).fork()).join();
    }
    for (const v of message.tags) {
      Tag.encode(v!, writer.uint32(274).fork()).join();
    }
    for (const v of message.backgrounds) {
      Background.encode(v!, writer.uint32(282).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Campaign {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaign();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = Campaign_DynamicStateEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.dynamicState[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.world = World.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.items.push(Item.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.pastExperiences.push(PastExperience.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.characterMemories.push(CharacterMemory.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.memories.push(Memory.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.memoryPools.push(MemoryPool.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.memoryPoolEntries.push(MemoryPoolEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.skills.push(Skill.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.traits.push(Trait.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.addictions.push(Addiction.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.birthsigns.push(Birthsign.decode(reader, reader.uint32()));
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.characters.push(Character.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.characterProfessions.push(CharacterProfession.decode(reader, reader.uint32()));
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.diseases.push(Disease.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.effects.push(Effect.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.facts.push(Fact.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.factions.push(Faction.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.storageSlots.push(StorageSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.equipmentSlots.push(EquipmentSlot.decode(reader, reader.uint32()));
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.itemSets.push(ItemSet.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.moods.push(Mood.decode(reader, reader.uint32()));
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.needs.push(Need.decode(reader, reader.uint32()));
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.personalityProfiles.push(PersonalityProfile.decode(reader, reader.uint32()));
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.races.push(Race.decode(reader, reader.uint32()));
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.religions.push(Religion.decode(reader, reader.uint32()));
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.resistances.push(Resistance.decode(reader, reader.uint32()));
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.statuses.push(Status.decode(reader, reader.uint32()));
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.tags.push(Tag.decode(reader, reader.uint32()));
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.backgrounds.push(Background.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Campaign {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      dynamicState: isObject(object.dynamicState)
        ? Object.entries(object.dynamicState).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      world: isSet(object.world) ? World.fromJSON(object.world) : undefined,
      user: isSet(object.user) ? User.fromJSON(object.user) : undefined,
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Item.fromJSON(e)) : [],
      pastExperiences: globalThis.Array.isArray(object?.pastExperiences)
        ? object.pastExperiences.map((e: any) => PastExperience.fromJSON(e))
        : [],
      characterMemories: globalThis.Array.isArray(object?.characterMemories)
        ? object.characterMemories.map((e: any) => CharacterMemory.fromJSON(e))
        : [],
      memories: globalThis.Array.isArray(object?.memories) ? object.memories.map((e: any) => Memory.fromJSON(e)) : [],
      memoryPools: globalThis.Array.isArray(object?.memoryPools)
        ? object.memoryPools.map((e: any) => MemoryPool.fromJSON(e))
        : [],
      memoryPoolEntries: globalThis.Array.isArray(object?.memoryPoolEntries)
        ? object.memoryPoolEntries.map((e: any) => MemoryPoolEntry.fromJSON(e))
        : [],
      skills: globalThis.Array.isArray(object?.skills)
        ? object.skills.map((e: any) => Skill.fromJSON(e))
        : [],
      traits: globalThis.Array.isArray(object?.traits) ? object.traits.map((e: any) => Trait.fromJSON(e)) : [],
      addictions: globalThis.Array.isArray(object?.addictions)
        ? object.addictions.map((e: any) => Addiction.fromJSON(e))
        : [],
      birthsigns: globalThis.Array.isArray(object?.birthsigns)
        ? object.birthsigns.map((e: any) => Birthsign.fromJSON(e))
        : [],
      characters: globalThis.Array.isArray(object?.characters)
        ? object.characters.map((e: any) => Character.fromJSON(e))
        : [],
      characterProfessions: globalThis.Array.isArray(object?.characterProfessions)
        ? object.characterProfessions.map((e: any) => CharacterProfession.fromJSON(e))
        : [],
      diseases: globalThis.Array.isArray(object?.diseases) ? object.diseases.map((e: any) => Disease.fromJSON(e)) : [],
      effects: globalThis.Array.isArray(object?.effects) ? object.effects.map((e: any) => Effect.fromJSON(e)) : [],
      facts: globalThis.Array.isArray(object?.facts) ? object.facts.map((e: any) => Fact.fromJSON(e)) : [],
      factions: globalThis.Array.isArray(object?.factions) ? object.factions.map((e: any) => Faction.fromJSON(e)) : [],
      storageSlots: globalThis.Array.isArray(object?.storageSlots)
        ? object.storageSlots.map((e: any) => StorageSlot.fromJSON(e))
        : [],
      equipmentSlots: globalThis.Array.isArray(object?.equipmentSlots)
        ? object.equipmentSlots.map((e: any) => EquipmentSlot.fromJSON(e))
        : [],
      itemSets: globalThis.Array.isArray(object?.itemSets)
        ? object.itemSets.map((e: any) => ItemSet.fromJSON(e))
        : [],
      moods: globalThis.Array.isArray(object?.moods) ? object.moods.map((e: any) => Mood.fromJSON(e)) : [],
      needs: globalThis.Array.isArray(object?.needs) ? object.needs.map((e: any) => Need.fromJSON(e)) : [],
      personalityProfiles: globalThis.Array.isArray(object?.personalityProfiles)
        ? object.personalityProfiles.map((e: any) => PersonalityProfile.fromJSON(e))
        : [],
      races: globalThis.Array.isArray(object?.races)
        ? object.races.map((e: any) => Race.fromJSON(e))
        : [],
      religions: globalThis.Array.isArray(object?.religions)
        ? object.religions.map((e: any) => Religion.fromJSON(e))
        : [],
      resistances: globalThis.Array.isArray(object?.resistances)
        ? object.resistances.map((e: any) => Resistance.fromJSON(e))
        : [],
      statuses: globalThis.Array.isArray(object?.statuses) ? object.statuses.map((e: any) => Status.fromJSON(e)) : [],
      tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e: any) => Tag.fromJSON(e)) : [],
      backgrounds: globalThis.Array.isArray(object?.backgrounds)
        ? object.backgrounds.map((e: any) => Background.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Campaign): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.dynamicState) {
      const entries = Object.entries(message.dynamicState);
      if (entries.length > 0) {
        obj.dynamicState = {};
        entries.forEach(([k, v]) => {
          obj.dynamicState[k] = v;
        });
      }
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.world !== undefined) {
      obj.world = World.toJSON(message.world);
    }
    if (message.user !== undefined) {
      obj.user = User.toJSON(message.user);
    }
    if (message.items?.length) {
      obj.items = message.items.map((e) => Item.toJSON(e));
    }
    if (message.pastExperiences?.length) {
      obj.pastExperiences = message.pastExperiences.map((e) => PastExperience.toJSON(e));
    }
    if (message.characterMemories?.length) {
      obj.characterMemories = message.characterMemories.map((e) => CharacterMemory.toJSON(e));
    }
    if (message.memories?.length) {
      obj.memories = message.memories.map((e) => Memory.toJSON(e));
    }
    if (message.memoryPools?.length) {
      obj.memoryPools = message.memoryPools.map((e) => MemoryPool.toJSON(e));
    }
    if (message.memoryPoolEntries?.length) {
      obj.memoryPoolEntries = message.memoryPoolEntries.map((e) => MemoryPoolEntry.toJSON(e));
    }
    if (message.skills?.length) {
      obj.skills = message.skills.map((e) => Skill.toJSON(e));
    }
    if (message.traits?.length) {
      obj.traits = message.traits.map((e) => Trait.toJSON(e));
    }
    if (message.addictions?.length) {
      obj.addictions = message.addictions.map((e) => Addiction.toJSON(e));
    }
    if (message.birthsigns?.length) {
      obj.birthsigns = message.birthsigns.map((e) => Birthsign.toJSON(e));
    }
    if (message.characters?.length) {
      obj.characters = message.characters.map((e) => Character.toJSON(e));
    }
    if (message.characterProfessions?.length) {
      obj.characterProfessions = message.characterProfessions.map((e) => CharacterProfession.toJSON(e));
    }
    if (message.diseases?.length) {
      obj.diseases = message.diseases.map((e) => Disease.toJSON(e));
    }
    if (message.effects?.length) {
      obj.effects = message.effects.map((e) => Effect.toJSON(e));
    }
    if (message.facts?.length) {
      obj.facts = message.facts.map((e) => Fact.toJSON(e));
    }
    if (message.factions?.length) {
      obj.factions = message.factions.map((e) => Faction.toJSON(e));
    }
    if (message.storageSlots?.length) {
      obj.storageSlots = message.storageSlots.map((e) => StorageSlot.toJSON(e));
    }
    if (message.equipmentSlots?.length) {
      obj.equipmentSlots = message.equipmentSlots.map((e) => EquipmentSlot.toJSON(e));
    }
    if (message.itemSets?.length) {
      obj.itemSets = message.itemSets.map((e) => ItemSet.toJSON(e));
    }
    if (message.moods?.length) {
      obj.moods = message.moods.map((e) => Mood.toJSON(e));
    }
    if (message.needs?.length) {
      obj.needs = message.needs.map((e) => Need.toJSON(e));
    }
    if (message.personalityProfiles?.length) {
      obj.personalityProfiles = message.personalityProfiles.map((e) => PersonalityProfile.toJSON(e));
    }
    if (message.races?.length) {
      obj.races = message.races.map((e) => Race.toJSON(e));
    }
    if (message.religions?.length) {
      obj.religions = message.religions.map((e) => Religion.toJSON(e));
    }
    if (message.resistances?.length) {
      obj.resistances = message.resistances.map((e) => Resistance.toJSON(e));
    }
    if (message.statuses?.length) {
      obj.statuses = message.statuses.map((e) => Status.toJSON(e));
    }
    if (message.tags?.length) {
      obj.tags = message.tags.map((e) => Tag.toJSON(e));
    }
    if (message.backgrounds?.length) {
      obj.backgrounds = message.backgrounds.map((e) => Background.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Campaign>, I>>(base?: I): Campaign {
    return Campaign.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Campaign>, I>>(object: I): Campaign {
    const message = createBaseCampaign();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.dynamicState = Object.entries(object.dynamicState ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.createdAt = object.createdAt ?? "";
    message.world = (object.world !== undefined && object.world !== null) ? World.fromPartial(object.world) : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? User.fromPartial(object.user) : undefined;
    message.items = object.items?.map((e) => Item.fromPartial(e)) || [];
    message.pastExperiences = object.pastExperiences?.map((e) => PastExperience.fromPartial(e)) || [];
    message.characterMemories = object.characterMemories?.map((e) => CharacterMemory.fromPartial(e)) || [];
    message.memories = object.memories?.map((e) => Memory.fromPartial(e)) || [];
    message.memoryPools = object.memoryPools?.map((e) => MemoryPool.fromPartial(e)) || [];
    message.memoryPoolEntries = object.memoryPoolEntries?.map((e) => MemoryPoolEntry.fromPartial(e)) || [];
    message.skills = object.skills?.map((e) => Skill.fromPartial(e)) || [];
    message.traits = object.traits?.map((e) => Trait.fromPartial(e)) || [];
    message.addictions = object.addictions?.map((e) => Addiction.fromPartial(e)) || [];
    message.birthsigns = object.birthsigns?.map((e) => Birthsign.fromPartial(e)) || [];
    message.characters = object.characters?.map((e) => Character.fromPartial(e)) || [];
    message.characterProfessions = object.characterProfessions?.map((e) => CharacterProfession.fromPartial(e)) || [];
    message.diseases = object.diseases?.map((e) => Disease.fromPartial(e)) || [];
    message.effects = object.effects?.map((e) => Effect.fromPartial(e)) || [];
    message.facts = object.facts?.map((e) => Fact.fromPartial(e)) || [];
    message.factions = object.factions?.map((e) => Faction.fromPartial(e)) || [];
    message.storageSlots = object.storageSlots?.map((e) => StorageSlot.fromPartial(e)) || [];
    message.equipmentSlots = object.equipmentSlots?.map((e) => EquipmentSlot.fromPartial(e)) || [];
    message.itemSets = object.itemSets?.map((e) => ItemSet.fromPartial(e)) || [];
    message.moods = object.moods?.map((e) => Mood.fromPartial(e)) || [];
    message.needs = object.needs?.map((e) => Need.fromPartial(e)) || [];
    message.personalityProfiles = object.personalityProfiles?.map((e) => PersonalityProfile.fromPartial(e)) || [];
    message.races = object.races?.map((e) => Race.fromPartial(e)) || [];
    message.religions = object.religions?.map((e) => Religion.fromPartial(e)) || [];
    message.resistances = object.resistances?.map((e) => Resistance.fromPartial(e)) || [];
    message.statuses = object.statuses?.map((e) => Status.fromPartial(e)) || [];
    message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
    message.backgrounds = object.backgrounds?.map((e) => Background.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCampaign_DynamicStateEntry(): Campaign_DynamicStateEntry {
  return { key: "", value: "" };
}

export const Campaign_DynamicStateEntry: MessageFns<Campaign_DynamicStateEntry> = {
  encode(message: Campaign_DynamicStateEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Campaign_DynamicStateEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCampaign_DynamicStateEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Campaign_DynamicStateEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Campaign_DynamicStateEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Campaign_DynamicStateEntry>, I>>(base?: I): Campaign_DynamicStateEntry {
    return Campaign_DynamicStateEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Campaign_DynamicStateEntry>, I>>(object: I): Campaign_DynamicStateEntry {
    const message = createBaseCampaign_DynamicStateEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
